import ast
import base64
import mimetypes
import os
import secrets
import string
import uuid
from collections import defaultdict
from datetime import datetime, time, date
from decimal import Decimal
import re
from django.db.models import Count
import json
# from django.conf import settings
from itertools import product
from django.core.mail import send_mail
from django.db.models import Q
from urllib.parse import urljoin

from rest_framework.permissions import IsAuthenticated
from rest_framework.views import APIView

from HOSTEL.models import StudentHostelDetail
from Swostitech_Acadix import settings
from _decimal import InvalidOperation
from django.contrib.auth import authenticate
from django.contrib.auth.hashers import make_password
from django.core.exceptions import ObjectDoesNotExist
from django.core.files.storage import default_storage
from django.db import transaction, DatabaseError, connection
from django.db.models import Q, Max, Sum, Exists, OuterRef
from django.http import Http404
from django.shortcuts import render, get_object_or_404
from django.utils.timezone import now
from rest_framework import status, permissions, generics
from rest_framework.exceptions import ValidationError, NotFound
from rest_framework.generics import CreateAPIView, ListAPIView, RetrieveAPIView, UpdateAPIView, DestroyAPIView
from rest_framework.parsers import MultiPartParser, FormParser
from rest_framework.response import Response
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi

from Swostitech_Acadix import settings
from Transport.models import RouteDetail, RouteMaster, PickupPoint
from .models import UserType, ExceptionTrack, Employee, Login, AcademicYear, Course, Section, \
    SiblingDetail, StudentEmergencyContact, AuthorisedPickup, \
    StudentDocument, StudentPreviousEducation, Organization, Department, StudentRegistration, Parent, StudentCourse, \
    UserLogin, FeeStructureMaster, FeeStructureDetail, Period, FeeFrequency, StudentFeeDetail, Address, \
    FeeElementType, House, Religion, Category, Nationality, Country, \
    State, City, Profession, Document, Language, MotherTongue, Blood, \
    PaymentMethod, CourseDepartmentSubject, StudentFeeReceiptHeader, \
    StudentPayment, StudentFeeReceiptDetail, MessageType, MessageInitiated, StudentMessagesHistory, \
    StudentCircular, Bank, BankAccountDetail, \
     StudentAssignment, EmployeeMaster, TimeTable, Attendance, EmployeeType, StudentClub, Club, \
    ClubGroup, \
    EmployeeDetail, FeeStructureDetail, Lecture, CourseSemesterSectionBind, Semester, PasswordResetOTP, LecturePeriod

from .serializers import *
from .utils import send_otp_email, generate_otp


# from .serializers_new import UserTypeSerializer, EmployeeSerializer, LoginSerializer, LoginModelSerializer, \
#     ChangePasswordSerializer, DetailsSerializer, AcademicYearSerializer, CourseSerializer, SectionSerializer, \
#     CourseSemesterSectionBindSerializer, StudentSiblingDetailSerializer, \
#     StudentEmergencyContactSerializer, AuthorisedPickupSerializer, StudentDocumentSerializer, \
#     StudentPreviousEducationSerializer, OrganizationSerializer, BranchesSerializer, StudentRegistrationSerializer, \
#     StudentCourseSerializer, FeeStructureMasterSerializer, FeeStructureDetailSerializer, \
#     FeeStructureDetailUpdateSerializer, AcademicSessionUpdateYear, PeriodSerializer, PeriodUpdateSerializer, \
#     UserTypeUpdateSerializer, OrganizationUpdateSerializer, BranchesUpdateSerializer, CourseUpdateSerializer, \
#     SectionUpdateSerializer, CourseSemesterSectionBindUpdateSerializer, SiblingDetailUpdateSerializer, \
#     StudentEmergencyUpdateContactSerializer, AuthorisedPickupUpdateSerializer, StudentDocumentUpdateSerializer, \
#     StudentPreviousEducationUpdateSerializer, AddressSerializer, AddressUpdatedSerializer, \
#     StudentDetailsGetSerializer, StudentFeeDetailSerializer, FeeElementTypeSerializer, InsertFeesForSelectedStudent, \
#     HouseSerializer, ReligionSerializer, CategorySerializer, NationalitySerializer, \
#     CountrySerializer, StateSerializer, CitySerializer, ProfessionSerializer, \
#     DocumentSerializer, BloodSerializer, LanguageSerializer, StudentPromotionSerializer, \
#     StudentRegistrationSerializer, FeeStructureMasterRequestSerializer, StudentBasicDetailSerializer, \
#     StudentSibilingDetailSerializer, StudentEmergencyContactDetailsSerializer, AuthorisedPickupDetailsSerializer, \
#     StudentDocumentDetailsSerializer, StudentPreviousEducationDetailsSerializer, AddressDetailsSerializer, \
#     StudentFeeAppliedDetails, StudentRegistrationUpdateSerializer, StudentFilterSerializer, studentfeeManageSerializer, \
#     FeeFrequencySerializer, CopyfeestructureSerializers, FeeStructureDetailsSerializer, GetSubjectMasterListSerializer, \
#     StudentGetBasedOnCourseSectionSerializer, FeeElementSerializer, StudentGroupBasedOnCourseSection, \
#     ClubUpdateSerializer, studentfilterbasedonidbarcodeadmissionnoSerializer, GLPaymentMethodSerializer, \
#     SubjectGroupsSerializer, StdFeeReceiptSerializer, studentfeereceiptserachSerializer, \
#     _Message_TypeSerializer, _Message_InitiatedSerializer, _StudentMessageHistorySerializer, \
#     _StudentMessageHistoryFilterSerializer, StdFeeReceiptCancelSerializer, \
#     StudentCircularSerializer, \
#     circularSerializerMessage, _SearchStudentListAPIView, studentclassUpdateSerializer, FeeReciptUpdateSerializer, \
#     BANKSERIALIZER, AccountDetailsSerializer, FeeLedgerSerializer, studentsearchconfirmSerializer, \
#     StudentFeeDueReceiptSerializer, StudentFeeBalanceReceiptSerializer, StudentPaymentMethodWiseFeesSerializer, \
#     CertificateSerializer, TransferCertificateFilterSerializer, studentperiodwiseSerializer, \
#     GetCertificateDetailsBasedOnStudentId, TimeTableSerializer, \
#     class_periodserializer, studentcertificatePDFGenerateSerializer, StudentAssignmentSerializer, \
#     EmployeeMasterSerializer, StudentAssignmentUpdateSerializer, AttendanceSearchSerializer, \
#     StudentAttendanceSerializer, EmployeeSearchSerializer, TermSerializer, GetSubjectBasedOnCourseSectionSerializer, \
#     GetStudentListBasedOnGroupCourseSubjectSerializer, circularmessageFilterSerializer, staffEmployeeTypeSerializer, \
#     StudentsSerializer, GetSubjectBasedOnCourseSectionSerializer,GetClubBasedOnCourseSectionSerializer


# Create your views here.

class UserTypeCreateView(CreateAPIView):
    queryset = UserType.objects.all()
    serializer_class = UserTypeSerializer

    def create(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            usertype = serializer.validated_data['usertype'].lower()
            description = serializer.validated_data['description']
            created_by = serializer.validated_data['created_by']

            # Check if the role already exists

            if UserType.objects.filter(usertype=usertype, is_active=True).exists():
                return Response({'message': 'UserType already exist'},
                                status=status.HTTP_400_BAD_REQUEST)

            # Create and save the Role instance if it doesn't exist
            usertype_instance = UserType.objects.create(
                usertype=usertype,
                description=description,
                created_by=created_by,
                updated_by=created_by
            )

            # Make response data based on serializer
            data = UserTypeSerializer(usertype_instance).data

            return Response({'message': 'UserType created successfully', 'data': data}, status=status.HTTP_201_CREATED)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            # Rollback the transaction on database error
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(
            request=str(request),
            process_name='usertypecreate',
            message=error_message,
        )


class UserTypeListView(ListAPIView):
    queryset = UserType.objects.all().order_by('-created_at')
    serializer_class = UserTypeSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            # prepare data from response

            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'user_type': item.get('user_type'),
                            'description': item.get('description')

                        })
                    else:
                        continue
                if responsedata:

                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='usertypelist',

            message=error_message,

        )


# need to work UserTypeDetailsView
class UserTypeDetailView(RetrieveAPIView):  # need to work
    queryset = UserType.objects.all()
    serializer_class = UserTypeSerializer

    def retrieve(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance:
                data = {
                    'id': instance.id,
                    'user_type': instance.user_type,
                    'description': instance.description,
                    'is_active': instance.is_active,
                    'created_at': instance.created_at,
                    'updated_at': instance.updated_at
                }
                return Response(data, status=status.HTTP_200_OK)
        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='usertyperetrive',

            message=error_message,

        )


class UserTypeUpdateView(UpdateAPIView):
    queryset = UserType.objects.all()
    serializer_class = UserTypeUpdateSerializer

    def update(self, request, *args, **kwargs):
        try:
            partial = kwargs.pop('partial', False)
            instance = self.get_object()
            # Validate input data
            serializer = self.get_serializer(instance, data=request.data, partial=partial)
            serializer.is_valid(raise_exception=True)

            # Access serializer data
            new_usertype = serializer.validated_data.get('usertype').lower()
            new_description = serializer.validated_data.get('description')
            updated_by = serializer.validated_data.get('updated_by')

            # Check if no changes were made
            if (instance.usertype == new_usertype and
                    instance.description == new_description):
                return Response({'message': 'No changes identified'}, status=status.HTTP_200_OK)

            # Check if the new name already exists
            if UserType.objects.exclude(pk=instance.pk).filter(usertype=new_usertype, is_active=True).exists():
                return Response({'message': f"The UserType '{new_usertype}' already exists."},
                                status=status.HTTP_400_BAD_REQUEST)

            # Update instance with new data
            instance.usertype = new_usertype
            instance.description = new_description
            instance.updated_by = updated_by
            instance.save()

            return Response({'message': 'UserType updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='UserTypeupdate',
            message=error_message,
        )


class UserTypeDeleteView(DestroyAPIView):
    queryset = UserType.objects.all()
    serializer_class = UserTypeSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()
            usertype = str(instance)
            if instance.is_active:
                instance.is_active = False
                instance.save()

                return Response({'message': 'Usertype Deactivated Successfully'},
                                status=status.HTTP_200_OK)
            else:
                return Response({'message': 'Usertype already Deactivated.'},
                                status=status.HTTP_400_BAD_REQUEST)
        except Http404:
            return Response({'message': 'Role not found'}, status=status.HTTP_404_NOT_FOUND)


class EmployeeCreateView(CreateAPIView):
    queryset = Employee.objects.all()
    serializer_class = EmployeeSerializer

    def create(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            # Get serializer value
            organization_id = serializer.validated_data['organization']
            branch_id = serializer.validated_data['branch']
            user_type = serializer.validated_data['user_type']
            first_name = serializer.validated_data['first_name']
            last_name = serializer.validated_data['last_name']
            guardian_name = serializer.validated_data['guardian_name']
            email = serializer.validated_data['email']
            mobile_number = serializer.validated_data['mobile_number']
            date_of_birth = serializer.validated_data['date_of_birth']
            gender = serializer.validated_data['gender']
            postal_code = serializer.validated_data['postal_code']
            address = serializer.validated_data['address']
            aadhaar_no = serializer.validated_data['aadhaar_no']
            profile_pic = serializer.validated_data['profile_pic']

            # manually create Employee

            Employee_instance = Employee(
                organization=organization_id,
                branch=branch_id,
                user_type=user_type,
                first_name=first_name,
                last_name=last_name,
                guardian_name=guardian_name,
                email=email,
                mobile_number=mobile_number,
                date_of_birth=date_of_birth,
                gender=gender,
                postal_code=postal_code,
                address=address,
                aadhaar_no=aadhaar_no,
                profile_pic=profile_pic
            )

            Employee_instance.save()

            # # Create Employee Login Instance
            employee_login_instance = UserLogin(
                user_name=Employee_instance.email,
                password=Employee_instance.first_name,
                plain_password=Employee_instance.first_name,  # Consider removing this for security
                user_type=Employee_instance.user_type,
                reference_id=Employee_instance.id,
                organization=Employee_instance.organization,
                branch=Employee_instance.branch,
                is_active=True,
                is_staff=True,  # Required for Django admin
                date_joined=date.today()
            )

            employee_login_instance.set_password(Employee_instance.first_name)
            employee_login_instance.save()

            # Create Login instance
            # login_instance = Login(
            #     username=Employee_instance.email,
            #     password=make_password(Employee_instance.first_name),  # Hash the password
            #     employee=Employee_instance,
            #     organization=Employee_instance.organization,
            #     branch=Employee_instance.branch,
            #     is_staff=True,  # Set to True for the default staff user; adjust as needed
            #     is_superuser=False  # Set to False for non-superuser; adjust as needed
            # )
            # login_instance.save()

            # Optionally, return the created employee data
            response_data = {
                'message': 'Successfully created!!. Note: While login use email_id as a username and firstname as a password',
                'employee': EmployeeSerializer(Employee_instance).data,
                'login': {
                    'organization_name': Employee_instance.organization.organization_code,
                    'branch_name': Employee_instance.branch.branch_name,
                    'username': employee_login_instance.user_name,
                    'is_staff': employee_login_instance.is_staff,
                    'is_superuser': False
                }
            }
            return Response(response_data, status=status.HTTP_201_CREATED)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)


        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='EmployeeCreate',
            message=error_message,
        )


class EmployeeListView(ListAPIView):
    queryset = Employee.objects.all().order_by('-created_at')
    serializer_class = EmployeeSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            # prepare data from response

            responsedata = []

            if resdata:
                for item in resdata:
                    data = {
                        "employeeId": item.get('id'),
                        "FirstName": item.get('first_name'),
                        "LastName": item.get('last_name'),
                        "GuardianName": item.get('guardian_name'),
                        "Email": item.get('email'),
                        "mobile_number": item.get('mobile_number'),
                        "Dob": item.get('date_of_birth'),
                        "Gender": item.get('gender'),
                        "Postalcode": item.get('postal_code'),
                        "Address": item.get('address'),
                        "Aadhaar_No": item.get('aadhaar_no'),
                        "Profile_Pic": item.get('profile_pic'),
                        "is_active": item.get('is_active'),
                        "created_at": item.get('created_at'),
                        "updated_at": item.get('updated_at'),

                    }

                    responsedata.append(data)
                return Response({'message': 'success', 'data': responsedata})
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)



        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='EmployeeList',

            message=error_message,

        )


class EmployeeDetailView(RetrieveAPIView):
    queryset = Employee.objects.all()
    serializer_class = EmployeeSerializer

    def retrieve(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance:
                data = {
                    "employeeId": instance.id,
                    "FirstName": instance.first_name,
                    "LastName": instance.last_name,
                    "GuardianName": instance.guardian_name,
                    "Email": instance.email,
                    "mobile_number": instance.mobile_number,
                    "Dob": instance.date_of_birth,
                    "Gender": instance.gender,
                    "Postalcode": instance.postal_code,
                    "Address": instance.address,
                    "Aadhaar_No": instance.aadhaar_no,
                    "Profile_Pic": instance.profile_pic.url if instance.profile_pic else None,
                    "is_active": instance.is_active,
                    "created_at": instance.created_at,
                    "updated_at": instance.updated_at,

                }

                # Include the full URL for the profile_pic
                if instance.profile_pic:
                    data['Profile_Pic'] = request.build_absolute_uri(instance.profile_pic.url)

                return Response(data, status=status.HTTP_200_OK)
        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='EmployeeRetrieve',

            message=error_message,

        )


class EmployeeUpdateView(UpdateAPIView):
    queryset = Employee.objects.all()
    serializer_class = EmployeeSerializer

    def update(self, request, *args, **kwargs):
        try:
            partial = kwargs.pop('partial', False)
            instance = self.get_object()

            with transaction.atomic():  # Ensuring atomicity of the operation
                # Validate input data
                serializer = self.get_serializer(instance, data=request.data, partial=partial)
                serializer.is_valid(raise_exception=True)

                # Access serializer data
                user_type = serializer.validated_data['user_type']
                first_name = serializer.validated_data['first_name']
                last_name = serializer.validated_data['last_name']
                guardian_name = serializer.validated_data['guardian_name']
                email = serializer.validated_data['email']
                mobile_number = serializer.validated_data['mobile_number']
                date_of_birth = serializer.validated_data['date_of_birth']
                gender = serializer.validated_data['gender']
                postal_code = serializer.validated_data['postal_code']
                address = serializer.validated_data['address']
                aadhaar_no = serializer.validated_data['aadhaar_no']
                profile_pic = serializer.validated_data['profile_pic']
                is_active = serializer.validated_data['is_active']

                # Check if the new email already exists
                if Employee.objects.exclude(pk=instance.pk).filter(email=email).exists():
                    return Response({'error': "This Email already exists."}, status=status.HTTP_400_BAD_REQUEST)

                # Update instance with new data if anything changed
                if instance.email != email:
                    # Update the email in the Login table
                    login_instance = Login.objects.get(employee=instance)
                    login_instance.username = email
                    login_instance.save()

                # Update instance with new data
                instance.user_type = user_type
                instance.first_name = first_name
                instance.last_name = last_name
                instance.guardian_name = guardian_name
                instance.email = email
                instance.mobile_number = mobile_number
                instance.date_of_birth = date_of_birth
                instance.gender = gender
                instance.postal_code = postal_code
                instance.address = address
                instance.aadhaar_no = aadhaar_no
                instance.profile_pic = profile_pic
                instance.is_active = is_active
                instance.save()

            return Response({'message': 'Employee updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='EmployeeUpdate',
            message=error_message,
        )


class EmployeeDeleteView(DestroyAPIView):
    queryset = Employee.objects.all()
    serializer_class = EmployeeSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            self.perform_destroy(instance)

            return Response({'message': f'Employee deleted successfully !!.'}, status=status.HTTP_200_OK)
        except Http404:
            return Response({'message': 'Employee not found'}, status=status.HTTP_404_NOT_FOUND)


class LoginListView(ListAPIView):
    queryset = Login.objects.all()
    serializer_class = LoginModelSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            # prepare data from response

            responsedata = []

            if resdata:
                for item in resdata:
                    data = {
                        'id': item.get('id'),
                        'organization_id': item.get('organization').id,
                        'organization_description': item.get('organization').organization_description,
                        'branch_id': item.get('branch').id,
                        'branch_name': item.get('branch').branch_name,
                        'username': item.get('username'),
                        'employee_id': item.get('employee'),
                        'is_superuser': item.get('is_superuser'),
                        'is_staff': item.get('is_staff'),

                    }

                    responsedata.append(data)
                return Response({'message': 'success', 'data': responsedata})
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)



        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='LoginList',

            message=error_message,

        )


class LoginListDetailView(RetrieveAPIView):
    queryset = Login.objects.all()
    serializer_class = LoginModelSerializer

    def retrieve(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance:
                data = {
                    'id': instance.id,
                    'organization_id': instance.organization.id,
                    'organization_description': instance.organization.organization_description,
                    'branch_id': instance.branch.id,
                    'branch_name': instance.branch.branch_name,
                    'username': instance.username,
                    'employee': instance.employee.id,
                    'is_superuser': instance.is_superuser,
                    'is_staff': instance.is_staff,
                }
                return Response(data, status=status.HTTP_200_OK)
        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='LoginRetrieve',

            message=error_message,

        )


class RegisterUserLoginAPIView(CreateAPIView):
    # permission_classes = [IsAuthenticated]
    # permission_classes = [permissions.AllowAny]
    serializer_class = LoginSerializer

    def create(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            username = serializer.validated_data['username']
            password = serializer.validated_data['password']
            organization_id = serializer.validated_data['organization_id']
            branch_id = serializer.validated_data['branch_id']

            # Check Authenticate username and password

            user = authenticate(username=username, password=password)

            # print('Auth')
            if user is not None and user.is_active:
                if user.organization.id == organization_id and user.branch.id == branch_id:
                    print("User", user)

                    # UserType Instance
                    UserTypeInstance = user.user_type
                    user_type = UserTypeInstance.user_type.upper()
                    if user_type == 'PARENT':
                        # Registration Instance
                        Registrationinstance = StudentRegistration.objects.get(id=user.reference_id)
                        # print(Registrationinstance,type(Registrationinstance))

                        # UserType Instance
                        # UserTypeInstance = user.user_type

                        # #get student id
                        reference_id = Registrationinstance.id
                        # print(reference_id)

                        # get active student object on student class
                        student_instance = StudentCourse.objects.get(student_id=reference_id, is_active=True)
                        # print(student_instance,type(student_instance))
                        # Get Class Instance
                        classinstance = Course.objects.get(id=student_instance.course.id)
                        # print(classinstance,type(classinstance))
                        # Get Section Instance
                        sectioninstance = Section.objects.get(id=student_instance.section.id)
                        # print(sectioninstance,type(sectioninstance))

                        # Make Response
                        data = {
                            "organization_id": Registrationinstance.organization.id,
                            "organization_name": Registrationinstance.organization.organization_code,
                            "branch_id": Registrationinstance.branch.id,
                            "branch_name": Registrationinstance.branch.branch_name,
                            "userId": Registrationinstance.id,
                            "username": Registrationinstance.user_name,
                            "userTypeId": UserTypeInstance.id,
                            "userRole": UserTypeInstance.usertype,
                            # "user_type_name": UserTypeInstance.usertype,
                            "admission_no": Registrationinstance.admission_no,
                            "firstName": Registrationinstance.first_name,
                            "LastName": Registrationinstance.last_name,
                            "Email": Registrationinstance.email,
                            "Dob": Registrationinstance.date_of_birth,
                            "Gender": Registrationinstance.gender,
                            "class": classinstance.course_name,
                            "section": sectioninstance.section_name,
                            "enrollment_no": student_instance.enrollment_no,
                            "House": student_instance.house,
                            "Profile_Pic": Registrationinstance.profile_pic,
                            "is_active": student_instance.is_active,

                        }

                        # Include the full URL for the profile_pic if it exists
                        if Registrationinstance.profile_pic:
                            data['Profile_Pic'] = request.build_absolute_uri(Registrationinstance.profile_pic.url)
                        else:
                            data['Profile_Pic'] = None  # Or any placeholder/default value
                        return Response({'message': 'Logged in  Successfully', 'data': data}, status=status.HTTP_200_OK)

                    elif user_type == 'PROFESSOR':
                        ProfessorInstance = user.user_type
                        data = {
                            "organization_id": user.organization.id,
                            "organization_name": user.organization.organization_code,
                            "branch_id": user.branch.id,
                            "branch_name": user.branch.branch_name,
                            'userId': user.reference_id,
                            'username': user.user_name,
                            'userRole': ProfessorInstance.user_type,
                            'userTypeId': ProfessorInstance.id
                        }
                        return Response({'message': 'Logged in  Successfully', 'data': data}, status=status.HTTP_200_OK)
                    elif user_type == 'ADMIN':
                        AdminInstance = user.user_type
                        data = {
                            "organization_id": user.organization.id,
                            "organization_name": user.organization.organization_code,
                            "branch_id": user.branch.id,
                            "branch_name": user.branch.branch_name,
                            'userId': user.reference_id,
                            'username': user.user_name,
                            'userRole': AdminInstance.user_type,
                            'userTypeId': AdminInstance.id,
                            'user_login_id': user.id,
                            'accessible_modules': user.accessible_modules if user.accessible_modules else []
                        }
                        return Response({'message': 'Logged in  Successfully', 'data': data}, status=status.HTTP_200_OK)
                    elif user_type == 'STAFF':
                        # --- Teaching Staff Validation ---
                        try:
                            employee_master = EmployeeMaster.objects.get(id=user.reference_id, is_active=True)
                            employee_type_code = employee_master.employee_type.employee_type_code
                        except EmployeeMaster.DoesNotExist:
                            return Response(
                                {'message': 'You are not authorized to access Teaching staff modules to access it contact adminstration'},
                                status=status.HTTP_403_FORBIDDEN
                            )

                        if employee_type_code != 'Teaching Staff':
                            return Response(
                                {'message': 'You are not authorized to access Teaching staff modules to access it contact adminstration'},
                                status=status.HTTP_403_FORBIDDEN
                            )
                        # --- End Validation ---

                        StaffInstance = user.user_type
                        data = {
                            "organization_id": user.organization.id,
                            "organization_name": user.organization.organization_code,
                            "branch_id": user.branch.id,
                            "branch_name": user.branch.branch_name,
                            'userId': user.reference_id,
                            'username': user.user_name,
                            'userRole': StaffInstance.user_type,
                            'userTypeId': StaffInstance.id
                        }
                        return Response({'message': 'Logged in  Successfully', 'data': data}, status=status.HTTP_200_OK)
                    elif user_type == 'STUDENT':
                        student = user.user_type
                        data = {
                            "organization_id": user.organization.id,
                            "organization_name": user.organization.organization_code,
                            "branch_id": user.branch.id,
                            "branch_name": user.branch.branch_name,
                            'userId': user.reference_id,
                            'username': user.user_name,
                            'userRole': student.user_type,
                            'userTypeId': student.id
                        }
                        return Response({'message': 'Logged in  Successfully', 'data': data}, status=status.HTTP_200_OK)

                    else:
                        return Response({'message': 'Logged in  Successfully,This is a unknown user!!', })
                else:
                    return Response({'message': f'User is not belong to branch - {user.branch.branch_name}'},
                                    status=status.HTTP_400_BAD_REQUEST)
            else:
                return Response({'message': 'username or password wrong'}, status=status.HTTP_400_BAD_REQUEST)


        except ValidationError as e:

            return Response({'message': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='Login',

            message=error_message,

        )


class RegisterUserChangePasswordAPIView(CreateAPIView):
    # permission_classes = [IsAuthenticated]
    serializer_class = ChangePasswordSerializer

    def create(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            # Get user_id & new_password
            username = serializer.validated_data.get('username')
            old_password = serializer.validated_data.get('old_password')
            new_password = serializer.validated_data.get('new_password')
            confirm_password = serializer.validated_data.get('confirm_password')

            # Get User ID
            # userid = user_name.id

            # Retrieve the user object based on user_id
            user_instance = UserLogin.objects.get(user_name=username)

            if old_password:
                if user_instance.plain_password != old_password:
                    return Response({"please enter correct old password !!!"}, status=status.HTTP_400_BAD_REQUEST)

            # check old password & new password
            if new_password != confirm_password:
                return Response({'message': 'new-password and confirm-password must be same !!'},
                                status=status.HTTP_400_BAD_REQUEST)

            # Set the new password for the user
            user_instance.set_password(new_password)

            # Update plain_password field with the new password
            user_instance.plain_password = new_password

            # Save the user object
            user_instance.save()

            # Return success response
            return Response({'message': 'Password changed successfully'}, status=status.HTTP_200_OK)

        except ValidationError as e:
            return Response({'message': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except UserLogin.DoesNotExist:

            return Response({'message': 'User does not exist'}, status=status.HTTP_400_BAD_REQUEST)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='UserChangePassword',

            message=error_message,

        )


class CreateAdminUserAPIView(CreateAPIView):
    """
    API endpoint to create a new admin user with accessible modules selection
    """
    serializer_class = CreateAdminUserSerializer

    def create(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            user_name = serializer.validated_data['user_name']
            password = serializer.validated_data['password']
            role_name = serializer.validated_data.get('role_name', '')
            organization_id = serializer.validated_data['organization_id']
            branch_id = serializer.validated_data['branch_id']
            reference_id = serializer.validated_data.get('reference_id', 0)
            accessible_modules = serializer.validated_data.get('accessible_modules', [])

            # Get UserType for admin
            try:
                admin_user_type = UserType.objects.get(user_type__iexact='admin')
            except UserType.DoesNotExist:
                return Response(
                    {'message': 'Admin user type not found. Please create it first.'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            # Get Organization and Branch instances
            organization = Organization.objects.get(id=organization_id)
            branch = Branch.objects.get(id=branch_id)

            # Create new admin user
            new_user = UserLogin(
                user_name=user_name,
                plain_password=password,
                role_name=role_name if role_name else '',
                user_type=admin_user_type,
                organization=organization,
                branch=branch,
                reference_id=reference_id if reference_id else 0,
                accessible_modules=accessible_modules,
                is_active=True,
                is_staff=False
            )
            
            # Set encrypted password
            new_user.set_password(password)
            new_user.save()

            data = {
                "id": new_user.id,
                "user_name": new_user.user_name,
                "user_type": admin_user_type.user_type,
                "organization": organization.organization_code,
                "branch": branch.branch_name,
                "reference_id": new_user.reference_id,
                "accessible_modules": accessible_modules,
                "is_active": new_user.is_active,
                "created_at": new_user.date_joined
            }

            return Response(
                {'message': 'Admin user created successfully', 'data': data},
                status=status.HTTP_201_CREATED
            )

        except Organization.DoesNotExist:
            return Response(
                {'message': 'Organization not found'},
                status=status.HTTP_400_BAD_REQUEST
            )
        except Branch.DoesNotExist:
            return Response(
                {'message': 'Branch not found'},
                status=status.HTTP_400_BAD_REQUEST
            )
        except ValidationError as e:
            return Response({'message': e.detail}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response(
                {'error': error_message},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='CreateAdminUser',
            message=error_message,
        )


class ListAdminUserAPIView(ListAPIView):
    """
    API endpoint to list all admin users
    """
    def get(self, request, *args, **kwargs):
        try:
            # Get organization and branch from query params
            org_id = request.query_params.get('org_id')
            branch_id = request.query_params.get('branch_id')

            # Base queryset
            queryset = UserLogin.objects.all()

            # Filter by organization if provided
            if org_id:
                queryset = queryset.filter(organization_id=org_id)

            # Filter by branch if provided
            if branch_id:
                queryset = queryset.filter(branch_id=branch_id)

            # Get admin user type
            try:
                admin_user_type = UserType.objects.get(user_type__iexact='admin')
                queryset = queryset.filter(user_type=admin_user_type)
            except UserType.DoesNotExist:
                pass

            # Build response data
            admin_users_data = []
            for user in queryset:
                admin_users_data.append({
                    "id": user.id,
                    "user_name": user.user_name,
                    "role_name": user.role_name if hasattr(user, 'role_name') else '',
                    "user_type": user.user_type.user_type if user.user_type else "N/A",
                    "reference_id": user.reference_id,
                    "organization": user.organization.organization_code if user.organization else "N/A",
                    "branch": user.branch.branch_name if user.branch else "N/A",
                    "accessible_modules": user.accessible_modules if user.accessible_modules else [],
                    "is_active": user.is_active,
                    "date_joined": user.date_joined
                })

            return Response(
                {
                    'message': 'Admin users fetched successfully',
                    'data': admin_users_data,
                    'count': len(admin_users_data)
                },
                status=status.HTTP_200_OK
            )

        except Exception as e:
            error_message = str(e)
            ExceptionTrack.objects.create(
                request=str(request),
                process_name='ListAdminUser',
                message=error_message,
            )
            return Response(
                {'error': error_message},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class UpdateAdminUserAPIView(UpdateAPIView):
    """
    API endpoint to update an existing admin user
    Only allows updating role_name and accessible_modules
    Username, password, and reference_id cannot be changed
    """
    def put(self, request, *args, **kwargs):
        try:
            user_id = kwargs.get('pk')
            
            if not user_id:
                return Response(
                    {'message': 'User ID is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            # Get the user to update
            try:
                user = UserLogin.objects.get(id=user_id)
            except UserLogin.DoesNotExist:
                return Response(
                    {'message': 'User not found'},
                    status=status.HTTP_404_NOT_FOUND
                )

            # Extract updateable fields from request
            role_name = request.data.get('role_name')
            accessible_modules = request.data.get('accessible_modules')

            # Validate role_name
            if role_name is not None:
                if not role_name.strip():
                    return Response(
                        {'message': 'Role name cannot be empty'},
                        status=status.HTTP_400_BAD_REQUEST
                    )
                user.role_name = role_name.strip()

            # Validate accessible_modules
            if accessible_modules is not None:
                if not isinstance(accessible_modules, list):
                    return Response(
                        {'message': 'Accessible modules must be a list'},
                        status=status.HTTP_400_BAD_REQUEST
                    )
                user.accessible_modules = accessible_modules

            # Save the updated user
            user.save()

            # Prepare response data
            response_data = {
                "id": user.id,
                "user_name": user.user_name,
                "role_name": user.role_name,
                "user_type": user.user_type.user_type if user.user_type else "N/A",
                "reference_id": user.reference_id,
                "accessible_modules": user.accessible_modules,
                "is_active": user.is_active,
                "updated_at": user.date_joined
            }

            return Response(
                {'message': 'Admin user updated successfully', 'data': response_data},
                status=status.HTTP_200_OK
            )

        except ValidationError as e:
            return Response({'message': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            error_message = str(e)
            ExceptionTrack.objects.create(
                request=str(request),
                process_name='UpdateAdminUser',
                message=error_message,
            )
            return Response(
                {'error': error_message},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class EmployeeEducationDetailCreateView(CreateAPIView):
    queryset = EmployeeDetail.objects.all()
    serializer_class = EmployeeDetailSerializer

    def create(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            EmployeeId = serializer.validated_data['EmployeeId']
            Documents = serializer.validated_data['Documents']
            Degree = serializer.validated_data['Degree']
            Institution = serializer.validated_data['Institution']
            Duration_Start = serializer.validated_data['Duration_Start']
            Duration_EndDate = serializer.validated_data['Duration_EndDate']
            Grade = serializer.validated_data['Grade']
            Specialization = serializer.validated_data['Specialization']

            Employee_Detail_instance = EmployeeDetail(
                EmployeeId=EmployeeId,
                Documents=Documents,
                Degree=Degree,
                Institution=Institution,
                Duration_Start=Duration_Start,
                Duration_EndDate=Duration_EndDate,
                Grade=Grade,
                Specialization=Specialization

            )

            Employee_Detail_instance.save()

            # Make response data based on serializer
            data = EmployeeDetailSerializer(Employee_Detail_instance).data

            return Response({'message': 'Education Details successfully', 'data': data}, status=status.HTTP_201_CREATED)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)


        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='EmployeeEducationDetailsCreate',
            message=error_message,
        )


class EducationDetailsListView(ListAPIView):
    queryset = EmployeeDetail.objects.all()
    serializer_class = EmployeeDetailSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            # prepare data from response

            responsedata = []

            if resdata:
                for item in resdata:
                    data = {
                        "id": item.get('id'),
                        "EmployeeId": item.get('EmployeeId'),
                        "Documents": item.get('Documents'),
                        "Degree": item.get('Degree'),
                        "Institution": item.get('Institution'),
                        "Duration_Start": item.get('Duration_Start'),
                        "Duration_EndDate": item.get('Duration_EndDate'),
                        "Grade": item.get('Grade'),
                        "Specialization": item.get('Specialization'),
                        "is_active": item.get('is_active'),
                        "created_at": item.get('created_at'),
                        "updated_at": item.get('updated_at'),

                    }

                    responsedata.append(data)
                return Response({'message': 'success', 'data': responsedata})
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)



        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='EmployeeEducationDetailsList',

            message=error_message,

        )


class EducationDetailsDetailView(RetrieveAPIView):
    queryset = EmployeeDetail.objects.all()
    serializer_class = EmployeeDetailSerializer

    def retrieve(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance:
                data = {
                    "id": instance.id,
                    "employeeId": instance.EmployeeId.id,
                    "Documents": instance.Documents,
                    "Degree": instance.Degree,
                    "Institution": instance.Institution,
                    "Duration_Start": instance.Duration_Start,
                    "Duration_EndDate": instance.Duration_EndDate,
                    "Grade": instance.Grade,
                    "Specialization": instance.Specialization,

                    "is_active": instance.is_active,
                    "created_at": instance.created_at,
                    "updated_at": instance.updated_at,

                }

                # Include the full URL for the profile_pic
                if instance.Documents:
                    data['Documents'] = request.build_absolute_uri(instance.Documents.url)

                return Response(data, status=status.HTTP_200_OK)
        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='EmployeeEducationDetailsRetrieve',

            message=error_message,

        )


class EducationDetailsUpdateView(UpdateAPIView):
    queryset = EmployeeDetail.objects.all()
    serializer_class = EmployeeDetailSerializer

    def update(self, request, *args, **kwargs):
        try:
            partial = kwargs.pop('partial', False)
            instance = self.get_object()
            # Validate input data
            serializer = self.get_serializer(instance, data=request.data, partial=partial)
            serializer.is_valid(raise_exception=True)

            # Access serializer data
            EmployeeId = serializer.validated_data.get('EmployeeId')
            Documents = serializer.validated_data.get('Documents')
            Degree = serializer.validated_data.get('Degree')
            Institution = serializer.validated_data.get('Institution')
            Duration_Start = serializer.validated_data.get('Duration_Start')
            Duration_EndDate = serializer.validated_data.get('Duration_EndDate')
            Grade = serializer.validated_data.get('Grade')
            Specialization = serializer.validated_data.get('Specialization')
            is_active = serializer.validated_data.get('is_active')

            # Check if the data matches the existing instance
            if all(getattr(instance, key) == value for key, value in serializer.validated_data.items()):
                return Response({'message': 'No changes identified'}, status=status.HTTP_200_OK)

            # Update instance with new data
            instance.EmployeeId = EmployeeId
            instance.Documents = Documents
            instance.Degree = Degree
            instance.Institution = Institution
            instance.Duration_Start = Duration_Start
            instance.Duration_EndDate = Duration_EndDate
            instance.Grade = Grade
            instance.Specialization = Specialization
            instance.is_active = is_active
            instance.save()

            return Response({'message': 'EducationDetails updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except Exception as e:

            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='EmployeeEducationDetailsUpdate',
            message=error_message,
        )


class EducationDetailsDeleteView(DestroyAPIView):
    queryset = EmployeeDetail.objects.all()
    serializer_class = EmployeeDetailSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            self.perform_destroy(instance)

            return Response({'message': f'Record deleted successfully !!.'}, status=status.HTTP_200_OK)
        except Http404:
            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


class AcademicSessionYearCreateView(CreateAPIView):
    queryset = AcademicYear.objects.all()
    serializer_class = AcademicYearSerializer

    def create(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            # Start_Year= serializer.validated_data['Start_Year']
            # End_Year = serializer.validated_data['End_Year']
            # Get validate data
            academic_year_code = serializer.validated_data.get('academic_year_code')
            academic_year_description = serializer.validated_data.get('academic_year_description')
            date_from = serializer.validated_data.get('date_from')
            date_to = serializer.validated_data.get('date_to')
            organization = serializer.validated_data.get('organization').id
            # branch_id = serializer.validated_data.get('branch_id').id
            created_by = serializer.validated_data.get('created_by')

            organization_instance = Organization.objects.get(pk=organization)

            # branch_instance = Branches.objects.get(pk=branch_id)

            if AcademicYear.objects.filter(academic_year_code=academic_year_code, organization=organization,
                                           is_active=True).exists():
                return Response(
                    {'message': 'An academic session already exists.'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            AcademicYear_instance = AcademicYear(
                academic_year_code=academic_year_code,
                academic_year_description=academic_year_description,
                date_from=date_from,
                date_to=date_to,
                organization=organization_instance,
                # branch_id=branch_instance,
                created_by=created_by,
                updated_by=created_by

            )

            AcademicYear_instance.save()

            # Make response data based on serializer
            data = AcademicYearSerializer(AcademicYear_instance).data

            return Response({'message': 'Academic Year Created successfully', 'data': data},
                            status=status.HTTP_201_CREATED)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            # Rollback the transaction on database error
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)


        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='academiccreate',
            message=error_message,
        )


# class AcademicSessionYearListView(ListAPIView):
#     queryset = AcademicYear.objects.all()
#     serializer_class = AcademicSessionYear
#
#     def list(self, request, *args, **kwargs):
#         try:
#             organization = self.kwargs.get('organization')
#             branchId = self.kwargs.get('branch_id')
#
#
#
#             resdata= AcademicYear.objects.filter(organization=organization,branch_id=branchId,is_active=True)
#
#
#
#
#
#
#             # response = super().list(request, *args, **kwargs)
#             # resdata = response.data
#             #
#             # prepare data from response
#
#             if resdata:
#                 responsedata = []
#                 for item in resdata:
#
#                     # Prepare the custom response data
#                     responsedata.append({
#                         'id': item.id,
#                         'sesion_code': item.sesion_code,
#                         'sesion_description': item.sesion_description,
#                         'date_from': item.date_from,
#                         'date_to': item.date_to,
#                         'organization': item.organization.id,
#                         'organization_code': item.organization.organization_code,
#                         'branch_id': item.branch_id.id,
#                         'branch_name': item.branch_id.branch_name
#
#                     })
#
#
#                 if responsedata:
#
#                     return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
#                 else:
#                     return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
#             else:
#                 return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)
#
#
#
#         except Exception as e:
#
#             # Log the exception
#
#             error_message = str(e)
#
#             self.log_exception(request, error_message)
#
#             return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#     def log_exception(self, request, error_message):
#
#         ExceptionTrack.objects.create(
#
#             request=str(request),
#
#             process_name='academicsessionyearlist',
#
#             message=error_message,
#
#         )


class AcademicSessionYearListView(ListAPIView):
    queryset = AcademicYear.objects.all()
    serializer_class = AcademicYearSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            # prepare data from response

            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        # Get Data
                        organization = item.get('organization')
                        # branch_id = item.get('branch_id')

                        Organization_instance = Organization.objects.get(pk=organization)

                        # branch_instance = Branches.objects.get(pk=branch_id)

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'academic_year_code': item.get('academic_year_code'),
                            'academic_year_description': item.get('academic_year_description'),
                            'date_from': item.get('date_from'),
                            'date_to': item.get('date_to'),
                            'organization': Organization_instance.id,
                            'organization_code': Organization_instance.organization_code,
                            # 'branch_id': branch_instance.id,
                            # 'branch_name': branch_instance.branch_name

                        })
                    else:
                        continue
                if responsedata:

                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)



        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='academicsessionyearlist',

            message=error_message,

        )


class AcademicSessionYearDetailView(RetrieveAPIView):
    queryset = AcademicYear.objects.all()
    serializer_class = AcademicYearSerializer

    def retrieve(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance:
                organization = instance.organization.id
                # branch_id = instance.branch_id.id

                Organization_instance = Organization.objects.get(pk=organization)

                # branch_instance = Branches.objects.get(pk=branch_id)
                data = {
                    "id": instance.id,
                    "academic_year_code": instance.academic_year_code,
                    "academic_year_description": instance.academic_year_description,
                    "date_from": instance.date_from,
                    "date_to": instance.date_to,
                    "organization": Organization_instance.id,
                    "organization_code": Organization_instance.organization_code,
                    # "branch_id": branch_instance.id,
                    # "branch_name": branch_instance.branch_name,

                    "is_active": instance.is_active,
                    "created_at": instance.created_at,
                    "updated_at": instance.updated_at,

                }

                return Response(data, status=status.HTTP_200_OK)
        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='AcademicYearRetrieve',

            message=error_message,

        )


class GetAllAcademicSessionYearDetailByFilterView(ListAPIView):
    queryset = AcademicYear.objects.all()
    serializer_class = AcademicYearSerializer

    def list(self, request, *args, **kwargs):
        try:
            # instance= self.get_object()
            organization_id = request.query_params.get('organization_id')
            batch_id = request.query_params.get('batch_id')
            course_id = request.query_params.get('course_id')
            department_id = request.query_params.get('department_id')

            if not (organization_id and batch_id and course_id and department_id):
                return Response({'message': 'Please provide required data !!!'}, status=status.HTTP_200_OK)

            filterdata = AcademicYear.objects.filter(is_active=True).order_by('display_order', 'id')

            if filterdata:
                if organization_id:
                    filterdata = filterdata.filter(organization=organization_id)

                if batch_id:
                    filterdata = filterdata.filter(batch=batch_id)

                if course_id:
                    filterdata = filterdata.filter(course=course_id)

                if department_id:
                    filterdata = filterdata.filter(department=department_id)

                # Organization_instance = Organization.objects.get(pk=organization)

                # branch_instance = Branches.objects.get(pk=branch_id)
                responsedata = []
                for item in filterdata:
                    data = {
                        "id": item.id,
                        "academic_year_code": item.academic_year_code,
                        "academic_year_description": item.academic_year_description,
                        "date_from": item.date_from,
                        "date_to": item.date_to,
                        # "organization": item.organization.id,
                        "organization_code": item.organization.organization_code,
                        "batch_code": item.batch.batch_code,
                        "course_code": item.course.course_code,
                        "department_code": item.department.department_code,
                        # "branch_id": branch_instance.id,
                        # "branch_name": branch_instance.branch_name,

                        "is_active": item.is_active,
                        "created_at": item.created_at,
                        "updated_at": item.updated_at,

                    }

                    responsedata.append(data)

                return Response(responsedata, status=status.HTTP_200_OK)
        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='GetAllAcademicSessionYearDetailByFilterView',

            message=error_message,

        )


class AcademicSessionYearUpdateView(UpdateAPIView):
    queryset = AcademicYear.objects.all()
    serializer_class = AcademicYearUpdateSerializer

    def update(self, request, *args, **kwargs):
        try:
            partial = kwargs.pop('partial', False)
            instance = self.get_object()
            # Validate input data
            serializer = self.get_serializer(instance, data=request.data, partial=partial)
            serializer.is_valid(raise_exception=True)

            # Access serializer data
            academic_year_code = serializer.validated_data.get('academic_year_code')
            academic_year_description = serializer.validated_data.get('academic_year_description')
            date_from = serializer.validated_data.get('date_from')
            date_to = serializer.validated_data.get('date_to')
            organization = serializer.validated_data.get('organization')
            # branch_id = serializer.validated_data.get('branch_id')
            updated_by = serializer.validated_data.get('updated_by')

            # Check if the data matches the existing instance
            if all(getattr(instance, key) == value for key, value in serializer.validated_data.items()):
                return Response({'message': 'No changes identified'}, status=status.HTTP_200_OK)

            # Check if a similar record already exists
            if AcademicYear.objects.exclude(pk=instance.pk).filter(

                    academic_year_code=academic_year_code,
                    organization=organization,
                    # branch_id=branch_id,
                    is_active=True

            ).exists():
                return Response({'message': 'This Academic Year  already exists on this organization.'},
                                status=status.HTTP_400_BAD_REQUEST)

            # Update instance with new data
            instance.academic_year_code = academic_year_code
            instance.academic_year_description = academic_year_description
            instance.date_from = date_from
            instance.date_to = date_to
            instance.organization = organization
            # instance.branch_id = branch_id
            instance.updated_by = updated_by
            instance.save()

            return Response({'message': 'AcademicYear updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except Exception as e:

            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='AcademicYearUpdate',
            message=error_message,
        )


class AcademicSessionYearDeleteView(DestroyAPIView):
    queryset = AcademicYear.objects.all()
    serializer_class = AcademicYearSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance.is_active:
                instance.is_active = False
                instance.save()

            return Response({'message': f'AcademicYear  deleted successfully !!.'}, status=status.HTTP_200_OK)
        except Http404:
            return Response({'message': 'AcademicYear not found'}, status=status.HTTP_404_NOT_FOUND)


class CourseCreateView(CreateAPIView):
    queryset = Course.objects.all()
    serializer_class = CourseSerializer

    def create(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            course_name = serializer.validated_data['course_name'].upper()
            description = serializer.validated_data['description']
            created_by = serializer.validated_data.get('created_by')

            # Check If The Course already exist
            if Course.objects.filter(course_name=course_name, is_active=True).exists():
                return Response(
                    {'message': 'Course Name already exists.'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            # create & save data
            Course_instance = Course(
                course_name=course_name,
                description=description,
                created_by=created_by,
                updated_by=created_by
            )

            Course_instance.save()

            # Make response data based on serializer
            data = CourseSerializer(Course_instance).data

            return Response({'message': 'Course Created successfully', 'data': data}, status=status.HTTP_201_CREATED)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            # Rollback the transaction on database error
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='CourseCreate',
            message=error_message,
        )


class CourseListView(ListAPIView):
    queryset = Course.objects.all()
    serializer_class = CourseSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            # prepare data from response
            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        # Prepare the custom response data
                        responsedata.append({
                            "id": item.get('id'),
                            "course_name": item.get('course_name'),
                            "description": item.get('description')

                        })
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='CourseList',

            message=error_message,

        )


# need to be work on CourseDetailView
class CourseDetailView(RetrieveAPIView):
    queryset = Course.objects.all()
    serializer_class = CourseSerializer

    def retrieve(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance:
                data = {
                    "id": instance.id,
                    "course_name": instance.course_name,
                    "description": instance.description,

                    "is_active": instance.is_active,
                    "created_by": instance.created_by,
                    "created_at": instance.created_at,
                    "updated_at": instance.updated_at,

                }

                return Response(data, status=status.HTTP_200_OK)
        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='CourseRetrieve',

            message=error_message,

        )


class GetAllCourseDetailsByFilter(ListAPIView):
    queryset = Course.objects.all()
    serializer_class = CourseSerializer

    def list(self, request, *args, **kwargs):
        try:
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            batch_id = request.query_params.get('batch_id')

            filterData = Course.objects.filter(is_active=True)

            if not (organization_id and branch_id and batch_id):
                return Response({'message': 'Please provide mandatory data!!! '}, status=status.HTTP_400_BAD_REQUEST)

            if organization_id:
                filterData = filterData.filter(organization=organization_id)
            # else:
            #     return Response({'message': 'Batch is required !!! '}, status=status.HTTP_400_BAD_REQUEST)

            if branch_id:
                filterData = filterData.filter(branch=branch_id)

            if batch_id:
                filterData = filterData.filter(batch=batch_id)
            # else:
            #     return Response({'message': 'Batch is required !!! '}, status=status.HTTP_400_BAD_REQUEST)

            if filterData:
                # Prepare the custom response data
                responsedata = []
                for item in filterData:
                    # if item.get('is_active') == True:

                    # organization_id = item.get('organization')

                    # Organization_instance = Organization.objects.get(id=organization_id)

                    # Prepare the custom response data
                    responsedata.append({
                        'id': item.id,
                        'organization_id': item.organization.id,
                        'organization_code': item.organization.organization_code,
                        'batch_id': item.batch.id,
                        'batch_code': item.batch.batch_code,
                        'course_id': item.id,
                        'course_code': item.course_code,
                        'course_name': item.course_name
                    })
                # else:
                #     continue
                if responsedata:

                    return Response(responsedata, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='GetAllCourseDetailsByFilter',
            message=error_message,
        )


class GetAllCourseDetailsByBatch(ListAPIView):
    queryset = Course.objects.all()
    serializer_class = CourseSerializer

    def list(self, request, *args, **kwargs):
        try:
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            batch_id = request.query_params.get('batch_id')

            # filterData = Course.objects.filter(is_active=True)

            if not (organization_id and branch_id and batch_id):
                return Response({'message': 'Please provide mandatory data!!! '}, status=status.HTTP_400_BAD_REQUEST)

            if (organization_id and branch_id and batch_id):
                filterData = Course.objects.filter(organization=organization_id, branch=branch_id, batch=batch_id)

            if filterData:
                # Prepare the custom response data
                responsedata = []
                for item in filterData:
                    # Prepare the custom response data
                    responsedata.append({
                        'id': item.id,
                        'organization_id': item.organization.id,
                        'organization_code': item.organization.organization_code,
                        'branch_id': item.branch.id,
                        "branch_name": item.branch.branch_name,
                        'batch_id': item.batch.id,
                        'batch_code': item.batch.batch_code,
                        'course_id': item.id,
                        'course_code': item.course_code,
                        'course_name': item.course_name
                    })
                # else:
                #     continue
                if responsedata:

                    return Response(responsedata, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='GetAllCourseDetailsByBatch',
            message=error_message,
        )


class CourseUpdateView(UpdateAPIView):
    queryset = Course.objects.all()
    serializer_class = CourseUpdateSerializer

    def update(self, request, *args, **kwargs):
        try:
            partial = kwargs.pop('partial', False)
            instance = self.get_object()
            # Validate input data
            serializer = self.get_serializer(instance, data=request.data, partial=partial)
            serializer.is_valid(raise_exception=True)

            # Access serializer data
            course_name = serializer.validated_data.get('course_name').upper()
            description = serializer.validated_data.get('description')
            updated_by = serializer.validated_data.get('updated_by')

            # Check if the data matches the same instance
            if (instance.course_name == course_name and
                    instance.description == description
            ):
                return Response({'message': 'No changes identified'}, status=status.HTTP_200_OK)

            # Check if the new name already exists
            if Course.objects.exclude(pk=instance.pk).filter(course_name=course_name).exists():
                return Response({'message': f"The class {course_name} already exists."},
                                status=status.HTTP_400_BAD_REQUEST)

            # Update instance with new data
            instance.course_name = course_name
            instance.description = description
            instance.updated_by = updated_by
            instance.save()

            return Response({'message': 'Course updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred.' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)


        except Exception as e:

            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='CourseUpdate',
            message=error_message,
        )


class CourseDeleteView(DestroyAPIView):
    queryset = Course.objects.all()
    serializer_class = CourseSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance.is_active:
                instance.is_active = False
                instance.save()

                return Response({'message': 'Course Deactivated Successfully'},
                                status=status.HTTP_200_OK)
            else:
                return Response({'message': 'Course already Deactivated.'},
                                status=status.HTTP_400_BAD_REQUEST)

        except Http404:
            return Response({'message': 'Course not found'}, status=status.HTTP_404_NOT_FOUND)


class DepartmentCreateView(CreateAPIView):
    queryset = Department.objects.all()
    serializer_class = DepartmentSerializer

    def create(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            department_code = serializer.validated_data['course_name'].upper()
            department_description = serializer.validated_data['department_description']
            created_by = serializer.validated_data.get('created_by')

            # Check If The Course already exist
            if Department.objects.filter(department_code=department_code, is_active=True).exists():
                return Response(
                    {'message': 'Department Name already exists.'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            # create & save data
            Department_instance = Course(
                department_code=department_code,
                department_description=department_description,
                created_by=created_by,
                updated_by=created_by
            )

            Department_instance.save()

            # Make response data based on serializer
            data = CourseSerializer(Department_instance).data

            return Response({'message': 'Course Created successfully', 'data': data}, status=status.HTTP_201_CREATED)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            # Rollback the transaction on database error
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='DepartmentCreate',
            message=error_message,
        )


class DepartmentListView(ListAPIView):
    queryset = Department.objects.all()
    serializer_class = DepartmentSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            # prepare data from response
            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        # Prepare the custom response data
                        responsedata.append({
                            "id": item.get('id'),
                            "department_code": item.get('department_code'),
                            "department_description": item.get('department_description')

                        })
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='DepartmentList',

            message=error_message,

        )


class GetAllDepartmentDetailsByFilters(ListAPIView):
    queryset = Department.objects.all()
    serializer_class = DepartmentSerializer

    def list(self, request, *args, **kwargs):
        try:
            # response = super().list(request, *args, **kwargs)
            # resdata = response.data
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            batch_id = request.query_params.get('batch_id')
            course_id = request.query_params.get('course_id')
            department_id = request.query_params.get('department_id')

            # filterdata = Department.objects.filter(is_active=True)

            if not (organization_id and branch_id and batch_id and course_id):
                return Response({'message': 'Please provide mandatory data !!!'}, status=status.HTTP_400_BAD_REQUEST)

            if organization_id:
                filterdata = Department.objects.filter(organization=organization_id, is_active=True)

            if batch_id:
                filterdata = filterdata.filter(batch=batch_id)

            if course_id:
                filterdata = filterdata.filter(course=course_id)

            if department_id:
                filterdata = filterdata.filter(id=department_id)

            # prepare data from response
            if filterdata:
                responsedata = []
                for item in filterdata:
                    if item.is_active == True:

                        # Prepare the custom response data
                        responsedata.append({
                            "department_id": item.id,
                            "department_code": item.department_code,
                            "department_description": item.department_description,
                            "course_name": item.course.course_code,
                            "description": item.course.description

                        })
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='GetAllDepartmentDetailsByFilters',

            message=error_message,

        )


class GetAllDepartmentDetailsByCourse(ListAPIView):
    queryset = Department.objects.all()
    serializer_class = DepartmentSerializer

    def list(self, request, *args, **kwargs):
        try:
            # response = super().list(request, *args, **kwargs)
            # resdata = response.data
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            batch_id = request.query_params.get('batch_id')
            course_id = request.query_params.get('course_id')

            # filterdata = Department.objects.filter(is_active=True)

            if not (organization_id and branch_id and batch_id and course_id):
                return Response({'message': 'Please provide required data !!!'}, status=status.HTTP_400_BAD_REQUEST)

            if (organization_id and branch_id and batch_id and course_id):
                filterdata = Department.objects.filter(organization=organization_id, branch=branch_id, batch=batch_id,
                                                       course=course_id, is_active=True)

            # if batch_id:
            #     filterdata =  filterdata.filter(batch=batch_id)
            #
            #
            # if course_id:
            #     filterdata = filterdata.filter(course=course_id)
            #
            # if department_id:
            #     filterdata = filterdata.filter(id = department_id)

            # prepare data from response
            if filterdata:
                responsedata = []
                for item in filterdata:
                    if item.is_active == True:

                        # Prepare the custom response data
                        responsedata.append({
                            "organization_id": item.organization.id,
                            "organization_description": item.organization.organization_description,
                            "branch_id": item.branch.id,
                            "branch_name": item.branch.branch_name,
                            "batch_id": item.batch.id,
                            "batch_name": item.batch.batch_description,
                            "course_id": item.course.id,
                            "course_name": item.course.course_name,
                            "department_id": item.id,
                            "department_code": item.department_code,
                            "department_description": item.department_description,
                            "course_name": item.course.course_code,
                            "description": item.course.description

                        })
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='GetAllDepartmentDetailsByCourse',

            message=error_message,

        )


# need to be work on CourseDetailView
class DepartmentDetailView(RetrieveAPIView):
    queryset = Department.objects.all()
    serializer_class = DepartmentSerializer

    def retrieve(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance:
                data = {
                    "id": instance.id,
                    "department_code": instance.department_code,
                    "department_description": instance.department_description,

                    "is_active": instance.is_active,
                    "created_by": instance.created_by,
                    "created_at": instance.created_at,
                    "updated_at": instance.updated_at,

                }

                return Response(data, status=status.HTTP_200_OK)
        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='DepartmentRetrieve',

            message=error_message,

        )


class DepartmentUpdateView(UpdateAPIView):
    queryset = Course.objects.all()
    serializer_class = CourseUpdateSerializer

    def update(self, request, *args, **kwargs):
        try:
            partial = kwargs.pop('partial', False)
            instance = self.get_object()
            # Validate input data
            serializer = self.get_serializer(instance, data=request.data, partial=partial)
            serializer.is_valid(raise_exception=True)

            # Access serializer data
            department_code = serializer.validated_data.get('department_code').upper()
            department_description = serializer.validated_data.get('department_description')
            updated_by = serializer.validated_data.get('updated_by')

            # Check if the data matches the same instance
            if (instance.department_code == department_code and
                    instance.department_description == department_description
            ):
                return Response({'message': 'No changes identified'}, status=status.HTTP_200_OK)

            # Check if the new name already exists
            if Department.objects.exclude(pk=instance.pk).filter(department_code=department_code).exists():
                return Response({'message': f"The Department {department_code} already exists."},
                                status=status.HTTP_400_BAD_REQUEST)

            # Update instance with new data
            instance.department_code = department_code
            instance.department_description = department_description
            instance.updated_by = updated_by
            instance.save()

            return Response({'message': 'Department updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred.' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)


        except Exception as e:

            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='DepartmentUpdate',
            message=error_message,
        )


class DepartmentDeleteView(DestroyAPIView):
    queryset = Course.objects.all()
    serializer_class = CourseSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance.is_active:
                instance.is_active = False
                instance.save()

                return Response({'message': 'Department Deactivated Successfully'},
                                status=status.HTTP_200_OK)
            else:
                return Response({'message': 'Department already Deactivated.'},
                                status=status.HTTP_400_BAD_REQUEST)

        except Http404:
            return Response({'message': 'Department not found'}, status=status.HTTP_404_NOT_FOUND)


# class SectionCreateView(CreateAPIView):
#     queryset = Section.objects.all()
#     serializer_class = SectionSerializer
#
#     def create(self, request, *args, **kwargs):
#         try:
#             serializer = self.get_serializer(data=request.data)
#             serializer.is_valid(raise_exception=True)
#
#             section_name = serializer.validated_data['section_name'].upper()
#             created_by = serializer.validated_data.get('created_by')
#
#             # Check If The section already exist
#             if Section.objects.filter(section_name=section_name,is_active=True).exists():
#                 return Response(
#                     {'message': 'Section Name already exists.'},
#                     status=status.HTTP_400_BAD_REQUEST
#                 )
#
#             Section_instance = Section(
#                 section_name=section_name,
#                 created_by=created_by
#             )
#
#             Section_instance.save()
#
#             # Make response data based on serializer
#             data = SectionSerializer(Section_instance).data
#
#             return Response({'message': 'Section Created successfully', 'data': data}, status=status.HTTP_201_CREATED)
#
#         except ValidationError as e:
#             return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)
#
#         except DatabaseError as e:
#             # Rollback the transaction on database error
#             self.log_exception(request, str(e))
#             return Response({'error': 'A database error occurred: ' + str(e)},status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#
#         except Exception as e:
#             # Log the exception
#             error_message = str(e)
#             self.log_exception(request, error_message)
#             return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#     def log_exception(self, request, error_message):
#         ExceptionTrack.objects.create(
#             request=str(request),
#             process_name='sectioncreate',
#             message=error_message,
#         )


class SemesterCreateView(CreateAPIView):
    queryset = Semester.objects.all()
    serializer_class = SemesterSerializer

    def create(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            semester_code = serializer.validated_data['semester_code'].upper()
            semester_description = serializer.validated_data['semester_description']
            created_by = serializer.validated_data.get('created_by')

            # Check If The Course already exist
            if Semester.objects.filter(semester_code=semester_code, is_active=True).exists():
                return Response(
                    {'message': 'Semester Name already exists.'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            # create & save data
            Semester_instance = Semester(
                semester_code=semester_code,
                semester_description=semester_description,
                created_by=created_by,
                updated_by=created_by
            )

            Semester_instance.save()

            # Make response data based on serializer
            data = SemesterSerializer(Semester_instance).data

            return Response({'message': 'Semester Created successfully', 'data': data}, status=status.HTTP_201_CREATED)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            # Rollback the transaction on database error
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='SemesterCreate',
            message=error_message,
        )


class SemesterListView(ListAPIView):
    queryset = Semester.objects.all()
    serializer_class = SemesterSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            # prepare data from response
            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        # Prepare the custom response data
                        responsedata.append({
                            "id": item.get('id'),
                            "semester_code": item.get('semester_code'),
                            "semester_description": item.get('semester_description')

                        })
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='SemesterList',

            message=error_message,

        )


class SemesterDetailByFilters(ListAPIView):
    queryset = Semester.objects.all()
    serializer_class = SemesterSerializer

    def list(self, request, *args, **kwargs):
        try:
            # response = super().list(request, *args, **kwargs)
            # resdata = response.data
            organization_id = request.query_params.get('organization_id')
            batch_id = request.query_params.get('batch_id')
            course_id = request.query_params.get('course_id')
            department_id = request.query_params.get('department_id')
            academic_year_id = request.query_params.get('academic_year_id')

            filterdata = Semester.objects.filter(is_active=True).order_by('display_order', 'id')

            if filterdata:
                if organization_id:
                    filterdata = filterdata.filter(organization=organization_id)

                if batch_id:
                    filterdata = filterdata.filter(batch=batch_id)

                if course_id:
                    filterdata = filterdata.filter(course=course_id)

                if department_id:
                    filterdata = filterdata.filter(department=department_id)

                if academic_year_id:
                    filterdata = filterdata.filter(academic_year=academic_year_id)

            # if course_id and department_id:
            #     filterdata = semesterInstance.filter(course=course_id,department=department_id)

            # prepare data from response
            if filterdata:
                responsedata = []
                for item in filterdata:
                    if item.is_active == True:

                        # Prepare the custom response data
                        responsedata.append({
                            "semester_id": item.id,
                            "semester_code": item.semester_code,
                            "semester_description": item.semester_description,
                            "course_name": item.course.course_code,
                            "description": item.course.description

                        })
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='SemesterDetailByFilter',

            message=error_message,

        )


# need to be work on CourseDetailView
class SemesterDetailView(RetrieveAPIView):
    queryset = Course.objects.all()
    serializer_class = CourseSerializer

    def retrieve(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance:
                data = {
                    "id": instance.id,
                    "semester_code": instance.course_name,
                    "description": instance.description,

                    "is_active": instance.is_active,
                    "created_by": instance.created_by,
                    "created_at": instance.created_at,
                    "updated_at": instance.updated_at,

                }

                return Response(data, status=status.HTTP_200_OK)
        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='SemesterRetrieve',

            message=error_message,

        )


class SemesterUpdateView(UpdateAPIView):
    queryset = Semester.objects.all()
    serializer_class = SemesterUpdateSerializer

    def update(self, request, *args, **kwargs):
        try:
            partial = kwargs.pop('partial', False)
            instance = self.get_object()
            # Validate input data
            serializer = self.get_serializer(instance, data=request.data, partial=partial)
            serializer.is_valid(raise_exception=True)

            # Access serializer data
            semester_code = serializer.validated_data.get('semester_code').upper()
            semester_description = serializer.validated_data.get('semester_description')
            updated_by = serializer.validated_data.get('updated_by')

            # Check if the data matches the same instance
            if (instance.semester_code == semester_code and
                    instance.semester_description == semester_description
            ):
                return Response({'message': 'No changes identified'}, status=status.HTTP_200_OK)

            # Check if the new name already exists
            if Semester.objects.exclude(pk=instance.pk).filter(semester_code=semester_code).exists():
                return Response({'message': f"The semester {semester_code} already exists."},
                                status=status.HTTP_400_BAD_REQUEST)

            # Update instance with new data
            instance.semester_code = semester_code
            instance.semester_description = semester_description
            instance.updated_by = updated_by
            instance.save()

            return Response({'message': 'Semester updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred.' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)


        except Exception as e:

            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='SemesterUpdate',
            message=error_message,
        )


class SemesterDeleteView(DestroyAPIView):
    queryset = Semester.objects.all()
    serializer_class = SemesterSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance.is_active:
                instance.is_active = False
                instance.save()

                return Response({'message': 'Semester Deactivated Successfully'},
                                status=status.HTTP_200_OK)
            else:
                return Response({'message': 'Semester already Deactivated.'},
                                status=status.HTTP_400_BAD_REQUEST)

        except Http404:
            return Response({'message': 'Semester not found'}, status=status.HTTP_404_NOT_FOUND)


class SectionCreateView(CreateAPIView):
    queryset = Section.objects.all()
    serializer_class = SectionSerializer

    def create(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            section_name = serializer.validated_data['section_name'].upper()
            created_by = serializer.validated_data.get('created_by')

            # Check If The section already exist
            if Section.objects.filter(section_name=section_name, is_active=True).exists():
                return Response(
                    {'message': 'Section Name already exists.'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            Section_instance = Section(
                section_name=section_name,
                created_by=created_by
            )

            Section_instance.save()

            # Make response data based on serializer
            data = SectionSerializer(Section_instance).data

            return Response({'message': 'Section Created successfully', 'data': data}, status=status.HTTP_201_CREATED)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            # Rollback the transaction on database error
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)


        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='sectioncreate',
            message=error_message,
        )


class SectionListView(ListAPIView):
    queryset = Section.objects.all()
    serializer_class = SectionSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            # prepare data from response
            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        # Prepare the custom response data
                        responsedata.append({
                            "id": item.get('id'),
                            "section_name": item.get('section_name')

                        })
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='sectionlist',

            message=error_message,

        )


class GetAllSectionByFilterListView(ListAPIView):
    queryset = Section.objects.all()
    serializer_class = SectionSerializer

    def list(self, request, *args, **kwargs):
        try:
            organization_id = request.query_params.get('organization_id')
            batch_id = request.query_params.get('batch_id')
            course_id = request.query_params.get('course_id')
            department_id = request.query_params.get('department_id')
            academic_year_id = request.query_params.get('academic_year_id')
            semester_id = request.query_params.get('semester_id')

            filterdata = Section.objects.filter(is_active=True)

            # prepare data from response
            if filterdata:
                responsedata = []
                if organization_id:
                    filterdata = filterdata.filter(organization=organization_id)

                if batch_id:
                    filterdata = filterdata.filter(batch=batch_id)

                if course_id:
                    filterdata = filterdata.filter(course=course_id)

                if department_id:
                    filterdata = filterdata.filter(department=department_id)

                if academic_year_id:
                    filterdata = filterdata.filter(academic_year=academic_year_id)

                if semester_id:
                    filterdata = filterdata.filter(semester=semester_id)

                for item in filterdata:
                    # Prepare the custom response data
                    responsedata.append({
                        "id": item.id,
                        "section_name": item.section_name

                    })
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='sectionlistbyfilter',

            message=error_message,

        )


# need to be work on SectionDetailView
class SectionDetailView(RetrieveAPIView):
    queryset = Section.objects.all()
    serializer_class = SectionSerializer

    def retrieve(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance:
                data = {
                    "id": instance.id,
                    "section_name": instance.section_name,

                    "is_active": instance.is_active,
                    "created_by": instance.created_by,
                    "created_at": instance.created_at,
                    "updated_at": instance.updated_at,

                }

                return Response(data, status=status.HTTP_200_OK)
        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='sectionretrive',

            message=error_message,

        )


class SectionUpdateView(UpdateAPIView):
    queryset = Section.objects.all()
    serializer_class = SectionUpdateSerializer

    def update(self, request, *args, **kwargs):
        try:
            partial = kwargs.pop('partial', False)
            instance = self.get_object()
            # Validate input data
            serializer = self.get_serializer(instance, data=request.data, partial=partial)
            serializer.is_valid(raise_exception=True)

            # Access serializer data
            section_name = serializer.validated_data.get('section_name').upper()
            updated_by = serializer.validated_data.get('updated_by')

            # Check if the data matches the same instance
            if (instance.section_name == section_name):
                return Response({'message': 'No changes identified'}, status=status.HTTP_200_OK)

            # Check if the new name already exists
            if Section.objects.exclude(pk=instance.pk).filter(section_name=section_name, is_active=True).exists():
                return Response({'message': f"The section {section_name} already exists."},
                                status=status.HTTP_400_BAD_REQUEST)

            # Update instance with new data
            instance.section_name = section_name
            instance.updated_by = updated_by
            instance.save()

            return Response({'message': 'Section updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred.' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='sectionupdate',
            message=error_message,
        )


class SectionDeleteView(DestroyAPIView):
    queryset = Section.objects.all()
    serializer_class = SectionSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance.is_active:
                instance.is_active = False
                instance.save()

                return Response({'message': 'Section Deactivated Successfully'},
                                status=status.HTTP_200_OK)
            else:
                return Response({'message': 'Section already Deactivated.'},
                                status=status.HTTP_400_BAD_REQUEST)
        except Http404:
            return Response({'message': 'Section not found'}, status=status.HTTP_404_NOT_FOUND)


class CourseSemesterSectionBindCreateView(CreateAPIView):
    queryset = CourseSemesterSectionBind.objects.all()
    serializer_class = CourseSemesterSectionBindSerializer

    def create(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            # academic_year= serializer.validated_data['academic_year']
            course = serializer.validated_data['course']
            section = serializer.validated_data['section']
            created_by = serializer.validated_data.get('created_by')

            # Check If The Course & Section already exist
            if CourseSemesterSectionBind.objects.filter(course=course, section=section, is_active=True).exists():
                return Response(
                    {'message': 'Course Bind with Section already exists .'},  # in this academic year
                    status=status.HTTP_400_BAD_REQUEST
                )

            # create & save the object into DB

            course_semester_section_instance = CourseSemesterSectionBind(
                course=course,
                section=section,
                created_by=created_by,
                updated_by=created_by
            )

            course_semester_section_instance.save()

            # Make response data based on serializer
            data = CourseSemesterSectionBindSerializer(course_semester_section_instance).data

            return Response({'message': 'Course Bind with Section successfully', 'data': data},
                            status=status.HTTP_201_CREATED)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            # Rollback the transaction on database error
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='course_semester_section_bind_create',
            message=error_message,
        )


class CourseSemesterSectionBindListView(ListAPIView):
    queryset = CourseSemesterSectionBind.objects.all()
    serializer_class = CourseSemesterSectionBindSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            # prepare data from response
            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        # academic_year = item.get('academic_year')
                        batch = item.get('batch')
                        course = item.get('course')
                        department = item.get('department')
                        semester = item.get('semester')
                        section = item.get('section')

                        batch_instance = Batch.objects.get(id=batch)
                        course_instance = Course.objects.get(id=course)
                        department_instance = Department.objects.get(id=department)
                        semester_instance = Semester.objects.get(id=semester)
                        section_instance = Section.objects.get(id=section)

                        # academic_year_instance = AcademicYear.objects.get(id=academic_year)

                        # Prepare the custom response data
                        responsedata.append({
                            "id": item.get('id'),
                            'batch_id': batch_instance.id,
                            'batch': batch_instance.batch_description,
                            'course_id': course_instance.id,
                            'course_name': course_instance.course_name,
                            'department_id': department_instance.id,
                            'department_name': department_instance.department_description,
                            'semester_id': semester_instance.id,
                            'semester_name': semester_instance.semester_description,
                            'section_id': section_instance.id,
                            'section_name': section_instance.section_name,

                        })
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='sectionlist',

            message=error_message,

        )


# need to be work   CourseSectionBindDetailView
class CourseSemesterSectionBindDetailView(RetrieveAPIView):
    queryset = CourseSemesterSectionBind.objects.all()
    serializer_class = CourseSemesterSectionBindSerializer

    def retrieve(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance:
                id = instance.id
                academic_year = instance.academic_year.id
                course_name = instance.course_name.id
                section_name = instance.section_name.id

                academic_year_instance = AcademicYear.objects.get(id=academic_year)
                course_instance = Course.objects.get(id=course_name)
                section_instance = Section.objects.get(id=section_name)

                data = {
                    "id": id,
                    "academicyear_id": academic_year_instance.id,
                    "academicyear": academic_year_instance.academic_year_code,
                    "course_id": course_instance.id,
                    "course_name": course_instance.course_name,
                    "section_id": section_instance.id,
                    "section_name": section_instance.section_name,

                }

                return Response(data, status=status.HTTP_200_OK)
        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='CourseSectionBindretrive',

            message=error_message,

        )


class CourseSemesterSectionBindUpdateView(UpdateAPIView):
    queryset = CourseSemesterSectionBind.objects.all()
    serializer_class = CourseSemesterSectionBindUpdateSerializer

    def update(self, request, *args, **kwargs):
        try:
            partial = kwargs.pop('partial', False)
            instance = self.get_object()
            # Validate input data
            serializer = self.get_serializer(instance, data=request.data, partial=partial)
            serializer.is_valid(raise_exception=True)

            # Access serializer data
            # academic_year = serializer.validated_data.get('academic_year')
            course_name = serializer.validated_data.get('course_name')
            semester = serializer.validated_data.get('course_name')
            section_name = serializer.validated_data.get('section_name')
            updated_by = serializer.validated_data.get('updated_by')

            # Check if the data matches the same instance

            # Check if the data matches the same instance
            # if (instance.academic_year == academic_year,
            #     instance.classname == classname,
            #     instance.sectionname == sectionname):
            #     return Response({'message': 'No changes identified'}, status=status.HTTP_200_OK)  #need to be modify

            # Check if the new name already exists
            if CourseSemesterSectionBind.objects.exclude(pk=instance.pk).filter(course__course_name=course_name,
                                                                                section__section_name=section_name,
                                                                                is_active=True).exists():
                return Response(
                    {'message': f"This Course Semester Bind section {course_name}-{section_name} already exists."},
                    status=status.HTTP_400_BAD_REQUEST)

            # Update instance with new data
            # instance.academic_year = academic_year
            instance.course.course_name = course_name
            instance.section.section_name = section_name
            instance.updated_by = updated_by
            instance.save()

            return Response({'message': 'Course Bind With Section updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred.' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:

            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='CourseSectionBindupdate',
            message=error_message,
        )


class CourseSemesterSectionBindDeleteView(DestroyAPIView):
    queryset = CourseSemesterSectionBind.objects.all()
    serializer_class = CourseSemesterSectionBindSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance.is_active:
                instance.is_active = False
                instance.save()

                return Response({'message': f' record deleted successfully !!.'}, status=status.HTTP_200_OK)
        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)


class GetAllSectionBindWithCourseSemester(ListAPIView):
    serializer_class = CourseSemesterSectionBindSerializer

    def get_queryset(self):
        # Get class ID from the URL parameters
        course_id = self.kwargs.get('pk')
        semester_id = self.kwargs.get('pk')

        if course_id:
            # Filter the queryset based on the class ID
            return CourseSemesterSectionBind.objects.filter(course=course_id, is_active=True)
        return CourseSemesterSectionBind.objects.none()  # Return an empty queryset if no class_id is provided

    def list(self, request, *args, **kwargs):
        try:
            course_id = self.kwargs.get('pk')

            # Get CourseSemesterSectionBind records directly
            queryset = CourseSemesterSectionBind.objects.filter(course_id=course_id, is_active=True)

            if queryset.exists():
                responsedata = []
                for item in queryset:
                    # Access related objects directly through ForeignKey
                    data = {
                        'id': item.id,
                        'course_id': item.course.id if item.course else None,
                        'course_name': item.course.course_name if item.course else None,
                        'section_id': item.section.id if item.section else None,
                        'section_name': item.section.section_name if item.section else None,
                        'semester_id': item.semester.id if item.semester else None,
                        'semester_code': item.semester.semester_code if item.semester else None,
                    }
                    responsedata.append(data)
                return Response({'message': 'success', 'data': responsedata}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', 'data': []}, status=status.HTTP_200_OK)

        except Exception as e:
            # Handle and log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='GetsectionlistByCourse',
            message=error_message,
        )


# class StudentRegistrationCreateView(CreateAPIView):
#     queryset = Student_Registration.objects.all()
#     serializer_class = StudentRegistrationSerializer
#
#     def generate_registration_no(self):
#         current_year_month = datetime.now().strftime('%y%m')  # Get the current year and month in YYMM format
#
#         # Get the last student registered
#         last_student = Student_Registration.objects.order_by('registration_no').last()
#
#         if last_student:
#             # Extract the last 4 digits and increment by 1
#             last_registration_no = int(last_student.registration_no[-4:])
#             new_registration_no = f"{last_registration_no + 1:04d}"
#         else:
#             # Start with '1001' if no student registered yet
#             new_registration_no = '1001'
#
#         # Combine the year-month prefix with the new registration number
#         return f"{current_year_month}{new_registration_no}"
#
#     def create(self, request, *args, **kwargs):
#         try:
#             serializer = self.get_serializer(data=request.data)
#             serializer.is_valid(raise_exception=True)
#
#             # Generate the registration number
#             registration_no = self.generate_registration_no()
#
#             academic_year = serializer.validated_data.get('academic_year')
#             admission_no = serializer.validated_data.get('admission_no')
#             parent_id = serializer.validated_data.get('parent_id')
#             studentname = serializer.validated_data.get('studentname')
#             addmitted_class = serializer.validated_data.get('addmitted_class')
#             addmitted_section = serializer.validated_data.get('addmitted_section')
#             primary_guardian = serializer.validated_data.get('primary_guardian')
#             gender = serializer.validated_data.get('gender')
#             date_of_admission = serializer.validated_data.get('date_of_admission')
#             doj = serializer.validated_data.get('doj')
#             fee_group  = serializer.validated_data.get('fee_group')
#             feeappfrom = serializer.validated_data.get('feeappfrom')
#             enrollment_no = serializer.validated_data.get('enrollment_no')
#             barcode = serializer.validated_data.get('barcode')
#             registration_no = registration_no  #serializer.validated_data.get('registration_no')
#             college_admission_no = serializer.validated_data.get('college_admission_no')
#             cbse_reg_no= serializer.validated_data.get('cbse_reg_no')
#             house = serializer.validated_data.get('house')
#             religion = serializer.validated_data.get('religion')
#             category = serializer.validated_data.get('category')
#             nativelanguage = serializer.validated_data.get('nativelanguage')
#             bloodgroup = serializer.validated_data.get('bloodgroup')
#             nationality = serializer.validated_data.get('nationality')
#             email = serializer.validated_data.get('email')
#             dob = serializer.validated_data.get('dob')
#             childreninfamily = serializer.validated_data.get('childreninfamily')
#             studentaadharno = serializer.validated_data.get('studentaadharno')
#             username = serializer.validated_data.get('username')
#             remarks = serializer.validated_data.get('remarks')
#             profile_pic = serializer.validated_data.get('profile_pic')
#             father_name = serializer.validated_data.get('father_name')
#             father_profession = serializer.validated_data.get('father_profession')
#             father_contact_number = serializer.validated_data.get('father_contact_number')
#             father_email = serializer.validated_data.get('father_email')
#             father_aadharno = serializer.validated_data.get('father_aadharno')
#             mother_name = serializer.validated_data.get('mother_name')
#             mother_profession = serializer.validated_data.get('mother_profession')
#             mother_contact_number = serializer.validated_data.get('mother_contact_number')
#             mother_email = serializer.validated_data.get('mother_email')
#             mother_aadharno = serializer.validated_data.get('mother_aadharno')
#             residence_address = serializer.validated_data.get('residence_address')
#             permanent_address = serializer.validated_data.get('permanent_address')
#
#             # Handle studentaadharno & email
#             if studentaadharno == '':
#                 studentaadharno = None
#
#             if email == '':
#                 email = None
#
#
#             Student_Registration_instance = Student_Registration(
#                 academic_year=academic_year,
#                 admission_no=admission_no,
#                 parent_id=parent_id,
#                 studentname=studentname,
#                 addmitted_class= addmitted_class,
#                 addmitted_section=addmitted_section,
#                 primary_guardian = primary_guardian,
#                 gender= gender,
#                 date_of_admission = date_of_admission,
#                 doj = doj,
#                 fee_group = fee_group,
#                 feeappfrom = feeappfrom,
#                 enrollment_no = enrollment_no,
#                 barcode = barcode,
#                 registration_no = registration_no,
#                 college_admission_no = college_admission_no,
#                 cbse_reg_no = cbse_reg_no,
#                 house= house,
#                 religion = religion,
#                 category = category,
#                 nativelanguage = nativelanguage,
#                 bloodgroup = bloodgroup,
#                 nationality = nationality,
#                 email = email,
#                 dob = dob,
#                 childreninfamily = childreninfamily,
#                 studentaadharno = studentaadharno,
#                 username= username,
#                 remarks = remarks,
#                 profile_pic = profile_pic,
#                 father_name = father_name,
#                 father_profession = father_profession,
#                 father_contact_number = father_contact_number,
#                 father_email = father_email,
#                 father_aadharno = father_aadharno,
#                 mother_name = mother_name,
#                 mother_profession = mother_profession,
#                 mother_contact_number = mother_contact_number,
#                 mother_email = mother_email,
#                 mother_aadharno = mother_aadharno,
#                 residence_address = residence_address,
#                 permanent_address = permanent_address
#
#             )
#
#             Student_Registration_instance.save()
#
#             # Make response data based on serializer
#             data = StudentRegistrationSerializer(Student_Registration_instance).data
#
#             return Response({'message': 'Registration successfully', 'data': data},
#                             status=status.HTTP_201_CREATED)
#
#         except ValidationError as e:
#             return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)
#
#
#         except Exception as e:
#             # Log the exception
#             error_message = str(e)
#             self.log_exception(request, error_message)
#             return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#     def log_exception(self, request, error_message):
#         ExceptionTrack.objects.create(
#             request=str(request),
#             process_name='studentregistration',
#             message=error_message,
#         )
# class StudentRegistrationListView(ListAPIView):
#     queryset = Student_Registration.objects.all()
#     serializer_class = StudentRegistrationSerializer
#
#     def list(self, request, *args, **kwargs):
#         try:
#             response = super().list(request, *args, **kwargs)
#             resdata = response.data
#
#             # prepare data from response
#
#             responsedata = []
#
#             if resdata:
#                 for item in resdata:
#
#                     academic_year = item.get('academic_year')
#                     addmitted_class = item.get('addmitted_class')
#                     addmitted_section = item.get('addmitted_section')
#
#
#                     course_instance = Course.objects.get(id=addmitted_class)
#
#                     section_instance = Section.objects.get(id=addmitted_section)
#
#                     academic_year_instance = AcademicYear.objects.get(id=academic_year)
#
#                     # Make Response data
#                     data = {
#                         'id': item.get('id'),
#                         # 'academicyear_id': academic_year_instance.id,
#                         'academicyear': f'{academic_year_instance.Start_Year.year}-{academic_year_instance.End_Year.year}',
#                         # 'class_id': course_instance.id,
#                         'classname': course_instance.classname,
#                         # 'section_id': section_instance.id,
#                         'sectionname': section_instance.sectionname,
#                         'admission_no': item.get('addmitted_class'),
#                         'parent_id': item.get('parent_id'),
#                         'studentname': item.get('studentname'),
#                         'primary_guardian': item.get('primary_guardian'),
#                         'gender': item.get('gender'),
#                         'date_of_admission': item.get('date_of_admission'),
#                         'doj': item.get('doj'),
#                         'fee_group': item.get('fee_group'),
#                         'feeappfrom': item.get('feeappfrom'),
#                         'enrollment_no': item.get('enrollment_no'),
#                         'barcode': item.get('barcode'),
#                         'registration_no': item.get('registration_no'),
#                         'college_admission_no': item.get('college_admission_no'),
#                         'cbse_reg_no': item.get('cbse_reg_no'),
#                         'house': item.get('house'),
#                         'religion': item.get('religion'),
#                         'category': item.get('category'),
#                         'native_language': item.get('nativelanguage'),
#                         'bloodgroup': item.get('bloodgroup'),
#                         'nationality': item.get('nationality'),
#                         'email': item.get('email'),
#                         'dob': item.get('dob'),
#                         'children_in_family': item.get('childreninfamily'),
#                         'studentaadharno': item.get('studentaadharno'),
#                         'username': item.get('username'),
#                         'remarks': item.get('remarks'),
#                         'profile_pic': item.get('profile_pic'),
#                         'father_name': item.get('father_name'),
#                         'father_profession': item.get('father_profession'),
#                         'father_contact_number': item.get('father_contact_number'),
#                         'father_email': item.get('father_email'),
#                         'father_aadharno': item.get('father_aadharno'),
#                         'mother_name': item.get('mother_name'),
#                         'mother_profession': item.get('mother_profession'),
#                         'mother_contact_number': item.get('mother_contact_number'),
#                         'mother_email': item.get('mother_email'),
#                         'mother_aadharno': item.get('mother_aadharno'),
#                         'residence_address': item.get('residence_address'),
#                         'permanent_address': item.get('permanent_address'),
#                         'is_active': item.get('is_active'),
#                         'created_at': item.get('created_at'),
#                         'updated_at': item.get('updated_at')
#                     }
#
#                     responsedata.append(data)
#                 return Response({'message': 'success', 'data': responsedata})
#             else:
#                 return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)
#
#         except Exception as e:
#
#             # Log the exception
#
#             error_message = str(e)
#
#             self.log_exception(request, error_message)
#
#             return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#     def log_exception(self, request, error_message):
#
#         ExceptionTrack.objects.create(
#
#             request=str(request),
#
#             process_name='registrationlist',
#
#             message=error_message,
#
#         )
# class StudentRegistrationDetailView(RetrieveAPIView):
#     queryset = Student_Registration.objects.all()
#     serializer_class = StudentRegistrationSerializer
#
#     def retrieve(self, request, *args, **kwargs):
#         try:
#             instance= self.get_object()
#
#             if instance:
#                 academic_year= instance.academic_year.id
#                 addmitted_class = instance.addmitted_class.id
#                 addmitted_section = instance.addmitted_section.id
#
#                 academic_year_instance= AcademicYear.objects.get(id=academic_year)
#                 course_instance= Course.objects.get(id=addmitted_class)
#                 section_instance = Section.objects.get(id= addmitted_section)
#
#
#                 data = {
#                     "id": instance.id,
#                     # "academicyear_id": academic_year_instance.id,
#                     "academicyear": f'{academic_year_instance.Start_Year.year}-{academic_year_instance.End_Year.year}',
#                     # "class_id":course_instance.id,
#                     "classname": course_instance.classname,
#                     # "section_id": section_instance.id,
#                     "sectionname": section_instance.sectionname,
#                     'admission_no': instance.admission_no,
#                     'parent_id': instance.parent_id,
#                     'studentname': instance.studentname,
#                     'primary_guardian': instance.primary_guardian,
#                     'gender': instance.gender,
#                     'date_of_admission': instance.date_of_admission,
#                     'doj': instance.doj ,
#                     'fee_group': instance.fee_group,
#                     'feeappfrom':instance.feeappfrom,
#                     'enrollment_no': instance.enrollment_no,
#                     'barcode': instance.barcode,
#                     'registration_no': instance.registration_no,
#                     'college_admission_no': instance.college_admission_no,
#                     'cbse_reg_no': instance.cbse_reg_no,
#                     'house': instance.house,
#                     'religion': instance.religion,
#                     'category': instance.category,
#                     'native_language': instance.nativelanguage,
#                     'bloodgroup': instance.bloodgroup,
#                     'nationality': instance.nationality,
#                     'email': instance.email,
#                     'dob': instance.dob,
#                     'children_in_family': instance.childreninfamily,
#                     'studentaadharno': instance.studentaadharno,
#                     'username': instance.username,
#                     'remarks': instance.remarks,
#                     'profile_pic':instance.profile_pic.url if instance.profile_pic else None,
#                     'father_name': instance.father_name,
#                     'father_profession': instance.father_profession,
#                     'father_contact_number': instance.father_contact_number,
#                     'father_email': instance.father_email,
#                     'father_aadharno': instance.father_aadharno,
#                     'mother_name': instance.mother_name,
#                     'mother_profession': instance.mother_profession,
#                     'mother_contact_number': instance.mother_contact_number,
#                     'mother_email': instance.mother_email,
#                     'mother_aadharno': instance.mother_aadharno,
#                     'residence_address': instance.residence_address,
#                     'permanent_address': instance.permanent_address,
#                     "is_active": instance.is_active,
#                     "created_at": instance.created_at,
#                     "updated_at": instance.updated_at,
#
#                 }
#
#                 return Response({'message': 'success', 'data': data},status=status.HTTP_200_OK)
#
#         except Http404:
#
#             return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)
#
#         except Exception as e:
#
#             # Log the exception
#
#             error_message = str(e)
#
#             self.log_exception(request, error_message)
#
#             return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#     def log_exception(self, request, error_message):
#
#         ExceptionTrack.objects.create(
#
#             request=str(request),
#
#             process_name='registrationretrive',
#
#             message=error_message,
#
#         )
# class StudentRegistrationUpdateView(UpdateAPIView):
#     queryset = Student_Registration.objects.all()
#     serializer_class = StudentRegistrationSerializer
#
#     def update(self, request, *args, **kwargs):
#         try:
#             partial = kwargs.pop('partial', False)
#             instance = self.get_object()
#             # Validate input data
#             serializer = self.get_serializer(instance, data=request.data, partial=partial)
#             serializer.is_valid(raise_exception=True)
#
#             # Access serializer data
#             admission_no = serializer.validated_data.get('admission_no')
#             parent_id= serializer.validated_data.get('parent_id')
#             studentname = serializer.validated_data.get('studentname')
#             addmitted_class = serializer.validated_data.get('addmitted_class')
#             addmitted_section = serializer.validated_data.get('addmitted_section')
#             primary_guardian = serializer.validated_data.get('primary_guardian')
#             gender = serializer.validated_data.get('gender')
#             date_of_admission = serializer.validated_data.get('date_of_admission')
#             doj  = serializer.validated_data.get('doj')
#             fee_group = serializer.validated_data.get('fee_group')
#             feeappfrom = serializer.validated_data.get('feeappfrom')
#             enrollment_no = serializer.validated_data.get('enrollment_no')
#             barcode = serializer.validated_data.get('barcode')
#             college_admission_no = serializer.validated_data.get('college_admission_no')
#             cbse_reg_no = serializer.validated_data.get('cbse_reg_no')
#             house = serializer.validated_data.get('house')
#             religion = serializer.validated_data.get('religion')
#             category = serializer.validated_data.get('category')
#             nativelanguage = serializer.validated_data.get('nativelanguage')
#             bloodgroup = serializer.validated_data.get('bloodgroup')
#             nationality = serializer.validated_data.get('nationality')
#             email = serializer.validated_data.get('email')
#             dob = serializer.validated_data.get('dob')
#             childreninfamily = serializer.validated_data.get('childreninfamily')
#             studentaadharno = serializer.validated_data.get('studentaadharno')
#             username = serializer.validated_data.get('username')
#             remarks = serializer.validated_data.get('remarks')
#             profile_pic = serializer.validated_data.get('profile_pic')
#             father_name = serializer.validated_data.get('father_name')
#             father_profession = serializer.validated_data.get('father_profession')
#             father_contact_number = serializer.validated_data.get('father_contact_number')
#             father_email = serializer.validated_data.get('father_email')
#             father_aadharno = serializer.validated_data.get('father_aadharno')
#             mother_name = serializer.validated_data.get('mother_name')
#             mother_profession = serializer.validated_data.get('mother_profession')
#             mother_contact_number = serializer.validated_data.get('mother_contact_number')
#             mother_email = serializer.validated_data.get('mother_email')
#             mother_aadharno = serializer.validated_data.get('mother_aadharno')
#             residence_address = serializer.validated_data.get('residence_address')
#             permanent_address = serializer.validated_data.get('permanent_address')
#
#             # Handle studentaadharno & email
#             if studentaadharno == '':
#                 studentaadharno = None
#
#             if email == '':
#                 email = None
#
#             # Check if the email already exists for another user
#             if email and Student_Registration.objects.filter(email=email).exclude(id=instance.id).exists():
#                 return Response({'error': 'Email already exists .'},
#                                 status=status.HTTP_400_BAD_REQUEST)
#
#
#             # Check if the data matches the existing instance
#             if all(getattr(instance, key) == value for key, value in serializer.validated_data.items()):
#                 return Response({'message': 'No changes identified'}, status=status.HTTP_200_OK)
#
#
#             # Update instance with new data
#             instance.admission_no = admission_no
#             instance.parent_id = parent_id
#             instance.studentname = studentname
#             instance.addmitted_class = addmitted_class
#             instance.addmitted_section = addmitted_section
#             instance.primary_guardian = primary_guardian
#             instance.gender = gender
#             instance.date_of_admission = date_of_admission
#             instance.doj = doj
#             instance.fee_group = fee_group
#             instance.feeappfrom = feeappfrom
#             instance.enrollment_no = enrollment_no
#             instance.barcode = barcode
#             instance.college_admission_no = college_admission_no
#             instance.cbse_reg_no = cbse_reg_no
#             instance.house = house
#             instance.religion = religion
#             instance.category = category
#             instance.nativelanguage = nativelanguage
#             instance.bloodgroup = bloodgroup
#             instance.nationality = nationality
#             instance.email = email
#             instance.dob = dob
#             instance.childreninfamily = childreninfamily
#             instance.studentaadharno = studentaadharno
#             instance.username = username
#             instance.remarks = remarks
#             instance.profile_pic = profile_pic
#             instance.father_name = father_name
#             instance.father_profession = father_profession
#             instance.father_contact_number = father_contact_number
#             instance.father_email = father_email
#             instance.father_aadharno = father_aadharno
#             instance.mother_name = mother_name
#             instance.mother_profession = mother_profession
#             instance.mother_contact_number = mother_contact_number
#             instance.mother_email = mother_email
#             instance.mother_aadharno = mother_aadharno
#             instance.residance_address = residence_address
#             instance.permanent_address = permanent_address
#             instance.save()
#
#             return Response({'message': 'Record updated successfully.'}, status=status.HTTP_200_OK)
#
#         except Http404:
#             return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)
#
#         except ValidationError as e:
#             return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)
#
#         except Exception as e:
#
#             #Log the exception
#             error_message = str(e)
#             self.log_exception(request, error_message)
#             return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#     def log_exception(self, request, error_message):
#         ExceptionTrack.objects.create(
#             request=str(request),
#             process_name='registrationupdate ',
#             message=error_message,
#         )

# class StudentRegistrationDeleteView(DestroyAPIView):
#     queryset = Student_Registration.objects.all()
#     serializer_class = StudentRegistrationSerializer
#
#     def destroy(self, request, *args, **kwargs):
#         instance = self.get_object()
#         if instance.is_active:
#             instance.is_active = False
#             instance.save()
#             return Response({'message': 'Student deactivated successfully.'}, status=status.HTTP_200_OK)
#         else:
#             return Response({'message': 'Student is already inactive.'}, status=status.HTTP_400_BAD_REQUEST)

class SiblingDetailCreateView(CreateAPIView):
    queryset = SiblingDetail.objects.all()
    serializer_class = StudentSiblingDetailSerializer

    def create(self, request, *args, **kwargs):
        # student_id = self.kwargs.get('student_id')
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            student_id = serializer.validated_data['student_id']

            sibling_id = serializer.validated_data['sibling_id']
            created_by = serializer.validated_data['created_by']

            # Check if the combination of student_id and sibling_id already exists
            if SiblingDetail.objects.filter(student=student_id, sibling=sibling_id, is_active=True).exists():
                return Response({'message': 'This sibling relationship has already been added.'},
                                status=status.HTTP_400_BAD_REQUEST)

            # Add siblings

            SiblingDetail_instance = SiblingDetail(
                student=student_id,
                siblings=sibling_id,
                created_by=created_by,
                updated_by=created_by
            )

            # save data into DB

            SiblingDetail_instance.save()

            # Prepare the response data
            response_data = {
                'message': 'Added Successfully!',
                'data': {
                    'id': SiblingDetail_instance.id,
                    'student_name': SiblingDetail_instance.student.first_name,
                    'sibling_name': SiblingDetail_instance.sibling.first_name,
                    'student_id': SiblingDetail_instance.student.id,
                    'sibling_id': SiblingDetail_instance.sibling.id,
                    'is_active': SiblingDetail_instance.is_active,
                    'created_at': SiblingDetail_instance.created_at,
                    'updated_at': SiblingDetail_instance.updated_at
                }
            }

            return Response(response_data, status=status.HTTP_201_CREATED)

        except ValidationError as e:

            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            # Rollback the transaction on database error
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='sibilingsAdd',

            message=error_message,

        )

    # def create(self, request, *args, **kwargs):
    #     try:
    #         serializer = self.get_serializer(data=request.data)
    #         serializer.is_valid(raise_exception=True)
    #
    #         student_id= serializer.validated_data['student_id']
    #         sibling_id = serializer.validated_data['sibling_id']
    #
    #         # Check if the student exists
    #         if not Student_Registration.objects.filter(pk=student_id).exists():
    #             return Response({'error': 'Student not found'}, status=status.HTTP_404_NOT_FOUND)
    #
    #         # Create or get the SiblingDetail instance
    #         sibling_details, created = SiblingDetail.objects.get_or_create(
    #             student_id=Student_Registration.objects.get(pk=student_id))
    #
    #         # Validate and add siblings
    #         for sibling_id in sibling_id:
    #             if sibling_id == student_id:
    #                 return Response({'error': 'A student cannot be their own sibling.'},
    #                                 status=status.HTTP_400_BAD_REQUEST)
    #
    #             if not Student_Registration.objects.filter(pk=sibling_id).exists():
    #                 return Response({'error': f'Sibling with ID {sibling_id} not found'},
    #                                 status=status.HTTP_404_NOT_FOUND)
    #
    #             sibling = Student_Registration.objects.get(pk=sibling_id)
    #             if not sibling_details.sibling_id.filter(pk=sibling.pk).exists():
    #                 sibling_details.sibling_id.add(sibling)
    #
    #         sibling_details.save()
    #
    #         # Serialize the response
    #         response_serializer = self.get_serializer(sibling_details)
    #         return Response(response_serializer.data, status=status.HTTP_201_CREATED)
    #
    #
    #     except ValidationError as e:
    #
    #         return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)
    #
    #     except Exception as e:
    #
    #         # Log the exception
    #
    #         error_message = str(e)
    #
    #         self.log_exception(request, error_message)
    #
    #         return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    #
    # def log_exception(self, request, error_message):
    #
    #     ExceptionTrack.objects.create(
    #
    #         request=str(request),
    #
    #         process_name='sibilingsAdd',
    #
    #         message=error_message,
    #
    #     )


class SiblingDetailListAPIView(ListAPIView):
    queryset = SiblingDetail.objects.all()
    serializer_class = StudentSiblingDetailSerializer

    def list(self, request, *args, **kwargs):
        try:
            # Get the serialized response data
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            # prepare data from response
            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        student_id = item.get('student_id')
                        sibling_id = item.get('sibling_id')

                        student_instance = StudentRegistration.objects.get(id=student_id)
                        sibling_instance = StudentRegistration.objects.get(id=sibling_id)

                        # Get related class and section instances
                        sibling_course = sibling_instance.course
                        sibling_department = sibling_instance.department
                        sibling_semester = sibling_instance.semester
                        sibling_section = sibling_instance.section

                        section_instance = Section.objects.get(id=sibling_section.id)

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'student_name': student_instance.first_name,
                            'sibling_name': sibling_instance.first_name,
                            # Assuming `course_name` is a field in `Course` model
                            'sibling_course': sibling_course.course_name,
                            'sibling_department': sibling_department.department_name,
                            'sibling_semester': sibling_semester.semester_name,
                            # # Assuming `section_name` is a field in `Section` model
                            'section': section_instance.section_name,
                            'admission_no': sibling_instance.admission_no,

                        })
                    else:
                        continue

                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='siblingsdetailslist',
            message=error_message,
        )


class GetAllSibilingsByStudent(ListAPIView):
    serializer_class = StudentSiblingDetailSerializer

    def get_queryset(self):
        student_id = self.kwargs.get('student_id')
        return SiblingDetail.objects.filter(student_id=student_id)

    def list(self, request, *args, **kwargs):

        try:
            # Get the serialized response data
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            # Prepare the custom response data

            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:
                        student_id = item.get('student_id')
                        sibling_id = item.get('sibling_id')

                        student_instance = StudentRegistration.objects.get(id=student_id)
                        sibling_instance = StudentRegistration.objects.get(id=sibling_id)

                        # Get related class and section instances
                        sibling_course = sibling_instance.course
                        sibling_department = sibling_instance.department
                        sibling_semester = sibling_instance.semester
                        siblings_section = sibling_instance.section

                        section_instance = Section.objects.get(id=siblings_section.id)

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'student_name': student_instance.first_name,
                            'sibling_name': sibling_instance.first_name,
                            'sibling_course': sibling_course.course_name,
                            'sibling_semester': sibling_semester.semester_name,
                            'sibling_section': section_instance.section_name,
                            'admission_no': sibling_instance.admission_no,

                        })
                    else:
                        continue

                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)


        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='GetAllsiblingsdetailslist',
            message=error_message,
        )


class SiblingDetailUpdateView(UpdateAPIView):
    queryset = SiblingDetail.objects.all()
    serializer_class = StudentSiblingDetailSerializer

    def update(self, request, *args, **kwargs):
        try:
            partial = kwargs.pop('partial', False)
            instance = self.get_object()
            # Validate input data
            serializer = self.get_serializer(instance, data=request.data, partial=partial)
            serializer.is_valid(raise_exception=True)

            # Access serializer data
            student_id = serializer.validated_data.get('student_id')
            sibling_id = serializer.validated_data.get('sibling_id')
            updated_by = serializer.validated_data.get('updated_by')

            # Check if the data matches the same instance
            if (instance.student_id == student_id and
                    instance.sibling == sibling_id):
                return Response({'message': 'No changes identified'}, status=status.HTTP_200_OK)

            # Check if the new name already exists
            if SiblingDetail.objects.exclude(pk=instance.pk).filter(student=student_id,
                                                                    sibling=sibling_id, is_active=True).exists():
                return Response({'message': f"This Siblings already exists."}, status=status.HTTP_400_BAD_REQUEST)

            # Update instance with new data
            instance.student_id = student_id
            instance.sibling_id = sibling_id
            instance.updated_by = updated_by

            instance.save()

            return Response({'message': 'Siblings updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except Exception as e:

            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='Siblingupdate',
            message=error_message,
        )


class SiblingDetailDeleteView(DestroyAPIView):
    queryset = SiblingDetail.objects.all()
    serializer_class = StudentSiblingDetailSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance.is_active:
                instance.is_active = False
                instance.save()

            # self.perform_destroy(instance)

            return Response({'message': f'  Sibling deleted successfully !!.'}, status=status.HTTP_200_OK)
        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)


class StudentEmergencyContactCreateView(CreateAPIView):
    queryset = StudentEmergencyContact.objects.all()
    serializer_class = StudentEmergencyContactSerializer

    def create(self, request, *args, **kwargs):
        # student_id = self.kwargs.get('student_id')
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            student_id = serializer.validated_data['student_id']

            name = serializer.validated_data['name']
            relationship = serializer.validated_data['relationship']
            mobile_number = serializer.validated_data['mobile_number']
            remark = serializer.validated_data['remark']
            created_by = serializer.validated_data['created_by']

            # Check if the combination of student_id and Emergency contact details already exists
            if StudentEmergencyContact.objects.filter(student=student_id, name=name, relationship=relationship,
                                                      mobile_number=mobile_number, is_active=True).exists():
                return Response({'message': 'This Emergency Contact has already been added.'},
                                status=status.HTTP_400_BAD_REQUEST)

            # Add Emergency Contact

            EmergencyDetailInstance = StudentEmergencyContact(
                student=student_id,
                name=name,
                relationship=relationship,
                mobile_number=mobile_number,
                remark=remark,
                created_by=created_by

            )

            # save data into DB

            EmergencyDetailInstance.save()

            # Prepare the response data
            response_data = {
                'message': 'Added Successfully!',
                'data': {
                    'id': EmergencyDetailInstance.id,
                    'name': EmergencyDetailInstance.name,
                    'relationship': EmergencyDetailInstance.relationship,
                    'mobile_number': EmergencyDetailInstance.mobile_number,
                    'remark': EmergencyDetailInstance.remark,
                    'is_active': EmergencyDetailInstance.is_active,
                    'created_at': EmergencyDetailInstance.created_at,
                    'updated_at': EmergencyDetailInstance.updated_at
                }
            }

            return Response(response_data, status=status.HTTP_201_CREATED)

        except ValidationError as e:

            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except Exception as e:
            # Log the exception
            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='EmergencyDetailsAdd',

            message=error_message,

        )


class StudentEmergencyContactListAPIView(ListAPIView):
    queryset = StudentEmergencyContact.objects.all()
    serializer_class = StudentEmergencyContactSerializer

    def list(self, request, *args, **kwargs):
        try:
            # Get the serialized response data
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            # prepare data from response
            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:
                        student = item.get('student_id')

                        student_instance = StudentRegistration.objects.get(id=student)

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'student_id': student_instance.id,
                            'student_name': student_instance.first_name,
                            'name': item.get('name'),
                            'relationship': item.get('relationship'),
                            'mobile_number': item.get('mobile_number'),
                            'remark': item.get('remark')

                        })

                    else:
                        continue

                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)



        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='StudentEmergencyDetailslist',
            message=error_message,
        )


class GetAllEmergencyContactDetailsByStudent(ListAPIView):
    serializer_class = StudentEmergencyContactSerializer

    def get_queryset(self):
        student_id = self.kwargs.get('student_id')
        return StudentEmergencyContact.objects.filter(student=student_id)

    def list(self, request, *args, **kwargs):

        try:
            # Get the serialized response data
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            # prepare data from response
            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:
                        student_id = item.get('student')

                        student_instance = StudentRegistration.objects.get(id=student_id)

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'student_id': student_instance.id,
                            'student_name': student_instance.first_name,
                            'name': item.get('name'),
                            'relationship': item.get('relationship'),
                            'mobile_number': item.get('mobile_number'),
                            'remark': item.get('remark')

                        })

                    else:
                        continue

                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)

            # Prepare the custom response data
            # responsedata = []
            #
            # if resdata:
            #     for item in resdata:
            #         student = item.get('student_id')
            #
            #         student_instance = StudentRegistration.objects.get(id=student)
            #
            #
            #
            #         # Prepare the custom response data
            #         responsedata.append({
            #             'id': item.get('id'),
            #             'student_id': student_instance.id,
            #             'student_name': student_instance.first_name,
            #             'name': item.get('name'),
            #             'relationship': item.get('relationship'),
            #             'mobile_number': item.get('mobile_number'),
            #             'remark': item.get('remark'),
            #             'is_active': item.get('is_active'),
            #             'created_at': item.get('created_at'),
            #             'updated_at': item.get('updated_at')
            #
            #         })
            #     return Response(responsedata, status=status.HTTP_200_OK)
            #
            # else:
            #     return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='GetAllEmergencyContactByStudentlist',
            message=error_message,
        )


class EmergencyContactUpdateView(UpdateAPIView):
    queryset = StudentEmergencyContact.objects.all()
    serializer_class = StudentEmergencyUpdateContactSerializer

    def update(self, request, *args, **kwargs):
        try:
            partial = kwargs.pop('partial', False)
            instance = self.get_object()
            # Validate input data
            serializer = self.get_serializer(instance, data=request.data, partial=partial)
            serializer.is_valid(raise_exception=True)

            # Access serializer data
            student_id = serializer.validated_data.get('student_id')
            name = serializer.validated_data.get('name')
            relationship = serializer.validated_data.get('relationship')
            mobile_number = serializer.validated_data.get('mobile_number')
            remark = serializer.validated_data.get('remark')
            updated_by = serializer.validated_data.get('updated_by')

            # Check if the data matches the existing instance
            if (instance.student_id == student_id and
                    instance.name == name and
                    instance.relationship == relationship and
                    instance.mobile_number == mobile_number and
                    instance.remark == remark):
                return Response({'message': 'No changes identified'}, status=status.HTTP_200_OK)

            # Check if the new name already exists
            if StudentEmergencyContact.objects.exclude(pk=instance.pk).filter(student_id=student_id,
                                                                              name=name, relationship=relationship,
                                                                              mobile_number=mobile_number,
                                                                              is_active=True).exists():
                return Response({'message': f"This Emergency Data already exists."}, status=status.HTTP_400_BAD_REQUEST)

            # Update instance with new data
            instance.student_id = student_id
            instance.name = name
            instance.relationship = relationship
            instance.mobile_number = mobile_number
            instance.remark = remark
            instance.updated_by = updated_by

            instance.save()

            return Response({'message': 'Emergency Data updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except Exception as e:

            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='EmergencyContactupdate',
            message=error_message,
        )


class EmergencyContactDeleteView(DestroyAPIView):
    queryset = StudentEmergencyContact.objects.all()
    serializer_class = StudentEmergencyContactSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()
            if instance.is_active:
                instance.is_active = False
                instance.save()

                return Response({'message': f'Emergency data deactivated successfully !!.'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'Emergency data already deactivated'}, status=status.HTTP_200_OK)
        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)


class AuthorisedPickupCreateView(CreateAPIView):
    queryset = AuthorisedPickup.objects.all()
    serializer_class = AuthorisedPickupSerializer

    def create(self, request, *args, **kwargs):
        # student_id = self.kwargs.get('student_id')
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            student_id = serializer.validated_data['student_id']

            name = serializer.validated_data['name']
            relationship = serializer.validated_data['relationship']
            mobile_number = serializer.validated_data['mobile_number']
            remark = serializer.validated_data['remark']
            created_by = serializer.validated_data['created_by']

            # Check if the combination of student_id and AuthorisedPickup contact details already exists
            if AuthorisedPickup.objects.filter(student_id=student_id, name=name, relationship=relationship,
                                               mobile_number=mobile_number, is_active=True).exists():
                return Response({'message': 'This AuthorisedPickup Contact has already been added.'},
                                status=status.HTTP_400_BAD_REQUEST)

            # Add AuthorisedPickup

            AuthorisedPickup_Details_instance = AuthorisedPickup(
                student_id=student_id,
                name=name,
                relationship=relationship,
                mobile_number=mobile_number,
                remark=remark,
                created_by=created_by,
                updated_by=created_by

            )

            # save data into DB

            AuthorisedPickup_Details_instance.save()

            # Prepare the response data
            response_data = {
                'message': 'Added Successfully!',
                'data': {
                    'id': AuthorisedPickup_Details_instance.id,
                    'name': AuthorisedPickup_Details_instance.name,
                    'relationship': AuthorisedPickup_Details_instance.relationship,
                    'mobile_number': AuthorisedPickup_Details_instance.mobile_number,
                    'remark': AuthorisedPickup_Details_instance.remark

                }
            }

            return Response(response_data, status=status.HTTP_201_CREATED)

        except ValidationError as e:

            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='AuthorisedPickupAdd',

            message=error_message,

        )


class GetAllAuthorisedPickupDetailsByStudent(ListAPIView):
    serializer_class = AuthorisedPickupSerializer

    def get_queryset(self):
        student_id = self.kwargs.get('student_id')
        return AuthorisedPickup.objects.filter(student=student_id)

    def list(self, request, *args, **kwargs):

        try:
            # Get the serialized response data
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            # prepare data from response
            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:
                        student_id = item.get('student')

                        student_instance = StudentRegistration.objects.get(id=student_id)

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'student_id': student_instance.id,
                            'student_name': student_instance.first_name,
                            'name': item.get('name'),
                            'relationship': item.get('relationship'),
                            'mobile_number': item.get('mobile_number'),
                            'remark': item.get('remark'),

                        })

                    else:
                        continue

                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)



        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='GetAllAuthorisedPickupStudentlist',
            message=error_message,
        )


class AuthorisedPickupUpdateView(UpdateAPIView):
    queryset = AuthorisedPickup.objects.all()
    serializer_class = AuthorisedPickupUpdateSerializer

    def update(self, request, *args, **kwargs):
        try:
            partial = kwargs.pop('partial', False)
            instance = self.get_object()
            # Validate input data
            serializer = self.get_serializer(instance, data=request.data, partial=partial)
            serializer.is_valid(raise_exception=True)

            # Access serializer data
            student_id = serializer.validated_data.get('student_id')
            name = serializer.validated_data.get('name')
            relationship = serializer.validated_data.get('relationship')
            mobile_number = serializer.validated_data.get('mobile_number')
            remark = serializer.validated_data.get('remark')
            updated_by = serializer.validated_data.get('updated_by')

            # Check if the data matches the existing instance
            if (instance.student_id == student_id and
                    instance.name == name and
                    instance.relationship == relationship and
                    instance.mobile_number == mobile_number and
                    instance.remark == remark):
                return Response({'message': 'No changes identified'}, status=status.HTTP_200_OK)

            # Check if the new record already exists
            if AuthorisedPickup.objects.exclude(pk=instance.pk).filter(student_id=student_id,
                                                                       name=name, relationship=relationship,
                                                                       mobile_number=mobile_number,
                                                                       is_active=True).exists():
                return Response({'message': f"This AuthorisedPickup Data already exists."},
                                status=status.HTTP_400_BAD_REQUEST)

            # Update instance with new data
            instance.student_id = student_id
            instance.name = name
            instance.relationship = relationship
            instance.mobile_number = mobile_number
            instance.remark = remark
            instance.updated_by = updated_by

            instance.save()

            return Response({'message': 'AuthorisedPickup Data updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except Exception as e:

            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='AuthorisedPickupupdate',
            message=error_message,
        )


class AuthorisedPickupDeleteView(DestroyAPIView):
    queryset = AuthorisedPickup.objects.all()
    serializer_class = AuthorisedPickupSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance.is_active:
                instance.is_active = False
                instance.save()
                return Response({'message': f'  AuthorisedPickup data deactivated successfully !!.'},
                                status=status.HTTP_200_OK)
            else:
                return Response({'message': f'  AuthorisedPickup data already deactivated successfully !!.'},
                                status=status.HTTP_200_OK)
        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)


class StudentDocumentCreateView(CreateAPIView):
    queryset = StudentDocument.objects.all()
    serializer_class = StudentDocumentSerializer
    parser_classes = (MultiPartParser, FormParser)

    @transaction.atomic
    def create(self, request, *args, **kwargs):
        try:
            with transaction.atomic():
                serializer = self.get_serializer(data=request.data)
                serializer.is_valid(raise_exception=True)

                student_id = serializer.validated_data['student_id']
                document_no = serializer.validated_data['document_no']
                document_type = serializer.validated_data['document_type']
                document_pic = serializer.validated_data.get('document_pic')
                start_from = serializer.validated_data.get('start_from')
                end_to = serializer.validated_data.get('end_to')
                created_by = serializer.validated_data.get('created_by')

                if StudentDocument.objects.filter(student_id=student_id, document_type=document_type,
                                                  is_active=True).exists():
                    raise ValidationError("This StudentDocument has already been added.")

                StudentDocument_instance = StudentDocument(
                    student_id=student_id,
                    document_no=document_no,
                    document_type=document_type,
                    document_pic=document_pic,
                    start_from=start_from,
                    end_to=end_to,
                    created_by=created_by,
                    updated_by=created_by
                )

                StudentDocument_instance.save()

                response_data = {
                    'message': 'Added Successfully!',
                    'data': {
                        'id': StudentDocument_instance.id,
                        'document_no': StudentDocument_instance.document_no,
                        'document_type': StudentDocument_instance.document_type,
                        'document_pic': StudentDocument_instance.document_pic.url if StudentDocument_instance.document_pic else None,
                        'start_from': StudentDocument_instance.start_from,
                        'end_to': StudentDocument_instance.end_to,
                        'is_active': StudentDocument_instance.is_active,
                        'created_at': StudentDocument_instance.created_at,
                        'updated_at': StudentDocument_instance.updated_at
                    }
                }

                return Response(response_data, status=status.HTTP_201_CREATED)

        except ValidationError as e:
            transaction.set_rollback(True)
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            transaction.set_rollback(True)
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            transaction.set_rollback(True)
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='StudentDocumentAdd',
            message=error_message,
        )


class GetAllStudentDocumentDetailsByStudent(ListAPIView):
    serializer_class = StudentDocumentSerializer

    def get_queryset(self):
        student_id = self.kwargs.get('student_id')
        return StudentDocument.objects.filter(student=student_id)

    def list(self, request, *args, **kwargs):
        try:
            # Get the serialized response data
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            # prepare data from response
            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:
                        student_id = item.get('student')

                        student_instance = StudentRegistration.objects.get(id=student_id)

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'student_id': student_instance.id,
                            'student_name': student_instance.first_name,
                            'document_no': item.get('document_no'),
                            'document_type': item.get('document_type'),
                            'document_pic': item.get('document_pic'),
                            'start_from': item.get('start_from'),
                            'end_to': item.get('end_to')

                        })

                    else:
                        continue

                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)


        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='GetAllStudentDocumentlist',
            message=error_message,
        )


class StudentDocumentUpdateView(UpdateAPIView):
    queryset = StudentDocument.objects.all()
    serializer_class = StudentDocumentUpdateSerializer

    @transaction.atomic
    def update(self, request, *args, **kwargs):
        try:
            partial = kwargs.pop('partial', False)
            instance = self.get_object()

            # Validate input data
            serializer = self.get_serializer(instance, data=request.data, partial=partial)
            serializer.is_valid(raise_exception=True)

            # Access serializer data
            student_id = serializer.validated_data.get('student_id')
            document_no = serializer.validated_data.get('document_no')
            document_type = serializer.validated_data.get('document_type')
            document_pic = serializer.validated_data.get('document_pic')
            start_from = serializer.validated_data.get('start_from')
            end_to = serializer.validated_data.get('end_to')
            updated_by = serializer.validated_data.get('updated_by')

            # Check if no changes were made
            if (instance.student_id == student_id and
                    instance.document_no == document_no and
                    instance.document_type == document_type and
                    instance.document_pic == document_pic and
                    instance.start_from == start_from and
                    instance.end_to == end_to):
                return Response({'message': 'No changes identified'}, status=status.HTTP_200_OK)

            # Check if a similar record already exists
            if StudentDocument.objects.exclude(pk=instance.pk).filter(
                    student_id=student_id,
                    document_type=document_type,
                    is_active=True
            ).exists():
                return Response({'message': 'This Document Data already exists.'}, status=status.HTTP_400_BAD_REQUEST)

            # Update instance with new data
            instance.student_id = student_id
            instance.document_no = document_no
            instance.document_type = document_type
            instance.document_pic = document_pic
            instance.start_from = start_from
            instance.end_to = end_to
            instance.updated_by = updated_by

            instance.save()

            return Response({'message': 'Document Data updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            transaction.set_rollback(True)
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            transaction.set_rollback(True)
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            transaction.set_rollback(True)
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='StudentDocumentUpdate',
            message=error_message,
        )


class StudentDocumentDeleteView(DestroyAPIView):
    queryset = StudentDocument.objects.all()
    serializer_class = StudentDocumentSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance.is_active:
                instance.is_active = False
                instance.save()

                # self.perform_destroy(instance)

                return Response({'message': f'  StudentDocument data deactivited successfully !!.'},
                                status=status.HTTP_200_OK)
            else:
                return Response({'message': f'  StudentDocument data already deactivited successfully !!.'},
                                status=status.HTTP_200_OK)
        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)


class StudentPreviousEducationCreateView(CreateAPIView):
    queryset = StudentPreviousEducation.objects.all()
    serializer_class = StudentPreviousEducationSerializer

    @transaction.atomic
    def create(self, request, *args, **kwargs):
        try:
            # Validate and save data within an atomic transaction
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            student_id = serializer.validated_data['student_id']
            name_of_institution = serializer.validated_data['name_of_institution'].upper()
            location = serializer.validated_data['location']
            course_completed = serializer.validated_data['course_completed']
            year_from = serializer.validated_data['year_from']
            year_to = serializer.validated_data['year_to']
            language_of_instruction = serializer.validated_data['language_of_instruction']
            transfer_certificate = serializer.validated_data['transfer_certificate']
            result = serializer.validated_data['result']
            created_by = serializer.validated_data['created_by']

            # Check if the record already exists
            if StudentPreviousEducation.objects.filter(
                    student_id=student_id,
                    name_of_institution=name_of_institution,
                    course_completed=course_completed,
                    is_active=True

            ).exists():
                return Response({'message': 'This data already been added'}, status=status.HTTP_400_BAD_REQUEST)

            # Create and save a new StudentPreviousEducation instance
            StudentPreviousEducation_instance = StudentPreviousEducation(
                student_id=student_id,
                name_of_institution=name_of_institution,
                location=location,
                course_completed=course_completed,
                year_from=year_from,
                year_to=year_to,
                language_of_instruction=language_of_instruction,
                transfer_certificate=transfer_certificate,
                result=result,
                created_by=created_by,
                updated_by=created_by
            )

            StudentPreviousEducation_instance.save()

            # Prepare the response data
            response_data = {
                'message': 'Added Successfully!',
                'data': {
                    'id': StudentPreviousEducation_instance.id,
                    'name_of_institution': StudentPreviousEducation_instance.name_of_institution,
                    'location': StudentPreviousEducation_instance.location,
                    'course_completed': StudentPreviousEducation_instance.course_completed,
                    'year_from': StudentPreviousEducation_instance.year_from,
                    'year_to': StudentPreviousEducation_instance.year_to,
                    'language_of_instruction': StudentPreviousEducation_instance.language_of_instruction,
                    'transfer_certificate': StudentPreviousEducation_instance.transfer_certificate,
                    'result': StudentPreviousEducation_instance.result,
                    'is_active': StudentPreviousEducation_instance.is_active,
                    'created_at': StudentPreviousEducation_instance.created_at,
                    'updated_at': StudentPreviousEducation_instance.updated_at
                }
            }

            return Response(response_data, status=status.HTTP_201_CREATED)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='Previous_EducationAdd',
            message=error_message,
        )


class GetAllStudentPreviousEducationDetailsByStudent(ListAPIView):
    serializer_class = StudentPreviousEducationSerializer

    def get_queryset(self):
        student_id = self.kwargs.get('student_id')

        return StudentPreviousEducation.objects.filter(student=student_id)

    def list(self, request, *args, **kwargs):
        try:
            # Get the serialized response data
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:
                        student_id = item.get('student')

                        student_instance = StudentRegistration.objects.get(id=student_id)

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'student_id': student_instance.id,
                            'student_name': student_instance.first_name,
                            'name_of_institution': item.get('name_of_institution'),
                            'location': item.get('location'),
                            'course_completed': item.get('course_completed'),
                            'year_from': item.get('year_from'),
                            'year_to': item.get('year_to'),
                            'language_of_instruction': item.get('language_of_instruction'),
                            'transfer_certificate': item.get('transfer_certificate'),
                            'result': item.get('result')

                        })

                    else:
                        continue

                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='GetAllPrevious_Educationlist',
            message=error_message,
        )


class StudentPreviousEducationUpdateView(UpdateAPIView):
    queryset = StudentPreviousEducation.objects.all()
    serializer_class = StudentPreviousEducationUpdateSerializer

    @transaction.atomic
    def update(self, request, *args, **kwargs):
        try:
            partial = kwargs.pop('partial', False)
            instance = self.get_object()

            # Validate input data
            serializer = self.get_serializer(instance, data=request.data, partial=partial)
            serializer.is_valid(raise_exception=True)

            # Access serializer data
            student_id = serializer.validated_data.get('student_id')
            name_of_institution = serializer.validated_data.get('name_of_institution').upper()
            location = serializer.validated_data.get('location')
            course_completed = serializer.validated_data.get('course_completed')
            year_from = serializer.validated_data.get('year_from')
            year_to = serializer.validated_data.get('year_to')
            language_of_instruction = serializer.validated_data.get('language_of_instruction')
            transfer_certificate = serializer.validated_data.get('transfer_certificate')
            result = serializer.validated_data.get('result')
            updated_by = serializer.validated_data.get('updated_by')

            # Check if no changes were made
            if (instance.student_id == student_id and
                    instance.name_of_institution == name_of_institution and
                    instance.location == location and
                    instance.course_completed == course_completed and
                    instance.year_from == year_from and
                    instance.year_to == year_to and
                    instance.language_of_instruction == language_of_instruction and
                    instance.transfer_certificate == transfer_certificate and
                    instance.result == result):
                return Response({'message': 'No changes identified'}, status=status.HTTP_200_OK)

            # Check if a similar record already exists
            if StudentPreviousEducation.objects.exclude(pk=instance.pk).filter(
                    student_id=student_id,
                    name_of_institution=name_of_institution,
                    course_completed=course_completed,
                    is_active=True
            ).exists():
                return Response({'message': 'This previous Education Data already exists.'},
                                status=status.HTTP_400_BAD_REQUEST)

            # Update instance with new data
            instance.student_id = student_id
            instance.name_of_institution = name_of_institution
            instance.location = location
            instance.course_completed = course_completed
            instance.year_from = year_from
            instance.year_to = year_to
            instance.language_of_instruction = language_of_instruction
            instance.transfer_certificate = transfer_certificate
            instance.result = result
            instance.updated_by = updated_by

            instance.save()

            return Response({'message': 'Record Data updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='Previous_EducationUpdate',
            message=error_message,
        )


class StudentPreviousEducationDeleteView(DestroyAPIView):
    queryset = StudentPreviousEducation.objects.all()
    serializer_class = StudentPreviousEducationSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance.is_active:
                instance.is_active = False
                instance.save()

                return Response({'message': f'  Record deactivated successfully !!.'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': f'  Record already deactivated successfully !!.'},
                                status=status.HTTP_200_OK)
        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)


class OrganizationCreateView(CreateAPIView):
    queryset = Organization.objects.all()
    serializer_class = OrganizationSerializer

    @transaction.atomic
    def create(self, request, *args, **kwargs):
        try:
            # Validate and save data within an atomic transaction
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            organization_code = serializer.validated_data['organization_code'].upper()
            organization_description = serializer.validated_data['organization_description']
            created_by = serializer.validated_data['created_by']

            # Check if the record already exists
            if Organization.objects.filter(
                    Q(organization_code=organization_code) & Q(is_active=True)

            ).exists():
                return Response({'message': 'This organization code already been added'},
                                status=status.HTTP_400_BAD_REQUEST)

            # Create and save a new Organization instance
            Organization_instance = Organization(
                organization_code=organization_code,
                organization_description=organization_description,
                created_by=created_by,
                updated_by=created_by

            )

            Organization_instance.save()

            # Prepare the response data
            response_data = {
                'message': 'Added Successfully!',
                'data': {
                    'id': Organization_instance.id,
                    'organization_code': Organization_instance.organization_code,
                    'organization_description': Organization_instance.organization_description

                }
            }

            return Response(response_data, status=status.HTTP_201_CREATED)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='OrganizationAdd',
            message=error_message,
        )


class OrganizationListView(ListAPIView):
    queryset = Organization.objects.all()
    serializer_class = OrganizationSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            # prepare data from response
            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        # Make Response data
                        data = {
                            'id': item.get('id'),
                            'organization_code': item.get('organization_code'),
                            'organization_description': item.get('organization_description'),

                        }

                        responsedata.append(data)
                    else:
                        continue

                if responsedata:
                    return Response({'message': 'success', 'data': responsedata})
                else:
                    return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='OrganizationList',

            message=error_message,

        )


class OrganizationUpdateView(UpdateAPIView):
    queryset = Organization.objects.all()
    serializer_class = OrganizationUpdateSerializer

    @transaction.atomic
    def update(self, request, *args, **kwargs):
        try:
            partial = kwargs.pop('partial', False)
            instance = self.get_object()

            # Validate input data
            serializer = self.get_serializer(instance, data=request.data, partial=partial)
            serializer.is_valid(raise_exception=True)

            # Access serializer data
            organization_code = serializer.validated_data.get('organization_code').upper()
            organization_description = serializer.validated_data.get('organization_description')
            updated_by = serializer.validated_data.get('updated_by')

            # Check if no changes were made
            if (instance.organization_code == organization_code and
                    instance.organization_description == organization_description):
                return Response({'message': 'No changes identified'}, status=status.HTTP_200_OK)

            # Check if a similar record already exists
            if Organization.objects.exclude(pk=instance.pk).filter(
                    Q(organization_code=organization_code) & Q(is_active=True)
            ).exists():
                return Response({'message': 'This organization already exists.'}, status=status.HTTP_400_BAD_REQUEST)

            # Update instance with new data
            instance.organization_code = organization_code
            instance.organization_description = organization_description
            instance.updated_by = updated_by
            instance.save()

            return Response({'message': 'Record  updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred.' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='OrganizationUpdate',
            message=error_message,
        )


class OrganizationDeleteView(DestroyAPIView):
    queryset = Organization.objects.all()
    serializer_class = OrganizationSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance.is_active:
                instance.is_active = False
                instance.save()

                return Response({'message': f'Organization deleted successfully !!.'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'Organization is already inactive.'}, status=status.HTTP_400_BAD_REQUEST)
        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)


class BatchCreateView(CreateAPIView):
    queryset = Batch.objects.all()
    serializer_class = BatchSerializer

    @transaction.atomic
    def create(self, request, *args, **kwargs):
        try:
            # Validate and save data within an atomic transaction
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            organization = serializer.validated_data['organization']
            batch_code = serializer.validated_data['batch_code'].upper()
            created_by = serializer.validated_data['created_by']

            # Check if the record already exists
            if Batch.objects.filter(
                    organization=organization,
                    batch_code=batch_code,
                    is_active=True
            ).exists():
                return Response({'message': 'This Batch already been added'}, status=status.HTTP_400_BAD_REQUEST)

            # Create and save a new Branches instance
            Batch_instance = Batch(
                organization=organization,
                batch_code=batch_code,
                created_by=created_by,
                updated_by=created_by

            )

            Batch_instance.save()

            # Prepare the response data
            response_data = {
                'message': 'Added Successfully!',
                'data': {
                    'id': Batch_instance.id,
                    'organization': Batch_instance.organization.id,
                    'branch_name': Batch_instance.batch_description

                }
            }

            return Response(response_data, status=status.HTTP_201_CREATED)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='BranchAdd',
            message=error_message,
        )


class BatchListView(ListAPIView):
    queryset = Batch.objects.all()
    serializer_class = BatchSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                # prepare data from response
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:
                        organization = item.get('organization')
                        organization_instance = Organization.objects.get(pk=organization)
                        branch_instance = Branch.objects.get(id=item.get('branch'))
                        # Make Response data
                        data = {
                            'id': item.get('id'),
                            'organization_id': organization_instance.id,
                            'organization_code': organization_instance.organization_code,
                            'organization_description': organization_instance.organization_description,
                            'branch_id': branch_instance.id,
                            'branch_name': branch_instance.branch_name,
                            'batch_id': item.get('id'),
                            'batch_description': item.get('batch_description')
                        }

                        responsedata.append(data)
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='BatchList',

            message=error_message,

        )


class GetAllBatchDetailsByBranch(ListAPIView):
    queryset = Batch.objects.all()
    serializer_class = BatchSerializer

    def list(self, request, *args, **kwargs):
        try:
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')

            filterdata = Batch.objects.filter(is_active=True)

            if organization_id and branch_id is not None:
                filterdata = filterdata.filter(organization=organization_id, branch=branch_id)
            else:
                return Response({'message': 'Organization_id and Branch_id is required !'}, status=status.HTTP_200_OK)

            if filterdata:
                responsedata = []
                for item in filterdata:
                    Organization_instance = Organization.objects.get(id=organization_id)

                    # Prepare the custom response data
                    responsedata.append({
                        'organization_id': Organization_instance.id,
                        'organization_code': Organization_instance.organization_code,
                        'branch_id': item.branch.id,
                        'branch_name': item.branch.branch_name,
                        'batch_id': item.id,
                        'batch_code': item.batch_code,
                        'batch_description': item.batch_description,
                        'date_from': item.date_from,
                        'date_to': item.date_to,
                        'is_active': item.is_active
                    })
                if responsedata:

                    return Response(responsedata, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='GetAllBatchDetailsByBranch',
            message=error_message,
        )


class GetBatchDetailBy(ListAPIView):
    queryset = Batch.objects.all()
    serializer_class = BatchSerializer

    def list(self, request, *args, **kwargs):
        try:
            batch_id = request.query_params.get('batch_id')

            filterdata = Batch.objects.filter(is_active=True)

            if batch_id:
                filterdata = filterdata.filter(id=batch_id)
            else:
                filterdata = []

            if filterdata:
                responsedata = []
                for item in filterdata:
                    # Organization_instance = Organization.objects.get(id=batch_id)

                    # Prepare the custom response data
                    responsedata.append({
                        'id': item.id,
                        'organization_id': item.organization.id,
                        'organization_code': item.organization.organization_code,
                        'batch_code': item.batch_code,
                        'batch_description': item.batch_description,
                        'date_from': item.date_from,
                        'date_to': item.date_to,
                        'is_active': item.is_active

                    })
                if responsedata:

                    return Response(responsedata, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='GetAllBatchDetailsByOrganization',
            message=error_message,
        )


class BranchCreateView(CreateAPIView):
    queryset = Branch.objects.all()
    serializer_class = BranchSerializer

    @transaction.atomic
    def create(self, request, *args, **kwargs):
        try:
            # Validate and save data within an atomic transaction
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            organization_id = serializer.validated_data['organization']
            branch_name = serializer.validated_data['branch_name'].upper()
            created_by = serializer.validated_data['created_by']

            # Check if the record already exists
            if Branch.objects.filter(
                    organization_id=organization_id,
                    branch_name=branch_name,
                    is_active=True
            ).exists():
                return Response({'message': 'This Branch already been added'}, status=status.HTTP_400_BAD_REQUEST)

            # Create and save a new Branches instance
            Branch_instance = Branch(
                organization_id=organization_id,
                branch_name=branch_name,
                created_by=created_by,
                updated_by=created_by
            )

            Branch_instance.save()

            # Prepare the response data
            response_data = {
                'message': 'Added Successfully!',
                'data': {
                    'id': Branch_instance.id,
                    'organization_id': Branch_instance.organization.id,
                    'branch_name': Branch_instance.branch_name

                }
            }

            return Response(response_data, status=status.HTTP_201_CREATED)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='BranchAdd',
            message=error_message,
        )


class BranchListView(ListAPIView):
    queryset = Branch.objects.all()
    serializer_class = BranchSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                # prepare data from response
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:
                        organization_id = item.get('organization')
                        organization_instance = Organization.objects.get(pk=organization_id)

                        # Make Response data
                        data = {
                            'id': item.get('id'),
                            'organization_id': organization_instance.id,
                            'organization_code': organization_instance.organization_code,
                            'organization_description': organization_instance.organization_description,
                            'branch_id': item.get('id'),
                            'branch_name': item.get('branch_name')
                        }

                        responsedata.append(data)
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='OrganizationBranchList',

            message=error_message,

        )


class GetAllBranchDetailsByOrganization(ListAPIView):
    queryset = Branch.objects.all()
    serializer_class = BranchSerializer

    # def get_queryset(self):
    #     organization_id = self.kwargs.get('organization_id')
    #     return Branch.objects.filter(organization=organization_id)

    def list(self, request, *args, **kwargs):
        try:
            # Get the serialized response data
            # response = super().list(request, *args, **kwargs)
            # resdata = response.data
            organization_id = request.query_params.get('organization_id')

            resdata = Branch.objects.filter(organization=organization_id, is_active=True)

            if resdata:
                # Prepare the custom response data
                responsedata = []
                for item in resdata:
                    # if item.get('is_active') == True:

                    # organization_id = item.get('organization')

                    Organization_instance = Organization.objects.get(id=organization_id)

                    # Prepare the custom response data
                    responsedata.append({
                        'organization_id': Organization_instance.id,
                        'organization_code': Organization_instance.organization_code,
                        'organization_description': Organization_instance.organization_description,
                        'branch_id': item.id,
                        'branch_name': item.branch_name

                    })

                if responsedata:

                    return Response(responsedata, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='GetAllOrganizationBranchList',
            message=error_message,
        )


class BranchUpdateView(UpdateAPIView):
    queryset = Branch.objects.all()
    serializer_class = BranchUpdateSerializer

    @transaction.atomic
    def update(self, request, *args, **kwargs):
        try:
            partial = kwargs.pop('partial', False)
            instance = self.get_object()

            # Validate input data
            serializer = self.get_serializer(instance, data=request.data, partial=partial)
            serializer.is_valid(raise_exception=True)

            # Access serializer data
            organization_id = serializer.validated_data.get('organization_id')
            branch_name = serializer.validated_data.get('branch_name').upper()
            updated_by = serializer.validated_data.get('updated_by')

            # Check if no changes were made
            if (instance.organization_id == organization_id and
                    instance.branch_name == branch_name
            ):
                return Response({'message': 'No changes identified'}, status=status.HTTP_200_OK)

            # Check if a similar record already exists
            if Branch.objects.exclude(pk=instance.pk).filter(

                    organization_id=organization_id,
                    branch_name=branch_name,
                    is_active=True

            ).exists():
                return Response({'message': 'This Branch already exists.'}, status=status.HTTP_400_BAD_REQUEST)

            # Update instance with new data
            instance.organization_id = organization_id
            instance.branch_name = branch_name
            instance.updated_by = updated_by
            instance.save()

            return Response({'message': 'Record  updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred.' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='OrganizationBranchUpdate',
            message=error_message,
        )


class BranchDeleteView(DestroyAPIView):
    queryset = Branch.objects.all()
    serializer_class = BranchSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance.is_active:
                instance.is_active = False
                instance.save()

                return Response({'message': f'  Branch deleted successfully !!.'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'Branch is already inactive.'}, status=status.HTTP_400_BAD_REQUEST)

        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)


class ProcessFeeGroupMixin:
    def process_fee_group(self, fee_group, student_instance):
        try:
            # Start a new atomic transaction for the fee group processing
            with transaction.atomic():
                # print(fee_group,type(fee_group))
                # print(student_instance, type(student_instance))
                # Process fee group logic here
                fee_group_id = fee_group.id
                # print(fee_group_id)

                # Get fee_Structure_Details record
                fee_structure_details_instance = FeeStructureDetail.objects.filter(FeeStructureMaster=fee_group_id)
                # print(fee_structure_details_instance)
                try:
                    if not fee_structure_details_instance.exists():
                        # raise ValueError("No fee structure details found for the provided fee group.")
                        return Response({'message': 'No fee structure details found for the provided fee group'})

                    # Process fee structure details
                    for details in fee_structure_details_instance:
                        try:
                            element_frequency_id = details.element_frequency.id
                            # print(element_frequency_id)

                            # Get frequency Instance
                            frequency_instance = FeeFrequency.objects.get(id=element_frequency_id)
                            # print(frequency_instance)

                            # Get frequency period
                            frequency_period = frequency_instance.frequency_period

                            if frequency_period > 0:
                                for item in range(frequency_period):

                                    if item == 0:
                                        period_month = details.period_1
                                    elif item == 1:
                                        period_month = details.period_2
                                    elif item == 2:
                                        period_month = details.period_3
                                    elif item == 3:
                                        period_month = details.period_4

                                    elif item == 4:
                                        period_month = details.period_5

                                    elif item == 5:
                                        period_month = details.period_6

                                    # Try creating the student fee details record
                                    student_fee_details_instance = StudentFeeDetail.objects.create(
                                        student=student_instance,
                                        fee_group=fee_group,
                                        fee_structure_details=details,
                                        element_name=details.element_frequency.element_name,
                                        period_month=period_month,
                                        paid='N',
                                        academic_year=student_instance.academic_year,
                                        organization=fee_group.organization,
                                        branch=fee_group.branch,
                                        multiplying_factor=1,
                                        element_amount=details.amount,
                                        total_element_period_amount=details.amount,
                                        paid_amount=0,
                                        created_by=student_instance.created_by,
                                        updated_by=student_instance.created_by
                                    )
                            else:
                                period_instance = Period.objects.all().order_by('sorting_order')
                                # period_times = len(period_instance)

                                # for item in range(period_times):
                                # period_month= period_instance.period_name
                                for period in period_instance:
                                    period_month = period.period_name

                                    # Try creating the student fee details record
                                    student_fee_details_instance = StudentFeeDetail.objects.create(
                                        student=student_instance,
                                        fee_group=fee_group,
                                        fee_structure_details=details,
                                        element_name=details.element_type.element_name,
                                        fee_applied_from=period,
                                        period=period,
                                        paid='N',
                                        academic_year=student_instance.academic_year,
                                        organization=fee_group.organization,
                                        department=fee_group.department,
                                        multiplying_factor=1,
                                        element_amount=details.amount,
                                        total_element_period_amount=details.amount,
                                        paid_amount=0,
                                        created_by=student_instance.created_by,
                                        updated_by=student_instance.created_by
                                    )
                        except Exception as e:
                            # print(f"Skipping fee detail due to error: {e}")
                            continue

                except Exception as e:
                    # Log critical failure in fee processing but don't fail registration
                    print(f"Fee processing failed: {e}")
                    pass

                return {'success': "Fee details processed successfully."}

        except Exception as e:
            print(f"Ignored error processing fee group: {str(e)}")
            # Do not raise exception, allow registration to complete without fees if needed
            return {'success': "Fee processing completed with ignored errors."}

    def ProcessFeeTransport_month(self, route_id, list_of_month, student_instance):
        try:
            # Get route Instance
            route_instance = RouteDetail.objects.get(id=route_id)

            # Get Route Master ID
            route_master_id = route_instance.route_master.id

            # Get PickUp Point ID
            pickup_point_id = route_instance.pickup_point.id

            # Get pickup Instance
            pickup_point_instance = PickupPoint.objects.get(id=pickup_point_id)

            # GEt route master ID
            route_master_instance = RouteMaster.objects.get(id=route_master_id)

            # Insert data into database according month selected
            for item in list_of_month:
                student_fee_details_instance = StudentFeeDetail.objects.create(
                    student=student_instance,
                    # fee_structure_id="",
                    # fee_structure_details_id=details.id,
                    element_name='Transport Fees',  # route_master_instance.transport_name,  # need to store
                    period_month=item,
                    paid='N',
                    academic_year_id=student_instance.academic_year,
                    org_id=pickup_point_instance.organization,
                    # branch_id=pickup_point_instance.branch_id,
                    multiplying_factor=1,
                    element_amount=pickup_point_instance.amount,
                    total_element_period_amount=pickup_point_instance.amount,
                    paid_amount=0,
                    created_by=student_instance.created_by,
                    updated_by=student_instance.created_by
                )


        except Exception as e:
            error_message = f"Error processing fee group: {str(e)}"
            # Raise an exception to be caught in the create method
            raise ValueError(error_message)

    def process_ADHOC_fee(self, student_ids_list, feeElement_ids_list, period_ids_list, created_by):
        try:
            with transaction.atomic():
                # print(student_ids_list,feeElement_ids_list,period_ids_list,created_by)

                # Iterate over each student
                for stu in student_ids_list:
                    # print(stu)
                    # Get the student registration instance
                    try:
                        studentcourseinstance = StudentCourse.objects.get(student=stu, is_active=True)
                        # print(studentcourseinstance)
                    except ObjectDoesNotExist:
                        return Response({'message': 'Student Class Details Not Found'},
                                        status=status.HTTP_404_NOT_FOUND)
                    try:
                        academicyearInstance = AcademicYear.objects.get(id=studentcourseinstance.academic_year.id,
                                                                        is_active=True)
                    except ObjectDoesNotExist:
                        return Response({'message': 'Academic year Details Not Found'},
                                        status=status.HTTP_404_NOT_FOUND)
                    # Iterate periods
                    for prd in period_ids_list:
                        # print(prd)
                        # Get periods Instance
                        try:
                            semesterInstance = Semester.objects.get(id=prd, is_active=True)
                            # print(semesterInstance)
                        except ObjectDoesNotExist:
                            return Response({'message': 'Semester record Not Found'}, status=status.HTTP_404_NOT_FOUND)

                        for element in feeElement_ids_list:
                            element_id = element.get('element_id')
                            # print(element_id)
                            # print(type(element_id))
                            # print(f'{element_id} and type is {type(element_id)}')
                            # Get Fee Element Type
                            feeElementInstance = FeeElementType.objects.get(id=element_id, is_active=True)

                            # print(feeElementInstance.element_name)

                            # print(feeElementInstance)
                            # Create the Student Fee Details record
                            StudentFeeDetail.objects.create(
                                student=studentcourseinstance.student,
                                student_course=studentcourseinstance,
                                element_name=feeElementInstance.element_name,
                                fee_group=None,
                                fee_structure_details=None,
                                fee_applied_from=semesterInstance,
                                semester=semesterInstance,
                                paid='N',
                                academic_year=semesterInstance.academic_year,
                                organization=studentcourseinstance.organization,
                                branch=studentcourseinstance.branch,
                                department=studentcourseinstance.department,
                                multiplying_factor=1,
                                element_amount=element['amount'],
                                total_element_period_amount=element['amount'],
                                paid_amount=0,
                                remarks=element['remarks'],
                                created_by=created_by,
                                updated_by=created_by
                            )

                return {'success': "ADOCH FEES processed successfully."}

                # for stu in student_ids_list:
                #     #print(stu)
                #     # Get the student registration instance
                #     registerstudentinstance = REGISTRATIONBYSTUDENT.objects.get(id=stu,is_active=True)
                #     #academic year instance
                #     academicyearInstance=Academic_Session_Year.objects.get(id=registerstudentinstance.academic_year_id)
                #     # Iterate periods
                #     for prd in period_ids_list:
                #         # Get periods Instance
                #         periodInstance = Periods.objects.get(id=prd)
                #
                #         for element in feeElement_ids_list:
                #
                #             element_id = element.get('element_id')
                #             # print(element_id)
                #             # print(type(element_id))
                #             # print(f'{element_id} and type is {type(element_id)}')
                #             # Get Fee Element Type
                #             feeElementInstance = fee_element_type.objects.get(id=element_id)
                #
                #             #print(feeElementInstance)
                #             # Create the Student Fee Details record
                #             Student_Fee_Details.objects.create(
                #                 student_id=registerstudentinstance,
                #                 element_name=feeElementInstance.element_name,
                #                 period_month=periodInstance.period_name,
                #                 paid='N',
                #                 academic_year_id=academicyearInstance,
                #                 org_id=feeElementInstance.org_id,
                #                 branch_id=feeElementInstance.branch_id,
                #                 multiplying_factor=1,
                #                 element_amount=element['amount'],
                #                 total_element_period_amount=element['amount'],
                #                 paid_amount=0,
                #                 remarks=element['remarks'],
                #                 created_by= created_by,
                #                 updated_by= created_by
                #             )

            # return {'success': "ADOCH FEES processed successfully."}

        except Exception as e:
            error_message = f"Error processing fee group: {str(e)}"
            # Raise an exception to be caught in the create method
            raise ValueError(error_message)


class STUDENTREGISTRATIONCreateView(ProcessFeeGroupMixin, CreateAPIView):
    queryset = StudentRegistration.objects.all()
    serializer_class = StudentRegistrationSerializer

    @transaction.atomic
    def create(self, request, *args, **kwargs):
        try:
            # Start a new atomic transaction
            with transaction.atomic():
                # Validate and save data within the atomic transaction
                serializer = self.get_serializer(data=request.data)
                serializer.is_valid(raise_exception=True)
                # print(serializer)

                # Get Input data
                # first_name = serializer.validated_data.get('first_name')
                fee_group = serializer.validated_data.get('fee_group')
                registration_no = serializer.validated_data.get('registration_no')
                barcode = serializer.validated_data.get('barcode')
                college_admission_no = serializer.validated_data.get('college_admission_no')
                username = serializer.validated_data.get('username')
                email = serializer.validated_data.get('email')
                studentaadharno = serializer.validated_data.get('studentaadharno')

                enrollment_no = serializer.validated_data['enrollment_no']
                primary_guardian = serializer.validated_data['primary_guardian']
                student_status = serializer.validated_data['student_status']

                transport_availed = serializer.validated_data.get('transport_availed')
                list_of_periods = serializer.validated_data.get('choice_month')
                route_id = serializer.validated_data.get('route_id')

                serializer.validated_data['is_active'] = True

                # Initialize first_period to None
                first_period = None

                # If transport availed is True
                if transport_availed:
                    # Check if the incoming list_of_periods is a string, split into list
                    if isinstance(list_of_periods, str):
                        list_of_periods = list_of_periods.split(',')

                    # Fetch sorted periods from the Period model based on sorting_order
                    sorted_periods = Period.objects.filter(is_active=True).order_by('sorting_order')

                    # Create a dictionary with period names and their sorting order for fast lookup
                    period_order_mapping = {period.period_name: period.sorting_order for period in sorted_periods}

                    # Sort incoming list_of_periods based on their sorting order
                    sorted_list_of_periods = sorted(
                        list_of_periods,
                        key=lambda period: period_order_mapping.get(period.strip(), float('inf'))
                        # Inf if period not found
                    )
                    # Get first element for store on class student database
                    first_period = sorted_list_of_periods[0]

                    # # Use sorted_list_of_periods for further processing
                    # print(f'Sorted Period: {sorted_list_of_periods}')

                # Handle studentaadharno & email & registration_no
                if registration_no == '':
                    registration_no = None
                    serializer.validated_data['registration_no'] = registration_no

                if studentaadharno == '':
                    studentaadharno = None
                    serializer.validated_data['studentaadharno'] = studentaadharno

                if email == '':
                    email = None
                    serializer.validated_data['email'] = email

                if primary_guardian == '':
                    primary_guardian = "FATHER"
                    serializer.validated_data['primary_guardian'] = primary_guardian

                if student_status == '':
                    student_status = "ACTIVE"
                    serializer.validated_data['student_status'] = student_status

                # if not registration_no:
                #     serializer.validated_data['registration_no'] = None
                # if not studentaadharno:
                #     serializer.validated_data['studentaadharno'] = None
                # if not email:
                #     serializer.validated_data['email'] = None

                # admission_no generate automatically

                last_student = StudentRegistration.objects.order_by('admission_no').last()
                admission_no = (last_student.admission_no + 1) if last_student else 1001
                serializer.validated_data['admission_no'] = admission_no

                # Set barcode and college_admission_no if not provided
                if not barcode:
                    barcode = admission_no
                serializer.validated_data['barcode'] = barcode

                if not college_admission_no:
                    serializer.validated_data['college_admission_no'] = admission_no

                if not username:
                    if not college_admission_no:
                        serializer.validated_data['username'] = admission_no
                    else:
                        serializer.validated_data['username'] = college_admission_no

                # Set barcode and college_admission_no if not provided
                # serializer.validated_data['barcode'] = barcode or admission_no
                # serializer.validated_data['college_admission_no'] = college_admission_no or admission_no
                # serializer.validated_data['username'] = username or college_admission_no or admission_no

                # Save the student record with the generated or provided admission_no
                # self.perform_create(serializer)
                student_instance = StudentRegistration.objects.create(
                    academic_year=serializer.validated_data['academic_year'],
                    admission_no=serializer.validated_data['admission_no'],
                    first_name=serializer.validated_data['first_name'],
                    middle_name=serializer.validated_data['middle_name'],
                    last_name=serializer.validated_data['last_name'],
                    course=serializer.validated_data['course'],
                    section=serializer.validated_data['section'],
                    gender=serializer.validated_data['gender'],
                    date_of_admission=serializer.validated_data['date_of_admission'],
                    doj=serializer.validated_data['doj'],
                    barcode=serializer.validated_data['barcode'],
                    registration_no=serializer.validated_data['registration_no'],
                    fee_group=serializer.validated_data['fee_group'],
                    fee_applied_from=serializer.validated_data['fee_applied_from'],
                    college_admission_no=serializer.validated_data['college_admission_no'],
                    cbse_reg_no=serializer.validated_data['cbse_reg_no'],
                    # enrollment_no=enrollment_no,
                    enrollment_no=int(StudentRegistration.objects.last().enrollment_no) + 1,
                    primary_guardian=serializer.validated_data.get('primary_guardian'),
                    student_status=serializer.validated_data.get('student_status', 'ACTIVE'),
                    house=serializer.validated_data['house'],
                    religion=serializer.validated_data['religion'],
                    category=serializer.validated_data['category'],
                    nativelanguage=serializer.validated_data['nativelanguage'],
                    bloodgroup=serializer.validated_data['bloodgroup'],
                    nationality=serializer.validated_data['nationality'],
                    email=serializer.validated_data['email'],
                    dob=serializer.validated_data['dob'],
                    childreninfamily=serializer.validated_data['childreninfamily'],
                    studentaadharno=serializer.validated_data['studentaadharno'],
                    username=serializer.validated_data['username'],
                    remarks=serializer.validated_data['remarks'],
                    profile_pic=serializer.validated_data['profile_pic'],

                    father_name=serializer.validated_data['father_name'],
                    father_profession=serializer.validated_data['father_profession'],
                    father_contact_number=serializer.validated_data['father_contact_number'],
                    father_email=serializer.validated_data['father_email'],
                    father_aadharno=serializer.validated_data['father_aadharno'],
                    mother_name=serializer.validated_data['mother_name'],
                    mother_profession=serializer.validated_data['mother_profession'],
                    mother_contact_number=serializer.validated_data['mother_contact_number'],
                    mother_email=serializer.validated_data['mother_email'],
                    mother_aadharno=serializer.validated_data['mother_aadharno'],
                    created_by=serializer.validated_data['created_by'],
                    updated_by=serializer.validated_data['created_by']

                )
                # student_instance = serializer.instance

                # Call the reusable method for processing fee_group
                self.process_fee_group(fee_group, student_instance)

                # Call the reusable method for processing transport
                if transport_availed == True:
                    self.ProcessFeeTransport_month(route_id, sorted_list_of_periods, student_instance)

                # Handle parent_id generation and save parent record
                last_parent = Parent.objects.order_by('parent_id').last()
                parent_id = (last_parent.parent_id + 1) if last_parent else 101

                # Create the parent entry linked to the student
                Parent.objects.create(
                    parent_id=parent_id,
                    student=student_instance
                )

                # Create the student class entry linked to the student
                StudentCourse.objects.create(
                    academic_year=student_instance.academic_year,
                    student_id=student_instance,
                    course=student_instance.course,
                    section=student_instance.section,
                    fee_group=student_instance.fee_group.id,
                    fee_applied_from=student_instance.fee_applied_from.id,
                    enrollment_no=enrollment_no,
                    house=student_instance.house,
                    transport_availed=transport_availed,
                    route_id=route_id,
                    choice_month=first_period,
                    created_by=student_instance.created_by,
                    updated_by=student_instance.created_by

                )

                # Create the student class entry linked to the student

                user_login = UserLogin.objects.create(
                    username=student_instance.username,
                    password=student_instance.first_name,
                    plain_password=student_instance.first_name,
                    reference_id=student_instance.id
                )

                # Hash the password and save the user login instance
                user_login.set_password(student_instance.first_name)
                user_login.save()

                # If everything is successful, return the response
                # Add the student_id to the response
                response_data = serializer.data
                response_data['student_id'] = student_instance.id

                # Get the absolute URL of the profile picture if it exists
                if student_instance.profile_pic:
                    response_data['profile_pic'] = request.build_absolute_uri(student_instance.profile_pic.url)
                else:
                    response_data['profile_pic'] = None  # or handle accordingly
            return Response(response_data, status=status.HTTP_201_CREATED)

        except ValidationError as e:
            # Rollback the transaction on validation error
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            # Rollback the transaction on database error
            # self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            # Rollback the transaction on any other exception
            # self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='StudentRegistrationAdd',
            message=error_message,
        )


class STUDENTREGISTRATIONListAPIVIew(ListAPIView):
    queryset = StudentRegistration.objects.all()
    serializer_class = StudentRegistrationSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                # prepare data from response
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        # Get Data
                        academic_year = item.get('academic_year')
                        course = item.get('course')
                        section = item.get('section')

                        academic_year_instance = AcademicYear.objects.get(pk=academic_year)

                        course_instance = Course.objects.get(pk=course)

                        section_instance = Section.objects.get(pk=section)

                        # Make Response data
                        data = {
                            'id': item.get('id'),
                            'academic_year_id': academic_year_instance.id,
                            'academicyear': f'{academic_year_instance.Start_Year.year}-{academic_year_instance.End_Year.year}',
                            'admission_no': item.get('admission_no'),
                            'first_name': item.get('first_name'),
                            'middle_name': item.get('middle_name'),
                            'last_name': item.get('last_name'),
                            'course': course_instance.course_name,
                            'section': section_instance.section_name,
                            'gender': item.get('gender'),
                            'date_of_admission': item.get('date_of_admission'),
                            'doj': item.get('doj'),
                            'fee_group': item.get('fee_group'),
                            'fee_applied_from': item.get('fee_applied_from'),
                            'enrollment_no': item.get('enrollment_no'),
                            'barcode': item.get('barcode'),
                            'registration_no': item.get('registration_no'),
                            'college_admission_no': item.get('college_admission_no'),
                            'cbse_reg_no': item.get('cbse_reg_no'),
                            'house': item.get('house'),
                            'religion': item.get('religion'),
                            'category': item.get('category'),
                            'nativelanguage': item.get('nativelanguage'),
                            'bloodgroup': item.get('bloodgroup'),
                            'nationality': item.get('nationality'),
                            'email': item.get('email'),
                            'dob': item.get('dob'),
                            'childreninfamily': item.get('childreninfamily'),
                            'studentaadharno': item.get('studentaadharno'),
                            'username': item.get('username'),
                            'remarks': item.get('remarks'),
                            'profile_pic': item.get('profile_pic'),
                            'father_name': item.get('father_name'),
                            'father_profession': item.get('father_profession'),
                            'father_contact_number': item.get('father_contact_number'),
                            'father_email': item.get('father_email'),
                            'father_aadharno': item.get('father_aadharno'),
                            'mother_name': item.get('mother_name'),
                            'mother_profession': item.get('mother_profession'),
                            'mother_contact_number': item.get('mother_contact_number'),
                            'mother_email': item.get('mother_email'),
                            'mother_aadharno': item.get('mother_aadharno')

                        }

                        responsedata.append(data)
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'success', 'data': responsedata})
                else:
                    return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='registerstudentlist',

            message=error_message,

        )


class STUDENTREGISTRATIONUpdateAPIView(UpdateAPIView):
    queryset = StudentRegistration.objects.all()
    serializer_class = StudentRegistrationSerializer

    @transaction.atomic
    def update(self, request, *args, **kwargs):
        try:
            # Start a new atomic transaction
            partial = kwargs.pop('partial', False)
            instance = self.get_object()

            # Validate and update the data
            serializer = self.get_serializer(instance, data=request.data, partial=partial)
            serializer.is_valid(raise_exception=True)

            admission_no = serializer.validated_data.get('admission_no')
            barcode = serializer.validated_data.get('barcode')
            registration_no = serializer.validated_data.get('registration_no')
            college_admission_no = serializer.validated_data.get('college_admission_no')
            email = serializer.validated_data.get('email')
            studentaadharno = serializer.validated_data.get('studentaadharno')
            username = serializer.validated_data.get('username')

            # Check if the data matches the existing instance
            if all(getattr(instance, key) == value for key, value in serializer.validated_data.items()):
                return Response({'message': 'No changes identified'}, status=status.HTTP_200_OK)

            # Handle studentaadharno & email
            if studentaadharno == '':
                studentaadharno = None
                serializer.validated_data['username'] = studentaadharno

            if email == '':
                email = None
                serializer.validated_data['email'] = email

            if college_admission_no == None:
                studentaadharno = admission_no
                serializer.validated_data['username'] = studentaadharno

            if not username:
                if not college_admission_no:
                    serializer.validated_data['username'] = admission_no
                else:
                    serializer.validated_data['username'] = college_admission_no

            # Check if the admission_no already exists for another user
            if admission_no and StudentRegistration.objects.filter(admission_no=admission_no).exclude(
                    id=instance.id).exists():
                return Response({'error': 'admission_no already exists .'},
                                status=status.HTTP_400_BAD_REQUEST)

            # Check if the barcode already exists for another user
            if barcode and StudentRegistration.objects.filter(barcode=barcode).exclude(
                    id=instance.id).exists():
                return Response({'error': 'barcode already exists .'},
                                status=status.HTTP_400_BAD_REQUEST)
            # Check if the barcode already exists for another user
            if registration_no and StudentRegistration.objects.filter(registration_no=registration_no).exclude(
                    id=instance.id).exists():
                return Response({'error': 'registration_no already exists .'},
                                status=status.HTTP_400_BAD_REQUEST)

            # Check if the college_admission_no already exists for another user
            if college_admission_no and StudentRegistration.objects.filter(
                    college_admission_no=college_admission_no).exclude(
                    id=instance.id).exists():
                return Response({'error': 'college_admission_no already exists .'},
                                status=status.HTTP_400_BAD_REQUEST)

            # Check if the email already exists for another user
            if email and StudentRegistration.objects.filter(email=email).exclude(id=instance.id).exists():
                return Response({'error': 'Email already exists .'},
                                status=status.HTTP_400_BAD_REQUEST)

            # Check if the studentaadharno already exists for another user
            if studentaadharno and StudentRegistration.objects.filter(
                    studentaadharno=studentaadharno).exclude(
                id=instance.id).exists():
                return Response({'error': 'college_admission_no already exists .'},
                                status=status.HTTP_400_BAD_REQUEST)

            # Save the updated student data
            self.perform_update(serializer)
            student_instance = serializer.instance

            # Update the related Parent record
            parent_record = Parent.objects.filter(student=student_instance).first()
            if parent_record:
                # Update the necessary fields in the parent record
                parent_record.parent_id = parent_record.parent_id
                parent_record.save()

            # Update the related StudentCourse record
            student_course_record = StudentCourse.objects.filter(student_id=student_instance).first()
            if student_course_record:
                student_course_record.course = student_instance.course
                student_course_record.semester = student_instance.semester
                student_course_record.section = student_instance.section
                student_course_record.fee_group = student_instance.fee_group
                student_course_record.fee_applied_from = student_instance.fee_applied_from
                student_course_record.enrollment_no = student_instance.enrollment_no
                student_course_record.house = student_instance.house
                student_course_record.updated_by = student_instance.updated_by
                student_course_record.save()

            # Update the related UserLogin record
            user_login_record = UserLogin.objects.filter(user_id=student_instance).first()
            if user_login_record:
                user_login_record.username = student_instance.username
                user_login_record.plain_password = student_instance.first_name  # Update the plain password if needed
                user_login_record.set_password(student_instance.first_name)  # Hash and set the new password
                user_login_record.save()

            # If everything is successful, return the response
            return Response({'message': 'Record  updated successfully.'}, status=status.HTTP_200_OK)

        except ValidationError as e:
            # Rollback the transaction on validation error
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            # Rollback the transaction on database error
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            # Rollback the transaction on any other exception
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='STUDENTREGISTRATIONUpdate',
            message=error_message,
        )


class STUDENTRAGISTRATIONDeleteAPIVIEW(DestroyAPIView):
    queryset = StudentRegistration.objects.all()
    serializer_class = StudentRegistrationSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance.is_active:
                instance.is_active = False
                instance.save()

                return Response({'message': f'  Student deleted successfully !!.'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'Student is already inactive.'}, status=status.HTTP_400_BAD_REQUEST)

        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)


class StudentCourseListAPIView(ListAPIView):
    serializer_class = StudentCourseSerializer

    def get_queryset(self):
        academicyearId = self.kwargs.get('academic_year_id')

        return academicyearId

    def list(self, request, *args, **kwargs):

        try:
            academicyearId = self.get_queryset()
            query_params = request.query_params
            try:
                course_id = query_params.get('course_id')
                course_instance = Course.objects.get(id=course_id)
            except:
                course_id = None
            try:
                section_id = query_params.get('section_id')
                # class_section_instance = CourseSectionBind.objects.get(id=section_id)
                section_instance = Section.objects.get(id=section_id)
            except:
                section_id = None

            try:
                admission_no = query_params.get('admission_no')
                studentRegistrationInstance = StudentRegistration.objects.get(admission_no=admission_no, is_active=True)
            except:
                admission_no = None
            # Step 1: Retrieve all students
            # studentList = StudentRegistration.objects.filter(academic_year=academicyearId)
            if course_id and section_id is not None:
                # student_list = StudentCourse.objects.filter(
                student_list = StudentRegistration.objects.filter(
                    academic_year_id=academicyearId,
                    is_active=True,
                    course=course_instance,
                    section=section_instance).order_by('-updated_at')
            elif course_id is not None:
                # student_list = StudentCourse.objects.filter(
                student_list = StudentRegistration.objects.filter(
                    academic_year_id=academicyearId,
                    is_active=True,
                    course=course_instance).order_by('-updated_at')
            elif query_params.get('studentName'):
                studentName = query_params.get('studentName')
                name_parts = studentName.strip().split()
                if len(name_parts) == 1:
                    first = name_parts[0].strip()
                    student_list = StudentRegistration.objects.filter(
                        Q(first_name__icontains=first) | Q(middle_name__icontains=first) | Q(last_name__icontains=first)
                        , is_active=True
                        )

                elif len(name_parts) == 2:  # First + Last
                    first, last = name_parts
                    student_list = StudentRegistration.objects.filter(
                        Q(first_name__iexact=first, last_name__iexact=last) |
                        Q(first_name__iexact=first, middle_name__isnull=False, last_name__iexact=last)
                        , is_active=True
                    )

                elif len(name_parts) == 3:  # First + Middle + Last
                    first, middle, last = name_parts
                    student_list = StudentRegistration.objects.filter(
                        first_name__iexact=first,
                        middle_name__iexact=middle,
                        last_name__iexact=last,
                        is_active=True
                    )
                # studentNameSplit = studentName.split()
                # student_list = StudentRegistration.objects.filter(first_name__istartswith=studentName,
                #                                                     academic_year_id=academicyearId).order_by('-updated_at')
                # student_list = StudentRegistration.objects.filter(Q(first_name__icontains=studentName) | Q(middle_name__icontains=studentName) | Q(last_name__icontains=studentName))
                # if len(studentNameSplit) == 0:
                #     student_list = StudentRegistration.objects.filter(first_name__istartswith = studentName,academic_year_id=academicyearId).order_by('-updated_at')
                # elif len(studentNameSplit) > 0:
                #     student_list = StudentRegistration.objects.filter(first_name__istartswith = studentName[0],middle_name__istartswith=studentName[1] if len(studentNameSplit) > 1 else '',last_name__istartswith=studentName[2] if len(studentNameSplit) > 2 else '',academic_year_id=academicyearId).order_by('-updated_at')
            elif query_params.get('gender'):
                gender = query_params.get('gender')
                student_list = StudentRegistration.objects.filter(gender=gender, is_active=True).order_by('-updated_at')
            elif query_params.get('admission_no'):
                admission_no = query_params.get('admission_no')
                student_list = StudentRegistration.objects.filter(admission_no=admission_no, is_active=True).order_by(
                    '-updated_at')
            elif query_params.get('from_date') and query_params.get('to_date'):
                from_date = query_params.get('from_date')
                to_date = query_params.get('to_date')
                student_list = StudentRegistration.objects.filter(created_at__range=(from_date, to_date),
                                                                  is_active=True).order_by('-updated_at')
            elif query_params.get('student_status'):
                student_status = query_params.get('student_status')
                student_list = StudentRegistration.objects.filter(student_status=student_status,
                                                                  is_active=True).order_by('-updated_at')
            elif query_params.get('barcode'):
                barcode = query_params.get('barcode')
                student_list = StudentRegistration.objects.filter(barcode=barcode,
                                                                  is_active=True).order_by(
                    '-updated_at')
            elif query_params.get('admissionNo'):
                admissionNo = query_params.get('admissionNo')
                student_list = StudentRegistration.objects.filter(admission_no=admissionNo, is_active=True).order_by(
                    '-updated_at')
            elif query_params.get('fatherName'):
                fatherName = query_params.get('fatherName')
                student_list = StudentRegistration.objects.filter(father_name__icontains=fatherName, is_active=True)

            elif query_params.get('motherName'):
                motherName = query_params.get('motherName')
                student_list = StudentRegistration.objects.filter(mother_name__icontains=motherName, is_active=True)
                # name_parts = fatherName.strip().split()
                # if len(name_parts) == 1:
                #     first = name_parts[0].strip()
                #     student_list = StudentRegistration.objects.filter(father_name__icontains=first)
                #
                # elif len(name_parts) == 2:  # First + Last
                #     first, last = name_parts
                #     student_list = StudentRegistration.objects.filter(
                #         Q(first_name__iexact=first, last_name__iexact=last) |
                #         Q(first_name__iexact=first, middle_name__isnull=False, last_name__iexact=last)
                #     )
                #
                # elif len(name_parts) == 3:  # First + Middle + Last
                #     first, middle, last = name_parts
                #     student_list = StudentRegistration.objects.filter(
                #         first_name__iexact=first,
                #         middle_name__iexact=middle,
                #         last_name__iexact=last
                #     )
            else:
                # First try to filter by academic year
                student_list = StudentCourse.objects.filter(academic_year=academicyearId, is_active=True).order_by(
                    '-updated_at')
                # If no students found with this academic year, return all active students
                # This handles cases where academicSessionId might be "Default" or an incorrect ID
                if not student_list.exists():
                    student_list = StudentCourse.objects.filter(is_active=True).order_by('-updated_at')
            # print(studentList.update_at)
            # if admission_no:

            recordList = []
            for stu in student_list:
                # Handle both StudentRegistration and StudentCourse objects
                if isinstance(stu, StudentCourse):
                    studentId = stu.student_id
                else:
                    studentId = stu.id
                # print('year id: ',stu.academic_year_id,"student_id: ", studentId.id)
                # if studentId.id==68:
                #     print("student_id: ", studentId)

                # Registration Instance
                try:
                    RegistrationInstance = StudentRegistration.objects.get(id=studentId)
                except Exception as e:
                    print(e)
                    RegistrationInstance = None
                if RegistrationInstance is not None:
                    # Step 2: Retrieve related data
                    feeDetails = StudentCourse.objects.filter(student_id=studentId, is_active=True)
                    transportDetails = StudentCourse.objects.filter(student_id=studentId, is_active=True)
                    addressDetails = Address.objects.filter(reference_id=studentId)
                    sibilingsDetails = SiblingDetail.objects.filter(student_id=studentId)
                    studentEmergencyContacts = StudentEmergencyContact.objects.filter(student_id=studentId)
                    authorizedPickups = AuthorisedPickup.objects.filter(student_id=studentId)
                    studentDocuments = StudentDocument.objects.filter(student_id=studentId)
                    previousEducations = StudentPreviousEducation.objects.filter(student_id=studentId)

                    # Manually serialize the feeDetails Data
                    feeDetailslist = []
                    if feeDetails.exists():

                        for item in feeDetails:
                            if item.fee_group == None or item.fee_applied_from == None:
                                continue
                            else:
                                # fee_group and fee_applied_from are ForeignKey fields, use them directly
                                feemasterInstance = item.fee_group
                                periodInstance = item.fee_applied_from

                                feedata = {
                                    'fee_groupId': item.fee_group_id,
                                    'fee_group': feemasterInstance.fee_structure_code,
                                    'fee_applied_fromId': item.fee_applied_from_id,
                                    'month': periodInstance.semester_code if hasattr(periodInstance,
                                                                                     'semester_code') else str(
                                        periodInstance)
                                }

                                feeDetailslist.append(feedata)

                    # Manually serialize the sibilingsDetails data
                    sibilinglist = []
                    if sibilingsDetails.exists():
                        for sibiling in sibilingsDetails:
                            # sibiling.sibling is the ForeignKey field (object), sibiling.sibling_id is the ID
                            studentInstance = sibiling.sibling
                            courseInstance = studentInstance.course
                            sectionInstance = studentInstance.section
                            sibilingsdata = {
                                'sibling_id': sibiling.sibling_id,
                                'sibling_firstname': studentInstance.first_name,
                                'sibling_lastname': studentInstance.last_name,
                                'college_admission_no': studentInstance.college_admission_no,
                                'course_name': courseInstance.course_name,
                                'section_name': sectionInstance.section_name

                            }
                            sibilinglist.append(sibilingsdata)
                    # Fetch class and section details for student
                    # if RegistrationInstance is not None:
                    # stu.course and stu.section are already the objects (ForeignKey fields)
                    courseInstance = stu.course
                    sectionInstance = stu.section

                    # Step 3: Serialize the data using respective serializers
                    student_data = {
                        # **StudentBasicDetailSerializer(RegistrationInstance).data,
                        # 'student_id': RegistrationInstance.id,
                        # 'first_name': RegistrationInstance.first_name,
                        # 'middle_name' : RegistrationInstance.middle_name,
                        # 'last_name' : RegistrationInstance.last_name,
                        # 'course_name' : RegistrationInstance.addmitted_class,
                        # 'section_name' : RegistrationInstance.addmitted_section,
                        'studentBasicDetails': {
                            **StudentBasicDetailSerializer(RegistrationInstance).data,
                            # 'classname': courseInstance.classname,
                            'course_name': RegistrationInstance.course.__dict__['course_name'],
                            # 'sectionname': sectionInstance.sectionname,
                            'section_name': RegistrationInstance.section.__dict__['section_name'],
                            'profile_pic': request.build_absolute_uri(
                                RegistrationInstance.profile_pic.url) if RegistrationInstance.profile_pic else None
                        },
                        'feeDetails': feeDetailslist,  # StudentFeeAppliedDetails(feeDetails).data,
                        'addressDetails': AddressDetailsSerializer(addressDetails, many=True).data,
                        'sibilingsDetails': sibilinglist,
                        # StudentSibilingsDetailsSerializer(sibilingsDetails, many=True).data,
                        'emegencyContact': StudentEmergencyContactDetailsSerializer(studentEmergencyContacts,
                                                                                    many=True).data,
                        'authorizedpickup': AuthorisedPickupDetailsSerializer(authorizedPickups, many=True).data,
                        'documentsDetails': StudentDocumentDetailsSerializer(studentDocuments, many=True).data,
                        'previousEducationDetails': StudentPreviousEducationDetailsSerializer(previousEducations,
                                                                                              many=True).data
                    }

                    recordList.append(student_data)

            # Step 4: Return the serialized response
            return Response({'message': 'Success', 'data': recordList}, status=status.HTTP_200_OK)


        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='RegistrationStudentlist',
            message=error_message,
        )


class STUDENTCLASSListAPIView(ListAPIView):
    queryset = StudentCourse.objects.all()
    serializer_class = StudentCourseSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                # prepare data from response
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        # Get Data
                        student_id = item.get('student_id')
                        course = item.get('course')
                        section = item.get('section')

                        # Get student,class & section instance

                        student_instance = StudentRegistration.objects.get(pk=student_id)
                        course_instance = Course.objects.get(pk=course)
                        section_instance = Section.objects.get(pk=section)

                        # Make Response data
                        data = {
                            'id': item.get('id'),
                            'student_id': student_instance.id,
                            'student_name': f'{student_instance.first_name}',
                            'addmitted_course_id': item.get('course'),
                            'course_name': course_instance.course_name,
                            'section_id': item.get('section'),
                            'section_name': section_instance.section_name,
                            'fee_group': item.get('fee_group'),
                            'fee_applied_from': item.get('fee_applied_from'),
                            'enrollment_no': item.get('enrollment_no'),
                            'house': item.get('house'),

                        }

                        responsedata.append(data)
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'success', 'data': responsedata})
                else:
                    return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='studentclasslist',

            message=error_message,

        )


class STUDENTCLASSUpdateAPIView(UpdateAPIView):
    queryset = StudentCourse.objects.all()
    serializer_class = StudentCourseSerializer

    def update(self, request, *args, **kwargs):
        try:
            partial = kwargs.pop('partial', False)
            instance = self.get_object()

            # Validate input data
            serializer = self.get_serializer(instance, data=request.data, partial=partial)
            serializer.is_valid(raise_exception=True)

            # Access serializer data
            student_id = serializer.validated_data.get('student_id')
            course = serializer.validated_data.get('course')
            section = serializer.validated_data.get('section')
            fee_group = serializer.validated_data.get('fee_group')
            fee_applied_from = serializer.validated_data.get('fee_applied_from')
            enrollment_no = serializer.validated_data.get('enrollment_no')
            house = serializer.validated_data.get('house')
            updated_by = serializer.validated_data.get('updated_by')

            # Check if no changes were made
            if (instance.student_id == student_id and
                    instance.course == course and
                    instance.section == section and
                    instance.fee_group == fee_group and
                    instance.fee_applied_from == fee_applied_from and
                    instance.enrollment_no == enrollment_no and
                    instance.house == house
            ):
                return Response({'message': 'No changes identified'}, status=status.HTTP_200_OK)

            # # Check if a similar record already exists
            # if Branches.objects.exclude(pk=instance.pk).filter(
            #
            #     organization_id=organization_id,
            #     branch_name = branch_name
            #
            # ).exists():
            #     return Response({'message': 'This Branch already exists.'}, status=status.HTTP_400_BAD_REQUEST)

            # Update instance with new data
            instance.course = course
            instance.section = section
            instance.fee_group = fee_group
            instance.fee_applied_from = fee_applied_from
            instance.enrollment_no = enrollment_no
            instance.house = house
            instance.updated_by = updated_by

            instance.save()

            return Response({'message': 'Record  updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='STUDENTCLASSUpdate',
            message=error_message,
        )


class FeeStructureMasterCreateAPIView(CreateAPIView):
    queryset = FeeStructureMaster.objects.all()
    serializer_class = FeeStructureMasterSerializer

    def create(self, request, *args, **kwargs):
        try:
            # Validate and save data
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            # Get validate Data
            fee_structure_code = serializer.validated_data.get('fee_structure_code').upper()
            fee_structure_description = serializer.validated_data.get('fee_structure_description').upper()
            academic_year_id = serializer.validated_data.get('academic_year')
            organization_id = serializer.validated_data.get('organization')
            # branch_id = serializer.validated_data.get('branch_id')
            course_id = serializer.validated_data.get('course')
            enabled = serializer.validated_data.get('enabled')
            version_no = serializer.validated_data.get('version_no')
            category_id = serializer.validated_data.get('category')
            new_existing = serializer.validated_data.get('new_existing').upper()
            created_by = serializer.validated_data.get('created_by')

            # Check this record already exist or not
            if FeeStructureMaster.objects.filter(
                    fee_structure_code=fee_structure_code,
                    fee_structure_description=fee_structure_description,
                    academic_year=academic_year_id,
                    organization=organization_id,
                    # branch_id=branch_id,
                    course=course_id,
                    category=category_id,
                    new_existing=new_existing,
                    is_active=True

            ).exists():
                return Response({'message': 'This fee structure already been added'},
                                status=status.HTTP_400_BAD_REQUEST)

            FeeStructureMaster_instance = FeeStructureMaster.objects.create(
                fee_structure_code=fee_structure_code,
                fee_structure_description=fee_structure_description,
                academic_year=academic_year_id,
                organization=organization_id,
                # branch_id=branch_id,
                course=course_id,
                enabled=enabled,
                category=category_id,
                version_no=version_no,
                new_existing=new_existing,
                created_by=created_by,
                updated_by=created_by
            )

            FeeStructureMaster_instance.save()

            # Prepare the response data
            response_data = {
                'message': 'Added Successfully!',
                'data': {
                    'id': FeeStructureMaster_instance.id,
                    'fee_structure_code': FeeStructureMaster_instance.fee_structure_code,
                    'fee_structure_desc': FeeStructureMaster_instance.fee_structure_description,
                    'academic_year_id': FeeStructureMaster_instance.academic_year.id,
                    'academic_year_code': FeeStructureMaster_instance.academic_year.academic_year_code,
                    'organization': FeeStructureMaster_instance.organization.id,
                    # 'branch_id': FeeStructureMaster_instance.branch_id.id,
                    'course_id': FeeStructureMaster_instance.course.id,
                    'enabled': FeeStructureMaster_instance.enabled,
                    'version_no': FeeStructureMaster_instance.version_no,
                    'category_code': FeeStructureMaster_instance.category.category_code,
                    'new_existing': FeeStructureMaster_instance.new_existing,
                }
            }

            return Response({'message': 'success', 'data': response_data}, status=status.HTTP_200_OK)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='FeeStructureMasterAdd',
            message=error_message,
        )


class FeeStructureDetailsCreateAPIView(CreateAPIView):
    queryset = FeeStructureDetail.objects.all()
    serializer_class = FeeStructureDetailSerializer

    def create(self, request, *args, **kwargs):
        try:
            # Validate and save data
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            # Get validate Data
            fee_structure_master = serializer.validated_data.get('fee_structure_master')
            element_type = serializer.validated_data.get('element_type')
            element_frequency = serializer.validated_data.get('element_frequency')
            amount = serializer.validated_data.get('amount')

            period_1 = serializer.validated_data.get('period_1')
            period_2 = serializer.validated_data.get('period_2')
            period_3 = serializer.validated_data.get('period_3')
            period_4 = serializer.validated_data.get('period_4')
            period_5 = serializer.validated_data.get('period_5')
            period_6 = serializer.validated_data.get('period_6')
            adjustment_flag = serializer.validated_data.get('adjustment_flag')
            created_by = serializer.validated_data.get('created_by')

            # Check this record already exist or not
            if FeeStructureDetail.objects.filter(
                    fee_structure_master=fee_structure_master,
                    element_type=element_type,
                    element_frequency=element_frequency,  # may be exclude this line as per our requirment
                    is_active=True

            ).exists():
                return Response({'message': 'This fee details already been added'},
                                status=status.HTTP_400_BAD_REQUEST)
            # create fee details & save
            fee_structure_details_instance = FeeStructureDetail.objects.create(
                fee_structure_master=fee_structure_master,
                element_type=element_type,
                element_frequency=element_frequency,
                amount=amount,
                period_1=period_1,
                period_2=period_2,
                period_3=period_3,
                period_4=period_4,
                period_5=period_5,
                period_6=period_6,
                adjustment_flag=adjustment_flag,
                created_by=created_by,
                updated_by=created_by
            )

            fee_structure_details_instance.save()

            # Prepare the response data
            response_data = {
                'message': 'Added Successfully!',
                'data': {
                    'id': fee_structure_details_instance.id,
                    'fee_structure_master_id': fee_structure_details_instance.fee_structure_master.id,
                    'fee_structure_master': fee_structure_details_instance.fee_structure_master.fee_structure_description,
                    'element_type_id': fee_structure_details_instance.element_type.id,
                    'element_type_name': fee_structure_details_instance.element_type.element_name,
                    'element_frequency_id': fee_structure_details_instance.element_frequency.id,
                    'element_frequency': fee_structure_details_instance.element_frequency.fee_frequency_name,
                    'amount': fee_structure_details_instance.amount,
                    'period_1': fee_structure_details_instance.period_1,
                    'period_2': fee_structure_details_instance.period_2,
                    'period_3': fee_structure_details_instance.period_3,
                    'period_4': fee_structure_details_instance.period_4,
                    'period_5': fee_structure_details_instance.period_5,
                    'period_6': fee_structure_details_instance.period_6,
                    'adjustment_flag': fee_structure_details_instance.adjustment_flag,

                }
            }

            return Response({'message': 'success', 'data': response_data}, status=status.HTTP_200_OK)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='FeeStructureDetailsAdd',
            message=error_message,
        )


class FeeStructureDetailsListAPIView(ListAPIView):
    serializer_class = FeeStructureDetailSerializer

    def list(self, request, *args, **kwargs):
        try:

            fee_master_id = request.query_params.get('fee_master_id')

            resdata = FeeStructureDetail.objects.filter(fee_structure_master=fee_master_id, is_active=True)

            if resdata:
                # prepare data from response
                responsedata = []
                for item in resdata:
                    # if item.get('is_active') == True:

                    # Get Data
                    fee_structure_master_id = item.fee_structure_master

                    FeeStructureMaster_instance = FeeStructureMaster.objects.get(pk=fee_structure_master_id)

                    # Get element name ID
                    element_type_id = item.element_type_id

                    # Get Element Type Instance
                    elementtypeInstance = FeeElementType.objects.get(id=element_type_id)

                    # Get the element frequency ID from the current item
                    element_frequency_id = item.element_frequency

                    # Fetch the fee frequency instance
                    FeeFrequency_instance = FeeFrequency.objects.get(pk=element_frequency_id)

                    # Make Response data
                    data = {
                        'id': item.id,
                        'FeeStructureMaster_id': FeeStructureMaster_instance.id,
                        'fee_structure_code': FeeStructureMaster_instance.fee_structure_code,
                        'elementTypeId': elementtypeInstance.id,
                        'element_name': elementtypeInstance.element_name,
                        'element_frequency_id': item.element_frequency,
                        'element_frequency': FeeFrequency_instance.fee_frequency_name,
                        'amount': item.amount,
                        'period_1': item.period_1,
                        'period_2': item.period_2,
                        'period_3': item.period_3,
                        'period_4': item.period_4,
                        'period_5': item.period_5,
                        'period_6': item.period_6,
                        'adjustment_flag': item.adjustment_flag,
                    }

                    responsedata.append(data)

                if responsedata:
                    return Response({'message': 'success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)


        except Exception as e:
            # Handle and log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='FeeStructureDetail_Get',
            message=error_message,
        )


class FeeStructureDetailsUpdateAPIView(UpdateAPIView):
    queryset = FeeStructureDetail.objects.all()
    serializer_class = FeeStructureDetailUpdateSerializer

    def update(self, request, *args, **kwargs):
        try:
            partial = kwargs.pop('partial', False)
            instance = self.get_object()

            # Validate input data
            serializer = self.get_serializer(instance, data=request.data, partial=partial)
            serializer.is_valid(raise_exception=True)

            # Access serializer data
            fee_structure_master = serializer.validated_data.get('fee_structure_master')
            element_type = serializer.validated_data.get('element_type')
            element_frequency = serializer.validated_data.get('element_frequency')
            amount = int(serializer.validated_data.get('amount'))
            period_1 = serializer.validated_data.get('period_1')
            period_2 = serializer.validated_data.get('period_2')
            period_3 = serializer.validated_data.get('period_3')
            period_4 = serializer.validated_data.get('period_4')
            period_5 = serializer.validated_data.get('period_5')
            period_6 = serializer.validated_data.get('period_6')
            adjustment_flag = serializer.validated_data.get('adjustment_flag')
            updated_by = serializer.validated_data.get('updated_by')

            # Check if no changes were made
            if (instance.FeeStructureMaster_id == fee_structure_master and
                    instance.element_type_id == element_type and
                    instance.element_frequency == element_frequency and
                    instance.amount == amount and
                    instance.period_1 == period_1 and
                    instance.period_2 == period_2 and
                    instance.period_3 == period_3 and
                    instance.period_4 == period_4 and
                    instance.period_5 == period_5 and
                    instance.period_6 == period_6 and
                    instance.adjustment_flag == adjustment_flag
            ):
                return Response({'message': 'No changes identified'}, status=status.HTTP_200_OK)

            # Check if a similar record already exists
            if FeeStructureDetail.objects.exclude(pk=instance.pk).filter(
                    fee_structure_master=fee_structure_master,
                    element_type=element_type,
                    element_frequency=element_frequency

            ).exists():
                return Response({'message': 'This fee structure details already exists.'},
                                status=status.HTTP_400_BAD_REQUEST)

            # Update instance with new data
            instance.fee_structure_master = fee_structure_master
            instance.element_type = element_type
            instance.element_frequency = element_frequency
            instance.amount = amount
            instance.period_1 = period_1
            instance.period_2 = period_2
            instance.period_3 = period_3
            instance.period_4 = period_4
            instance.period_5 = period_5
            instance.period_6 = period_6
            instance.adjustment_flag = adjustment_flag
            instance.updated_by = updated_by

            instance.save()

            return Response({'message': 'fee structure details  updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='feestuructuedetailsUpdate',
            message=error_message,
        )


class FeeStructureDetailsDeleteAPIVIEW(DestroyAPIView):
    queryset = FeeStructureDetail.objects.all()
    serializer_class = FeeStructureDetailSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance.is_active:
                instance.is_active = False
                instance.save()

                return Response({'message': f'  fee structure details deleted successfully !!.'},
                                status=status.HTTP_200_OK)
            else:
                return Response({'message': 'fee structure details already inactive.'},
                                status=status.HTTP_400_BAD_REQUEST)

        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)


class PeriodCreateAPIView(CreateAPIView):
    queryset = Period.objects.all()
    serializer_class = PeriodSerializer

    def create(self, request, *args, **kwargs):
        try:
            # Validate and save data
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            # Get validate Data
            period_name = serializer.validated_data.get('period_name').upper()
            period_description = serializer.validated_data.get('period_description')
            fees_exempt = serializer.validated_data.get('fees_exempt', 'N').upper()
            if fees_exempt == '':
                fees_exempt = 'N'
            serializer.validated_data['fees_exempt'] = fees_exempt

            organization = serializer.validated_data.get('organization').id
            # branch_id = serializer.validated_data.get('branch_id').id
            no_of_months = serializer.validated_data.get('no_of_months')
            sorting_order = serializer.validated_data.get('sorting_order')
            academic_id = serializer.validated_data.get('academic_id').id
            period_start_date = serializer.validated_data.get('period_start_date')
            period_end_date = serializer.validated_data.get('period_end_date')
            created_by = serializer.validated_data.get('created_by')

            # Get Forign key instance
            organization_instance = Organization.objects.get(pk=organization)

            # branch_instance = Branches.objects.get(pk=branch_id)

            academicyear_instance = AcademicYear.objects.get(pk=academic_id)

            # Check this record already exist or not
            if Period.objects.filter(
                    period_name=period_name,
                    organization=organization,
                    # branch_id=branch_id,
                    academic_id=academic_id,
                    is_active=True

            ).exists():
                return Response({'message': 'This period already been added'},
                                status=status.HTTP_400_BAD_REQUEST)
            # create fee details & save
            period_instance = Period.objects.create(
                period_name=period_name,
                period_description=period_description,
                fees_exempt=fees_exempt,
                organization=organization_instance,
                # branch_id=branch_instance,
                no_of_months=no_of_months,
                sorting_order=sorting_order,
                academic_id=academicyear_instance,
                period_start_date=period_start_date,
                period_end_date=period_end_date,
                created_by=created_by,
                updated_by=created_by
            )

            period_instance.save()

            # Prepare the response data
            response_data = {
                'message': 'Added Successfully!',
                'data': {
                    'id': period_instance.id,
                    'period_name': period_instance.period_name,
                    'period_description': period_instance.period_description,
                    'fees_exempt': period_instance.fees_exempt,
                    'organization': period_instance.organization.id,
                    # 'branch_id': period_instance.branch_id.id,
                    'no_of_months': period_instance.no_of_months,
                    'sorting_order': period_instance.sorting_order,
                    'academic_id': period_instance.academic_year.id,
                    'period_start_date': period_instance.period_start_date,
                    'period_end_date': period_instance.period_end_date,

                }
            }

            return Response({'message': 'success', 'data': response_data}, status=status.HTTP_200_OK)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='PeriodAdd',
            message=error_message,
        )


class PeriodListAPIView(ListAPIView):
    queryset = Period.objects.all()
    serializer_class = PeriodSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                print(resdata)
                # prepare data from response
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:
                        # Get Data
                        organization = item.get('organization')
                        # branch_id = item.get('branch_id')
                        academic_year = item.get('academic_year')

                        # Get student,class & section instance

                        organization_instance = Organization.objects.get(pk=organization)
                        # branch_instance = Branches.objects.get(pk=branch_id)
                        academic_instance = AcademicYear.objects.get(pk=academic_year)

                        # Make Response data
                        data = {
                            'id': item.get('id'),
                            'period_name': item.get('period_name'),
                            'period_description': item.get('period_description'),
                            'fees_exempt': item.get('fees_exempt'),
                            'organization': organization_instance.id,
                            'organization_code': organization_instance.organization_code,
                            # 'branch_id': branch_instance.id,
                            # 'branch_name': branch_instance.branch_name,
                            'no_of_months': item.get('no_of_months'),
                            'sorting_order': item.get('sorting_order'),
                            'academic_id': academic_instance.id,
                            'academic_year_code': academic_instance.academic_year_code,
                            'period_start_date': item.get('period_start_date'),
                            'period_end_date': item.get('period_end_date'),

                        }

                        responsedata.append(data)
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'success', 'data': responsedata})
                else:
                    return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='periodlist',

            message=error_message,

        )


class PeriodUpdateAPIView(UpdateAPIView):
    queryset = Period.objects.all()
    serializer_class = PeriodUpdateSerializer

    def update(self, request, *args, **kwargs):
        try:
            partial = kwargs.pop('partial', False)
            instance = self.get_object()

            # Validate input data
            serializer = self.get_serializer(instance, data=request.data, partial=partial)
            serializer.is_valid(raise_exception=True)

            # Access serializer data
            period_name = serializer.validated_data.get('period_name').upper()
            period_description = serializer.validated_data.get('period_description')
            fees_exempt = serializer.validated_data.get('fees_exempt', 'N').upper()
            if fees_exempt == '':
                fees_exempt = 'N'
            serializer.validated_data['fees_exempt'] = fees_exempt

            organization = serializer.validated_data.get('organization')
            # branch_id = serializer.validated_data.get('branch_id')
            no_of_months = serializer.validated_data.get('no_of_months')
            sorting_order = serializer.validated_data.get('sorting_order')
            academic_id = serializer.validated_data.get('academic_id')
            period_start_date = serializer.validated_data.get('period_start_date')
            period_end_date = serializer.validated_data.get('period_end_date')
            updated_by = serializer.validated_data.get('updated_by')

            # Check if no changes were made
            if (instance.period_name == period_name and
                    instance.period_description == period_description and
                    instance.fees_exempt == fees_exempt and
                    instance.organization == organization and
                    # instance.branch_id == branch_id and
                    instance.no_of_months == no_of_months and
                    instance.sorting_order == sorting_order and
                    instance.academic_id == academic_id and
                    instance.period_start_date == period_start_date and
                    instance.period_end_date == period_end_date
            ):
                return Response({'message': 'No changes identified'}, status=status.HTTP_200_OK)

            # Check if a similar record already exists
            if Period.objects.exclude(pk=instance.pk).filter(
                    period_name=period_name,
                    organization=organization,
                    # branch_id = branch_id,
                    academic_id=academic_id,
                    is_active=True

            ).exists():
                return Response({'message': 'This period already exists.'}, status=status.HTTP_400_BAD_REQUEST)

            # Update instance with new data
            instance.period_name = period_name
            instance.period_description = period_description
            instance.fees_exempt = fees_exempt
            instance.organization = organization
            # instance.branch_id = branch_id
            instance.no_of_months = no_of_months
            instance.sorting_order = sorting_order
            instance.academic_id = academic_id
            instance.period_start_date = period_start_date
            instance.period_end_date = period_end_date
            instance.updated_by = updated_by

            instance.save()

            return Response({'message': 'Period  updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='periodUpdate',
            message=error_message,
        )


class PeriodDestroyAPIView(DestroyAPIView):
    queryset = Period.objects.all()
    serializer_class = PeriodSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()
            if instance.is_active:
                instance.is_active = False
                instance.save()

                return Response({'message': 'Period Deactivated Successfully'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'Period already Deactivated.'}, status=status.HTTP_400_BAD_REQUEST)

        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)


class StudentAddressCreateAPIView(CreateAPIView):
    queryset = Address.objects.all()
    serializer_class = AddressSerializer

    def create(self, request, *args, **kwargs):
        try:
            # Validate and save data
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            # Get validate Data
            reference_id = serializer.validated_data.get('reference_id')
            present_address = serializer.validated_data.get('present_address')
            present_pincode = serializer.validated_data.get('present_pincode')
            present_city = serializer.validated_data.get('present_city')

            present_state = serializer.validated_data.get('present_state')
            present_country = serializer.validated_data.get('present_country')
            present_phone_number = serializer.validated_data.get('present_phone_number')
            permanent_address = serializer.validated_data.get('permanent_address')
            permanent_pincode = serializer.validated_data.get('permanent_pincode')
            permanent_city = serializer.validated_data.get('permanent_city')
            permanent_state = serializer.validated_data.get('permanent_state')
            permanent_country = serializer.validated_data.get('permanent_country')
            permanent_phone_number = serializer.validated_data.get('permanent_phone_number')
            created_by = serializer.validated_data.get('created_by')

            #
            #         # Check this record already exist or not
            if Address.objects.filter(
                    reference_id=reference_id,
                    usertype='STUDENT',
                    is_active=True

            ).exists():
                return Response({'message': 'student address already added'},
                                status=status.HTTP_400_BAD_REQUEST)
            #         # create fee details & save
            student_address_instance = Address.objects.create(
                reference_id=reference_id,
                usertype='STUDENT',
                present_address=present_address,
                present_pincode=present_pincode,
                present_city=present_city,
                present_state=present_state,
                present_country=present_country,
                present_phone_number=present_phone_number,
                permanent_address=permanent_address,
                permanent_pincode=permanent_pincode,
                permanent_city=permanent_city,
                permanent_state=permanent_state,
                permanent_country=permanent_country,
                permanent_phone_number=permanent_phone_number,

                created_by=created_by,
                updated_by=created_by
            )

            student_address_instance.save()

            # Prepare the response data
            response_data = {
                'message': 'Added Successfully!',
                'data': {
                    'id': student_address_instance.id,
                    'reference_id': student_address_instance.reference_id,
                    'usertype': student_address_instance.usertype,
                    'present_address': student_address_instance.present_address,
                    'present_pincode': student_address_instance.present_pincode,
                    'present_city': student_address_instance.present_city,
                    'present_state': student_address_instance.present_state,
                    'present_country': student_address_instance.present_country,
                    'present_phone_number': student_address_instance.present_phone_number,
                    'permanent_address': student_address_instance.permanent_address,
                    'permanent_pincode': student_address_instance.permanent_pincode,
                    'permanent_city': student_address_instance.permanent_city,
                    'permanent_state': student_address_instance.permanent_state,
                    'permanent_country': student_address_instance.permanent_country,
                    'permanent_phone_number': student_address_instance.permanent_phone_number,

                }
            }

            return Response({'message': 'success', 'data': response_data}, status=status.HTTP_200_OK)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='PeriodAdd',
            message=error_message,
        )


class StudentAddressListAPIView(ListAPIView):
    # queryset = Period.objects.all()
    serializer_class = AddressSerializer

    def get_queryset(self):
        student_id = self.kwargs.get('pk')
        if student_id:
            return Address.objects.filter(reference_id=student_id)
        return Address.objects.none()

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                # prepare data from response
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:
                        # Get Data
                        # organization = item.get('organization')
                        # branch_id = item.get('branch_id')
                        # academic_id = item.get('academic_id')

                        # Get student,class & section instance

                        # organization_instance = Organization.objects.get(pk=organization)
                        # branch_instance = Branches.objects.get(pk=branch_id)
                        # academic_instance = AcademicYear.objects.get(pk=academic_id)

                        # Make Response data
                        data = {
                            'id': item.get('id'),
                            'reference_id': item.get('reference_id'),
                            'usertype': item.get('usertype'),
                            'present_address': item.get('present_address'),
                            'present_pincode': item.get('present_pincode'),
                            'present_city': item.get('present_city'),
                            'present_state': item.get('present_state'),
                            'present_country': item.get('present_country'),
                            'present_phone_number': item.get('present_phone_number'),
                            'permanent_address': item.get('permanent_address'),
                            'permanent_pincode': item.get('permanent_pincode'),
                            'permanent_city': item.get('present_address'),
                            'permanent_state': item.get('permanent_state'),
                            'permanent_country': item.get('permanent_country'),
                            'permanent_phone_number': item.get('permanent_phone_number'),

                        }

                        responsedata.append(data)
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'success', 'data': responsedata})
                else:
                    return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='studentaddresslist',

            message=error_message,

        )


class StudentAddressUpdateAPIView(UpdateAPIView):
    queryset = Address.objects.all()
    serializer_class = AddressUpdateSerializer

    def update(self, request, *args, **kwargs):
        try:
            partial = kwargs.pop('partial', False)
            instance = self.get_object()

            # Validate input data
            serializer = self.get_serializer(instance, data=request.data, partial=partial)
            serializer.is_valid(raise_exception=True)

            # Get validate Data

            present_address = serializer.validated_data.get('present_address')
            present_pincode = serializer.validated_data.get('present_pincode')
            present_city = serializer.validated_data.get('present_city')
            present_state = serializer.validated_data.get('present_state')
            present_country = serializer.validated_data.get('present_country')
            present_phone_number = serializer.validated_data.get('present_phone_number')

            permanent_address = serializer.validated_data.get('permanent_address')
            permanent_pincode = serializer.validated_data.get('permanent_pincode')
            permanent_city = serializer.validated_data.get('permanent_city')
            permanent_state = serializer.validated_data.get('permanent_state')
            permanent_country = serializer.validated_data.get('permanent_country')
            permanent_phone_number = serializer.validated_data.get('permanent_phone_number')
            updated_by = serializer.validated_data.get('updated_by')

            # Check if no changes were made
            if (
                    instance.present_address == present_address and
                    instance.present_pincode == present_pincode and
                    instance.present_city == present_city and
                    instance.present_state == present_state and
                    instance.present_country == present_country and
                    instance.present_phone_number == present_phone_number and
                    instance.permanent_address == permanent_address and
                    instance.permanent_pincode == permanent_pincode and
                    instance.permanent_city == permanent_city and
                    instance.permanent_pincode == permanent_pincode and
                    instance.permanent_state == permanent_state and
                    instance.permanent_country == permanent_country and
                    instance.permanent_phone_number == permanent_phone_number
            ):
                return Response({'message': 'No changes identified'}, status=status.HTTP_200_OK)

            # Check if a similar record already exists
            # if Period.objects.exclude(pk=instance.pk).filter(
            #     period_name=period_name,
            #     organization = organization,
            #     branch_id = branch_id,
            #     academic_id =academic_id,
            #     is_active = True
            #
            # ).exists():
            #     return Response({'message': 'This period already exists.'}, status=status.HTTP_400_BAD_REQUEST)

            # Update instance with new data
            instance.present_address = present_address
            instance.present_pincode = present_pincode
            instance.present_city = present_city
            instance.present_state = present_state
            instance.present_country = present_country
            instance.present_phone_number = present_phone_number
            instance.permanent_address = permanent_address
            instance.permanent_pincode = permanent_pincode
            instance.permanent_city = permanent_city
            instance.permanent_pincode = permanent_pincode
            instance.permanent_state = permanent_state
            instance.permanent_country = permanent_country
            instance.permanent_phone_number = permanent_phone_number
            instance.updated_by = updated_by

            instance.save()

            return Response({'message': 'student Address updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='studentaddressUpdate',
            message=error_message,
        )


class StudentAddressDestroyAPIView(DestroyAPIView):
    queryset = Address.objects.all()
    serializer_class = AddressSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            instance = self.get_object()
            if instance.is_active:
                instance.is_active = False
                instance.save()

                return Response({'message': 'address Deactivated Successfully'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'record already Deactivated.'}, status=status.HTTP_400_BAD_REQUEST)

        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)


class StudentDetailsGetListAPIView(ListAPIView):
    queryset = StudentCourse.objects.all()
    serializer_class = StudentDetailsGetSerializer

    def list(self, request, *args, **kwargs):
        try:
            academic_id = self.kwargs.get('academic_id')
            student_id = self.kwargs.get('student_id')

            try:
                studentCourseInstance = StudentCourse.objects.get(student=student_id, academic_year=academic_id,
                                                                  is_active=True)
            except ObjectDoesNotExist:
                return Response({'message': 'Student class Not Found!!'}, status=status.HTTP_404_NOT_FOUND)

            # Get Fee structure Instance
            feestructureInstance = None
            try:
                feestructureInstance = FeeStructureMaster.objects.get(id=studentCourseInstance.fee_group.id,
                                                                      is_active=True)
            except ObjectDoesNotExist:
                feestructureInstance = None

            # Get Feeappfrom Instance
            semesterInstance = None
            try:
                semesterInstance = Semester.objects.get(id=studentCourseInstance.fee_applied_from.id,
                                                        is_active=True)
            except ObjectDoesNotExist:
                semesterInstance = None

            # Response Data

            name_part = filter(None, [
                studentCourseInstance.student.first_name,
                studentCourseInstance.student.middle_name,
                studentCourseInstance.student.last_name
            ])
            student_name = " ".join(name_part)

            data = {
                'student_id': student_id,
                'first_name': studentCourseInstance.student.first_name,
                'studentname': student_name,
                'gender': studentCourseInstance.student.gender.gender_name,
                'barcode': studentCourseInstance.student.barcode,
                'registration_no': studentCourseInstance.student.registration_no,
                'college_admission_no': studentCourseInstance.student.college_admission_no,
                'dob': studentCourseInstance.student.date_of_birth,
                'username': studentCourseInstance.student.user_name,
                'email': studentCourseInstance.student.email,
                'course_name': studentCourseInstance.student.course.course_name,
                'section_name': studentCourseInstance.student.section.section_name,
                'feestructureId': feestructureInstance.id if feestructureInstance else None,
                'fee_group': feestructureInstance.fee_structure_code if feestructureInstance else None,
                'fee_applied_fromId': semesterInstance.id if semesterInstance else None,
                'feeappform': semesterInstance.semester_description if semesterInstance else None,
                'enrollment_no': studentCourseInstance.enrollment_no,
                'house': studentCourseInstance.house.house_name,
                'transport_availed': studentCourseInstance.transport_availed,
                'choice_semester': studentCourseInstance.choice_semester
            }

            return Response({'message': 'success', 'data': data}, status=status.HTTP_200_OK)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='studentdetailsGet',

            message=error_message,

        )


class StudentFullDetailsAPIView(ListAPIView):
    """
    GET: Get comprehensive student details including mentor and communication info.

    Query params:
    - student_id: Required - Student ID
    - academic_year_id: Optional - Filter mentor/communication by academic year
    - organization_id: Optional - For validation
    - branch_id: Optional - For validation
    """

    def list(self, request, *args, **kwargs):
        try:
            student_id = request.query_params.get('student_id')
            academic_year_id = request.query_params.get('academic_year_id')
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')

            if not student_id:
                return Response(
                    {'message': 'student_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            # Get student registration
            try:
                student = StudentRegistration.objects.get(id=student_id, is_active=True)
            except StudentRegistration.DoesNotExist:
                return Response(
                    {'message': 'Student not found'},
                    status=status.HTTP_404_NOT_FOUND
                )

            # Get current StudentCourse for class/section info
            student_course = None
            course_name = None
            section_name = None
            try:
                student_course = StudentCourse.objects.filter(
                    student=student,
                    is_active=True
                ).order_by('-created_at').first()

                if student_course:
                    course_name = student_course.course.course_name if student_course.course else None
                    section_name = student_course.section.section_name if student_course.section else None
            except Exception:
                pass

            # Build student name
            student_name_parts = [
                student.first_name,
                student.middle_name,
                student.last_name
            ]
            student_name = " ".join(p for p in student_name_parts if p)

            # Get mentor assignments
            mentor_assignments = []
            try:
                from MENTOR.models import StudentMentorAssignment, Mentor

                mentor_queryset = StudentMentorAssignment.objects.filter(
                    student=student,
                    is_active=True,
                    status='ACTIVE'
                )

                if academic_year_id:
                    mentor_queryset = mentor_queryset.filter(academic_year_id=academic_year_id)

                for assignment in mentor_queryset:
                    mentor = assignment.mentor
                    employee = mentor.employee

                    mentor_name_parts = [
                        employee.title,
                        employee.first_name,
                        employee.middle_name,
                        employee.last_name
                    ]
                    mentor_name = " ".join(p for p in mentor_name_parts if p)

                    mentor_assignments.append({
                        'assignment_id': assignment.id,
                        'mentor_id': mentor.id,
                        'mentor_name': mentor_name,
                        'employee_code': employee.employee_code,
                        'employee_id': employee.id,
                        'department_name': mentor.department.department_description if mentor.department else None,
                        'assignment_date': assignment.assignment_date,
                        'is_primary': assignment.is_primary,
                        'status': assignment.status,
                    })
            except Exception as e:
                # If mentor module not available, just skip
                pass

            # Get communication history
            communication_history = []
            try:
                from MENTOR.models import MentorStudentCommunication

                comm_queryset = MentorStudentCommunication.objects.filter(
                    student=student,
                    is_active=True
                ).order_by('-communication_date', '-created_at')

                if academic_year_id:
                    comm_queryset = comm_queryset.filter(academic_year_id=academic_year_id)

                # Limit to last 20 communications
                for comm in comm_queryset[:20]:
                    mentor = comm.mentor
                    employee = mentor.employee

                    mentor_name_parts = [
                        employee.title,
                        employee.first_name,
                        employee.middle_name,
                        employee.last_name
                    ]
                    mentor_name = " ".join(p for p in mentor_name_parts if p)

                    communication_history.append({
                        'id': comm.id,
                        'communication_date': comm.communication_date,
                        'mentor_name': mentor_name,
                        'mentor_employee_code': employee.employee_code,
                        'communicated_with': comm.communicated_with,
                        'communicated_via': comm.communicated_via,
                        'communication_details': comm.communication_details,
                        'remarks': comm.remarks,
                    })
            except Exception as e:
                # If mentor module not available, just skip
                pass

            # Build response
            response_data = {
                'student_id': student.id,
                'student_name': student_name,
                'first_name': student.first_name,
                'middle_name': student.middle_name,
                'last_name': student.last_name,
                'admission_no': student.admission_no,
                'college_admission_no': student.college_admission_no,
                'barcode': student.barcode,
                'course_name': course_name,
                'section_name': section_name,
                'student_mobile_no': student.contact_no,
                'student_email': student.email,
                'father_name': student.father_name,
                'father_mobile_no': student.father_contact_number,
                'father_email': student.father_email,
                'mother_name': student.mother_name,
                'mother_mobile_no': student.mother_contact_number,
                'mother_email': student.mother_email,
                'mentors': mentor_assignments,
                'communication_history': communication_history,
            }

            return Response(
                {'message': 'success', 'data': response_data},
                status=status.HTTP_200_OK
            )

        except Exception as e:
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response(
                {'error': error_message},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='StudentFullDetails',
            message=error_message,
        )


# class StudentDetailsGetListAPIView(ListAPIView):
#     serializer_class = StudentDetailsGetSerializer
#     def get_queryset(self):
#         academic_id = self.kwargs.get('academic_id')
#         student_id = self.kwargs.get('student_id')
#
# return StudentRegistration.objects.filter(academic_year_id=academic_id, id=student_id)
#
#     def list(self, request, *args, **kwargs):
#         try:
#             queryset = self.get_queryset()
#
#
#             # Check if the queryset is empty and raise NotFound exception if true
#             if not queryset.exists():
#                 # raise NotFound(detail="Student details not found for the provided academic year and student ID.")
#                 return Response({"message":"Student details not found for the provided academic year and student ID."},status=status.HTTP_200_OK)
#
#             # Create a list to hold serialize data
#             response_data=[]
#
#             # Iterate over the queryset using a for loop
#             for student in queryset:
#                 student_id= student.id
#
#                 student_course_instance= StudentCourse.objects.get(student_id=student_id,is_active=True)
#
#                 addmitted_class_id= student.addmitted_class
#                 addmitted_section_id= student.addmitted_section
#                 fee_group_id = student.fee_group
#                 feeappfrom_id = student.feeappfrom
#
#
#                 course_instance= Course.objects.get(id=addmitted_class_id.id)
#
#
#                 section_instance= Section.objects.get(id=addmitted_section_id.id)
#
#                 fee_group_instance = FeeStructureMaster.objects.get(id=fee_group_id.id)
#
#                 feeappfrom_instance = Period.objects.get(id=feeappfrom_id.id)
#
#
#
# data={
#     'student_id':student_id,
#     'first_name': student.first_name,
#     'gender': student.gender,
#     'barcode': student.barcode,
#     'registration_no': student.registration_no,
#     'college_admission_no': student.college_admission_no,
#     'dob': student.dob,
#     'username': student.username,
#     'email': student.email,
#     'course_name': course_instance.classname,
#     'section_name': section_instance.sectionname,
#     'fee_group': fee_group_instance.fee_structure_code,
#     'feeappform': feeappfrom_instance.period_name,
#     'enrollment_no': student_course_instance.enrollment_no,
#     'house': student_course_instance.house,
#     'transport_availed': student_course_instance.transport_availed,
#     'choice_month': student_course_instance.choice_month
# }
#
#
#                 # Append the data for each student to the list
#                 response_data.append(data)
#
#                 # Return the list of student data as the response
#             return Response(response_data, status=status.HTTP_200_OK)
#
#         except Exception as e:
#
#             # Log the exception
#
#             error_message = str(e)
#
#             self.log_exception(request, error_message)
#
#             return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#     def log_exception(self, request, error_message):
#
#         ExceptionTrack.objects.create(
#
#             request=str(request),
#
#             process_name='studentdetailsGet',
#
#             message=error_message,
#
#         )


class StudentFeeDetailGetListAPIView(ListAPIView):
    queryset = StudentFeeDetail.objects.all()
    serializer_class = StudentFeeDetailSerializer

    def list(self, request, *args, **kwargs):

        try:
            academic_id = self.kwargs.get('academic_id')
            student_id = self.kwargs.get('student_id')

            try:
                studentfeedetailsrecord = StudentFeeDetail.objects.filter(academic_year=academic_id, student=student_id,
                                                                          is_active=True)
            except:
                return Response({'message': 'No student fee details found'}, status=status.HTTP_404_NOT_FOUND)

            responsedata = []

            for item in studentfeedetailsrecord:
                semesterInstance = None
                try:
                    semesterInstance = Semester.objects.get(id=item.fee_applied_from.id, is_active=True)
                except ObjectDoesNotExist:
                    semesterInstance = None

                responsedata.append({
                    'id': item.id,
                    'element_name': item.element_name,
                    'fee_applied_fromId': semesterInstance.id if semesterInstance else None,
                    'period_month': semesterInstance.semester_description if semesterInstance else None,
                    'element_amount': item.element_amount,
                    'total_element_period_amount': item.total_element_period_amount,
                    'paid_amount': item.paid_amount,
                    'remarks': item.remarks,
                    'multiplying_factor': item.multiplying_factor
                })
            return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)

            # data = {
            #         'id': student.id,
            #         # 'student_id':student_instance.id,
            #         'element_name': student.element_name,
            #
            #         'period_month': student.period_month,
            #         'element_amount': student.element_amount,
            #         'total_element_period_amount': student.total_element_period_amount,
            #         'paid_amount': student.paid_amount,
            #         'remarks': student.remarks,
            #         'multiplying_factor': student.multiplying_factor
            #                 }





        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='studentfeedetailsGet',

            message=error_message,

        )


# class StudentFeeDetailGetListAPIView(ListAPIView):
#     serializer_class =studentfeedetails_Serializer
#
#     def get_queryset(self):
#
#         academic_id = self.kwargs.get('academic_id')
#         student_id = self.kwargs.get('student_id')
#
#         return StudentFeeDetail.objects.filter(academic_year_id=academic_id, student_id=student_id)  #is_active=True
#
#     def list(self, request, *args, **kwargs):
#         try:
#             queryset = self.get_queryset()
#
#             # Check if the queryset is empty and raise NotFound exception if true
#             if not queryset.exists():
#                 raise NotFound(detail="Student details not found for the provided academic year and student ID.")
#
#             # Create a list to hold serialize data
#             response_data = []
#
#             # Iterate over the queryset using a for loop
#             for student in queryset:
#
#
#                 data={
#                     'id': student.id,
#                     # 'student_id':student_instance.id,
#                     'element_name': student.element_name,
#
#                     'period_month': student.period_month,
#                     'element_amount': student.element_amount,
#                     'total_element_period_amount': student.total_element_period_amount,
#                     'paid_amount': student.paid_amount,
#                     'remarks': student.remarks,
#                     'multiplying_factor': student.multiplying_factor
#                 }
#                 response_data.append(data)
#
#             # Return the list of student data as the response
#             return Response(response_data, status=status.HTTP_200_OK)
#
#     except Exception as e:
#
#         # Log the exception
#
#         error_message = str(e)
#
#         self.log_exception(request, error_message)
#
#         return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
# def log_exception(self, request, error_message):
#
#     ExceptionTrack.objects.create(
#
#         request=str(request),
#
#         process_name='studentfeedetailsGet',
#
#         message=error_message,
#
#     )
class FeeElementTypeListAPIView(ListAPIView):
    queryset = FeeElementType.objects.all()
    serializer_class = FeeElementTypeSerializer

    def get_queryset(self):
        # Get the elementType from the URL
        element_type = self.kwargs.get('elementType')

        # Use regular expression to check if element_type contains only a-z or A-Z

        if element_type and re.match(r'^[a-zA-Z]+$', element_type):
            # If element_type is valid, filter the queryset based on element_type
            return FeeElementType.objects.filter(element_type=element_type, is_active=True)
        else:
            # If element_type is invalid (contains non-alphabetic characters), return all active records
            return FeeElementType.objects.filter(is_active=True)

        # Filter the queryset based on element_type
        # return FeeElementType.objects.filter(element_type=element_type, is_active=True)

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                # prepare data from response
                responsedata = []

                for item in resdata:
                    if item.get('is_active') == True:
                        # Get Data
                        organization = item.get('organization')
                        branch = item.get('branch')
                        # academic_id = item.get('academic_id')

                        # Get Organization & Branch
                        organization_instance = Organization.objects.get(pk=organization)
                        branch_instance = Branch.objects.get(id=branch)

                        # Make Response data
                        data = {
                            'id': item.get('id'),
                            'element_name': item.get('element_name'),
                            'element_description': item.get('element_description'),
                            'organization': organization_instance.id,
                            'organization_code': organization_instance.organization_code,
                            'branch_id': branch_instance.id,
                            'branch_description': branch_instance.branch_name,
                            'sequence_order': item.get('sequence_order'),
                            'element_type': item.get('element_type')

                        }

                        responsedata.append(data)
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'success', 'data': responsedata})
                else:
                    return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', }, status=status.HTTP_200_OK)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='FeeElementTypelist',

            message=error_message,

        )


class GetStudentBasedOnCourseSection(ListAPIView):
    serializer_class = StudentGetBasedOnCourseSectionSerializer

    def list(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.query_params)
            serializer.is_valid(raise_exception=True)
            # {organization_id,branch_id,batch_id,course_ids,department_ids,academic_year_id,semester_ids,section_ids}
            # Get Value into query params
            organization_id = serializer.validated_data.get('organization_id')
            branch_id = serializer.validated_data.get('branch_id')
            batch_id = serializer.validated_data.get('batch_id')
            # course_id = serializer.validated_data.get('course_id')
            course_ids_list = serializer.validated_data.get('course_ids')
            # department_id = serializer.validated_data.get('department_id')
            department_ids_list = serializer.validated_data.get('department_ids')
            academic_year_id = serializer.validated_data.get('academic_year_id')
            semester_ids_list = serializer.validated_data.get('semester_ids')
            # semester_id = serializer.validated_data.get('semester_id')
            # semester_id = serializer.validated_data.get('section_id')
            section_ids_list = serializer.validated_data.get('section_ids')

            # print(class_ids_list,type(class_ids_list))

            # Convert class_ids to a list of integers by stripping brackets and splitting by comma
            if isinstance(course_ids_list, list):
                course_ids_list = [int(i) for i in course_ids_list[0].split(',')]
            if isinstance(department_ids_list, list):
                department_ids_list = [int(i) for i in department_ids_list[0].split(',')]
            if isinstance(semester_ids_list, list):
                semester_ids_list = [int(i) for i in semester_ids_list[0].split(',')]
            if isinstance(section_ids_list, list):
                section_ids_list = [int(i) for i in section_ids_list[0].split(',')]

            try:
                student_list = StudentCourse.objects.filter(organization=organization_id, branch=branch_id,
                                                            batch=batch_id, academic_year=academic_year_id,
                                                            course__in=course_ids_list,
                                                            department__in=department_ids_list
                                                            , semester__in=semester_ids_list,
                                                            section__in=section_ids_list,
                                                            is_active=True)
            except:
                student_list = []

            student_record = []

            if student_list:
                for item in student_list:
                    name_part = filter(None, [
                        item.student.first_name,
                        item.student.middle_name,
                        item.student.last_name
                    ])
                    student_name = " ".join(name_part)

                    data = {
                        'student_id': item.student.id,  # student_course_instance.id,
                        'student_name': student_name,
                        'organization': item.student.organization.organization_code,
                        'branch': item.student.branch.branch_code,
                        'batch': item.student.batch.batch_code,
                        'course_name': item.student.course.course_name,
                        'department': item.student.department.department_code,
                        'academic_year': item.student.academic_year.academic_year_code,
                        'semester': item.student.semester.semester_code,
                        'section': item.student.section.section_name,
                        'registration_no': item.student.registration_no,
                        'enrollment_no': item.enrollment_no,
                        'college_admission_no': item.student.college_admission_no,
                        'barcode': item.student.barcode,
                        'father_name': item.student.father_name,
                        'mother_name': item.student.mother_name,

                    }

                    student_record.append(data)
                return Response({'message': 'success', 'data': student_record}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'success', 'data': student_record}, status=status.HTTP_204_NO_CONTENT)



        except ValidationError as e:

            return Response({'message': e.detail}, status=status.HTTP_400_BAD_REQUEST)


        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='students-by-class-section',

            message=error_message,

        )


# class StudentGetBasedOnCourseSection(ListAPIView):
#     serializer_class = StudentGetBasedOnCourseSectionSerializer
#
#     def get_queryset(self):
#         class_ids = self.kwargs.get('classlist')
#         section_ids = self.kwargs.get('sectionlist')
#
#
# # Convert class_ids to a list of integers by stripping brackets and splitting by comma
# class_ids_list = [cls_id.strip() for cls_id in class_ids.strip('[]').split(',')]
#
# # Convert section_ids to a list of strings by stripping brackets and splitting by comma
# section_ids_list = [sec_id.strip() for sec_id in section_ids.strip('[]').split(',')]
#
#
#
#         student_record=[]
#         for class_id in class_ids_list:
#             for section_id in section_ids_list:
#                 student_list=list(StudentCourse.objects.filter(addmitted_class__in=class_id, addmitted_section__in=section_id,is_active=True))
#                 if student_list:
#                     student_record.extend(student_list)
#
#
#         return student_record
#
#     def list(self, request, *args, **kwargs):
#         try:
#             queryset = self.get_queryset()
#
#
#             # Create a list to hold the response data
#             response_data = []
#
#             # Iterate over the student records and extract required fields
#             for student_course_instance in queryset:
#                 if student_course_instance.is_active:
#                     RegisterstudentInstance= StudentRegistration.objects.get(id=student_course_instance.student_id.id)
#
#                     student_data = {
#                         'student_id':RegisterstudentInstance.id,  #student_course_instance.id,
#                         'student_name': RegisterstudentInstance.first_name + ' ' + RegisterstudentInstance.last_name,
#                         # 'class_id': student_course_instance.addmitted_class.id,
#                         'course_name': student_course_instance.addmitted_class.classname,
#                         # 'section_id': student_course_instance.addmitted_section.id,
#                         'section_name': student_course_instance.addmitted_section.sectionname,
#                         'enrollment_no': student_course_instance.enrollment_no,
#                         'college_admission_no': RegisterstudentInstance.college_admission_no,
#                         'barcode': RegisterstudentInstance.barcode,
#                         'father_name': RegisterstudentInstance.father_name,
#                     }
#
#                     # Append the student data to the response list
#                     response_data.append(student_data)
#
#                 else:
#                     continue
#
#             if response_data:
#
#                 return Response({'message': 'Success', 'data': response_data}, status=status.HTTP_200_OK)
#             else:
#                 return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
#
#         except Exception as e:
#
#             # Log the exception
#
#             error_message = str(e)
#
#             self.log_exception(request, error_message)
#
#             return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#     def log_exception(self, request, error_message):
#
#         ExceptionTrack.objects.create(
#
#             request=str(request),
#
#             process_name='students-by-class-section',
#
#             message=error_message,
#
#         )
class GetFeeElementBasedOnFeeStructureAcademicSession(ListAPIView):
    serializer_class = FeeElementSerializer

    def get_queryset(self):
        academic_id = self.kwargs.get('academic_id')
        fee_structure = self.kwargs.get('fee_structure')

        # Get Fee Structure
        FeeStructureMaster_details = FeeStructureMaster.objects.get(academic_year_id=academic_id, id=fee_structure,
                                                                    is_active=True)

        # Get Fee Structure Id
        FeeStructureMaster_id = FeeStructureMaster_details.id

        # Get All Element Details
        fee_element_details = FeeStructureDetail.objects.filter(FeeStructureMaster_id=FeeStructureMaster_id,
                                                                is_active=True)

        return fee_element_details

    def list(self, request, *args, **kwargs):
        try:
            queryset = self.get_queryset()

            # Create a list to hold the response data
            response_data = []

            # Iterate over the student records and extract required fields
            for fee_details_instance in queryset:
                if fee_details_instance.is_active:

                    # Get FeeElement
                    FeeElementTypeInstance = FeeElementType.objects.get(id=fee_details_instance.element_type_id.id)

                    data = {
                        'id': fee_details_instance.id,
                        'elementTypeId': FeeElementTypeInstance.id,
                        'elementName': FeeElementTypeInstance.element_name,
                        'amount': fee_details_instance.amount,

                    }

                    # Append the student data to the response list
                    response_data.append(data)

                else:
                    continue

            if response_data:

                return Response({'message': 'Success', 'data': response_data}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='GetFilterdatabasedonacademic&feestructure',

            message=error_message,

        )


class ADHOCFessInsertInStudentFeeStructureDetailsCreateAPIView(ProcessFeeGroupMixin, CreateAPIView):
    serializer_class = InsertFeesForSelectedStudent

    def create(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            # Get validate data

            student_ids_list = serializer.validated_data.get('studentIds')
            period_ids_list = serializer.validated_data.get('periodIds')
            feeElement_ids_list = serializer.validated_data.get('feeElementIds')
            created_by = serializer.validated_data.get('created_by')

            # print(student_ids_list,period_ids_list,feeElement_ids_list)
            # print(type(student_ids_list))
            # print(type(period_ids_list))
            # print(type(feeElement_ids_list))

            # student_ids_list= [stu_id.strip() for stu_id in studentIds.strip('[]').split(',')]
            #
            # period_ids_list = [prd_id.strip() for prd_id in periodIds.strip('[]').split(',')]
            #
            # feeElement_ids_list = [feeEle_id.strip() for feeEle_id in feeElementIds.strip('[]').split(',')]

            if not student_ids_list:
                return Response({'message': 'Please select atleast one student'}, status=status.HTTP_400_BAD_REQUEST)

            if not feeElement_ids_list:
                return Response({'message': 'Please select atleast one fee Element'},
                                status=status.HTTP_400_BAD_REQUEST)

            if not period_ids_list:
                return Response({'message': 'Please select atleast one semester'}, status=status.HTTP_400_BAD_REQUEST)

            self.process_ADHOC_fee(student_ids_list, feeElement_ids_list, period_ids_list, created_by)

            return Response({'message': 'Successfully added ADHOC Fees.'}, status=status.HTTP_200_OK)

        except ValidationError as e:

            # Rollback the transaction on validation error

            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)


        except DatabaseError as e:

            # Rollback the transaction on database error

            self.log_exception(request, str(e))

            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        except Exception as e:

            # Rollback the transaction on any other exception

            self.log_exception(request, str(e))

            return Response({'error': 'An unexpected error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='StudentADHOCfeesAdd',

            message=error_message,

        )


class HouseListAPIView(ListAPIView):
    queryset = House.objects.all()
    serializer_class = HouseSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'organization_id': item.get('organization'),
                            'house_code': item.get('house_code'),
                            'house_name': item.get('house_name'),
                            'house_color': item.get('house_color'),
                            # 'orgid': item.get('organization'),
                            # 'branchid': item.get('branch_id'),

                        })
                    else:
                        continue
                if responsedata:

                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='houselist',
            message=error_message,
        )


class ReligionListAPIView(ListAPIView):
    queryset = Religion.objects.all()
    serializer_class = ReligionSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'religion_code': item.get('religion_code'),
                            'religion_name': item.get('religion_name')

                        })
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='religionlist',
            message=error_message,
        )


class CategoryListAPIView(ListAPIView):
    queryset = Category.objects.all()
    serializer_class = CategorySerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'category_code': item.get('category_code'),
                            'category_name': item.get('category_name')

                        })
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)




        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='categorylist',
            message=error_message,
        )


class NationalityListAPIView(ListAPIView):
    queryset = Nationality.objects.all()
    serializer_class = NationalitySerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'nationality_code': item.get('nationality_code'),
                            'nationality_name': item.get('nationality_name')

                        })
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='nationalitylist',
            message=error_message,
        )


class CountryListAPIView(ListAPIView):
    queryset = Country.objects.all()
    serializer_class = CountrySerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'country_code': item.get('country_code'),
                            'country_name': item.get('country_name')

                        })
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='countrylist',
            message=error_message,
        )


class StateListAPIView(ListAPIView):
    queryset = State.objects.all()
    serializer_class = StateSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:
                        country_id = item.get('country_id')
                        countryInstance = Country.objects.get(id=country_id)

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'country_code': countryInstance.country_code,
                            'state_code': item.get('state_code'),
                            'state_name': item.get('state_name')

                        })
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='findstatelist',
            message=error_message,
        )


class CityListAPIView(ListAPIView):
    queryset = City.objects.all()
    serializer_class = CitySerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:
                        # Get country ID
                        country_id = item.get('country_id')
                        countryInstance = Country.objects.get(id=country_id)

                        # Get state ID
                        state_id = item.get('state_id')
                        stateInstance = State.objects.get(id=state_id)

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'cityname': item.get('city_name'),
                            'countryId': country_id,
                            'countrycode': countryInstance.country_code,
                            'stateId': state_id,
                            'statecode': stateInstance.state_code

                        })
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='findcitylist',
            message=error_message,
        )


class GetSTATECOUNTRYBASEDCITYDetailView(RetrieveAPIView):
    queryset = City.objects.all()
    serializer_class = CitySerializer

    def retrieve(self, request, *args, **kwargs):
        try:
            instance = self.get_object()

            if instance:
                # Get state Id
                stateId = instance.state_id.id
                # Get state Instance
                stateInstance = State.objects.get(id=stateId)

                # Get country Id
                countryId = instance.country_id.id

                # Get country Instance
                countryInstance = Country.objects.get(id=countryId)

                data = {
                    'id': instance.id,
                    'cityname': instance.city_name,
                    'statecode': stateInstance.state_code,
                    'countrycode': countryInstance.country_code

                }
                return Response(data, status=status.HTTP_200_OK)
        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='GetIndividualCityRecord',

            message=error_message,

        )


class ProfessionListAPIView(ListAPIView):
    queryset = Profession.objects.all()
    serializer_class = ProfessionSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'profession_code': item.get('profession_code'),
                            'profession_description': item.get('profession_description')

                        })
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='findprofessionlist',
            message=error_message,
        )


class DocumentListAPIView(ListAPIView):
    queryset = Document.objects.all()
    serializer_class = DocumentTypeSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'document_code': item.get('document_code'),
                            'document_desc': item.get('document_desc')

                        })
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='finddocumentlist',
            message=error_message,
        )


class GetFilteredFeeStructureListAPIView(ListAPIView):
    serializer_class = FeeStructureMasterSerializer

    # def get_queryset(self):
    #     course_id = self.kwargs.get('class_id')
    #     academicYearId = self.kwargs.get('academic_year_id')
    #     organization= self.kwargs.get('organization')
    #     branchId = self.kwargs.get('branch_id')

    # return FeeStructureMaster.objects.filter(
    #     academic_year_id=academicYearId,
    #     organization=organization,
    #     branch_id=branchId,
    #     is_active=True
    # )

    # if course_id < 1:
    #     return FeeStructureMaster.objects.filter(
    #         academic_year_id=academicYearId,
    #         organization=organization,
    #         branch_id=branchId,
    #         is_active=True
    #     )
    #
    # elif course_id > 0:
    #     return FeeStructureMaster.objects.filter(
    #         class_id=course_id,
    #         academic_year_id=academicYearId,
    #         organization=organization,
    #         branch_id=branchId,
    #         is_active=True
    #     )

    def list(self, request, *args, **kwargs):
        try:
            # response = super().list(request, *args, **kwargs)
            # resdata = response.data
            course_id = request.query_params.get('course_id')
            academic_year_id = request.query_params.get('academic_year_id')
            organization_id = request.query_params.get('organization_id')
            # branchId = request.query_params.get('branch_id')
            category_id = request.query_params.get('category_id')

            resdata = []
            if course_id and not category_id:
                if int(course_id) < 1:
                    resdata = FeeStructureMaster.objects.filter(
                        academic_year=academic_year_id,
                        organization=organization_id,
                        # branch_id=branchId,
                        is_active=True
                    )
                elif int(course_id) > 0:
                    resdata = FeeStructureMaster.objects.filter(
                        course=course_id,
                        academic_year=academic_year_id,
                        organization=organization_id,
                        # branch_id=branchId,
                        is_active=True
                    )
            if category_id and not course_id:
                resdata = FeeStructureMaster.objects.filter(
                    category_code=category_id,
                    academic_year_id=academic_year_id,
                    organization=organization_id,
                    # branch_id=branchId,
                    is_active=True
                )

            if category_id and course_id:
                resdata = FeeStructureMaster.objects.filter(
                    course_id=course_id,
                    category_code=category_id,
                    academic_year_id=academic_year_id,
                    organization=organization_id,
                    # branch_id=branchId,
                    is_active=True
                )

            if resdata:
                responsedata = []
                for item in resdata:
                    fee_structure_code = item.fee_structure_code
                    fee_structure_description = item.fee_structure_description.upper()

                    if fee_structure_code.find('ADHOC') != -1 or fee_structure_description.find('ADHOC') != -1:
                        continue

                    # Prepare the custom response data
                    responsedata.append({
                        'id': item.id,
                        'fee_structure_code': item.fee_structure_code,
                        'fee_structure_description': item.fee_structure_description

                    })

                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='findfeestructuretlist',
            message=error_message,

        )


class LanguageListAPIView(ListAPIView):
    queryset = Language.objects.all()
    serializer_class = LanguageSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'language_code': item.get('language_code'),
                            'language_desc': item.get('language_desc')

                        })
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='languagelist',
            message=error_message,
        )


class MotherTongueListAPIView(ListAPIView):
    queryset = MotherTongue.objects.all()
    serializer_class = MotherTongueSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:
                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'mother_tongue_code': item.get('mother_tongue_code'),
                            'mother_tongue_name': item.get('mother_tongue_name')
                        })
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='mothertong uelist',
            message=error_message,
        )


class GenderListAPIView(ListAPIView):
    queryset = Gender.objects.all()
    serializer_class = GenderSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'gender_code': item.get('gender_code'),
                            'gender_name': item.get('gender_name')

                        })
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='genderlist',
            message=error_message,
        )


class BloodGroupListAPIView(ListAPIView):
    queryset = Blood.objects.all()
    serializer_class = BloodSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'blood_code': item.get('blood_code'),
                            'blood_name': item.get('blood_name')

                        })
                    else:
                        continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='bloodlist',
            message=error_message,
        )


class StudentPromotionCreateAPI(CreateAPIView):
    queryset = StudentCourse.objects.all()
    serializer_class = StudentPromotionSerializer

    def create(self, request, *args, **kwargs):
        try:
            with transaction.atomic():
                # Validate and save data
                serializer = self.get_serializer(data=request.data)
                serializer.is_valid(raise_exception=True)

                # Get validate Data
                organization_id = serializer.validated_data.get('organization_id')
                branch_id = serializer.validated_data.get('branch_id')
                batch_id = serializer.validated_data.get('batch_id')
                course_id = serializer.validated_data.get('course_id')
                department_id = serializer.validated_data.get('department_id')
                # academic_year_id = serializer.validated_data.get('academic_year_id')
                next_academic_year_id = serializer.validated_data.get('next_academic_year_id')
                # semester_id = serializer.validated_data.get('semester_id')
                next_semester_id = serializer.validated_data.get('next_semester_id')
                # section_id = serializer.validated_data.get('section_id')
                next_section_id = serializer.validated_data.get('next_section_id')
                student_id = serializer.validated_data.get('student_id')
                student_status = serializer.validated_data.get('student_status')
                created_by = serializer.validated_data.get('created_by')
                # student_details = serializer.validated_data.get('student_details')

                # print(course_id,section_id,academicyearId,NextacademicyearId,studentId,organization,branchId,studentStatus,updated_by)

                # Get Course Instance
                organizationInstance = Organization.objects.get(id=organization_id)
                branchInstance = Branch.objects.get(id=branch_id)
                batchInstance = Batch.objects.get(id=batch_id)
                courseInstance = Course.objects.get(id=course_id)
                departmentInstance = Department.objects.get(id=department_id)
                # academicInstance = AcademicYear.objects.get(id=next_academic_year_id)
                nextAcademicYearInstance = AcademicYear.objects.get(id=next_academic_year_id)
                # semesterInstance = Semester.objects.get(id=semester_id)
                nextSemesterInstance = Semester.objects.get(id=next_semester_id)
                nextSectionInstance = Section.objects.get(id=next_section_id)
                # sectionInstance = Section.objects.get(id=section_id)

                # print(CourseInstance)
                # Get Course Instance

                # print(sectionInstance)
                # # Get organization Instance
                # organizationInstance = Organization.objects.get(id=organization)
                #
                # # Get Branch Instance
                # branchInstance = Branches.objects.get(id=branchId)

                # Get Academic Year Instance

                # print(academicInstance)

                for stu in student_id:

                    try:
                        RegisterstudentInstance = StudentRegistration.objects.get(id=stu, is_active=True)
                    except RegisterstudentInstance.DoesNotExist:
                        return Response({"message": f"student registration record not found with id - {stu}"})

                    if student_status == 'FAIL':
                        return Response({
                                            "message": f"Student - {RegisterstudentInstance.first_name + RegisterstudentInstance.middle_name + RegisterstudentInstance.last_name} with student_id - {stu} is failed in current semester. !!!  "})

                    # Check if a similar record already exists
                    existing_record = StudentCourse.objects.filter(
                        organization=organizationInstance,
                        student=RegisterstudentInstance,
                        batch=batchInstance,
                        academic_year=nextAcademicYearInstance,
                        course=courseInstance,
                        department=departmentInstance,
                        semester=nextSemesterInstance,
                        section=nextSectionInstance,
                        is_active=True
                    ).exists()

                    if existing_record:
                        return Response(
                            {'message': f'this student already promoted!!.'},
                            status=status.HTTP_400_BAD_REQUEST
                        )
                    # Get all active student course instances for the student
                    try:
                        student_instances = StudentCourse.objects.get(student=RegisterstudentInstance, is_active=True)
                        if not student_instances:
                            return Response({
                                                "message": f"student course record not found with student_id - {RegisterstudentInstance.id}  !!!"},
                                            status=status.HTTP_400_BAD_REQUEST)
                    except StudentCourse.DoesNotExist:
                        return Response({"message": "student course record not found !!!"},
                                        status=status.HTTP_204_NO_CONTENT)
                    enrollment_no = student_instances.enrollment_no
                    house_instance = student_instances.house

                    fee_group_instance = student_instances.fee_group
                    fee_applied_from_instance = student_instances.fee_applied_from
                    if student_instances.transport_availed:
                        transport_availed = student_instances.transport_availed
                        choice_semester = student_instances.choice_semester
                    else:
                        transport_availed = False
                        choice_semester = ""


                    route_id = student_instances.route_id
                    if student_instances.hostel_availed:
                        hostel_availed = student_instances.hostel_availed
                        hostel_choice_semester = student_instances.hostel_choice_semester
                    else:
                        hostel_availed = False
                        hostel_choice_semester = ""

                    # Deactivate all active student class records
                    student_instances.is_active = False
                    student_instances.student_status = "Inactive"
                    student_instances.save()
                    # last_student = StudentRegistration.objects.filter(organization=organizationInstance.id,batch=batchInstance.id).last()
                    # enrollment_no = int(last_student.enrollment_no) + 1 if last_student else 1001
                    StudentCourse.objects.create(
                        organization=organizationInstance,
                        branch=branchInstance,
                        batch=batchInstance,
                        academic_year=nextAcademicYearInstance,
                        student=RegisterstudentInstance,
                        course=courseInstance,
                        department=departmentInstance,
                        semester=nextSemesterInstance,
                        section=nextSectionInstance,
                        fee_group=fee_group_instance,
                        fee_applied_from=fee_applied_from_instance,
                        # enrollment_no=RegisterstudentInstance.enrollment_no,
                        enrollment_no=enrollment_no,
                        # house=student_instances.first().house if student_instances.exists() else "",
                        house=house_instance,
                        transport_availed=transport_availed,
                        choice_semester=choice_semester,
                        hostel_availed = hostel_availed,
                        hostel_choice_semester = hostel_choice_semester,
                        # hostel_availed = student_details.get('hostel_availed'),
                        # hostel_choice_semester = student_details.get('hostel_choice_semester'),
                        route_id=route_id,
                        student_status=student_status,
                        is_promoted=True,
                        # student_status= 'Inactive',
                        is_active=False,
                        created_by=created_by,
                        updated_by=created_by
                    )
                    RegisterstudentInstance.is_active = False
                    RegisterstudentInstance.save()

                return Response({'message': 'successfully sent to promotion confirmation!!', },
                                status=status.HTTP_200_OK)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='StudentPromotion',
            message=error_message,
        )


class UtilityGroupMixin:
    def process_fee_group(self, fee_applied_from, fee_group, student_instance):
        try:
            # Start a new atomic transaction for the fee group processing
            with transaction.atomic():
                # print(fee_group, type(fee_group))
                # print(student_instance, type(student_instance))
                # Process fee group logic here
                FeeStructuremasterInstance = FeeStructureMaster.objects.get(id=fee_group)

                # print(FeeStructuremasterInstance,type(FeeStructuremasterInstance))

                # print(feeStructureMasterInstance)
                # fee_group_id = feeStructureMasterInstance.id
                # print(fee_group_id,type(fee_group_id))

                # Get FeeStructureDetail record
                fee_structure_details_instance = FeeStructureDetail.objects.filter(
                    fee_structure_master=FeeStructuremasterInstance)

                # print(fee_structure_details_instance)

                if not fee_structure_details_instance:
                    # raise ValueError("No fee structure details found for the provided fee group.")
                    return Response({'message': 'No fee structure details found for the provided fee group'})

                # print(fee_structure_details_instance)

                # Process fee structure details
                for details in fee_structure_details_instance:
                    element_frequency_id = details.element_frequency.id
                    # if element_frequency_id == 1:

                    # print(element_frequency_id)

                    # Get frequency Instance
                    # Only filter by ID - the extra filters cause failures when there are FK mismatches
                    frequency_instance = FeeFrequency.objects.get(id=element_frequency_id)
                    # print(frequency_instance)

                    # Get frequency period
                    frequency_period = frequency_instance.frequency_period

                    if frequency_period > 0 and frequency_period < 12:
                        # for item in range(1, frequency_period+1):
                        for item in range(1, frequency_period + 1):

                            if item == 1:
                                semester = details.semester_1

                            elif item == 2:
                                semester = details.semester_2

                            elif item == 3:
                                semester = details.semester_3

                            elif item == 4:
                                semester = details.semester_4

                            elif item == 5:
                                semester = details.semester_5

                            elif item == 6:
                                semester = details.semester_6

                            elif item == 7:
                                semester = details.semester_7

                            elif item == 8:
                                semester = details.semester_8

                            try:
                                fee_applied_from_instance = Semester.objects.get(id=details.semester_1, is_active=True)
                                semester_instance = Semester.objects.get(id=semester, is_active=True)
                            except Semester.DoesNotExist:
                                return Response({"message": "semester record not found !!!"},
                                                status=status.HTTP_204_NO_CONTENT)
                            studentCourseInstance = StudentCourse.objects.get(student=student_instance.id,
                                                                              is_active=True)
                            # Try creating the student fee details record
                            student_fee_details_instance = StudentFeeDetail.objects.create(
                                student=student_instance,
                                student_course=studentCourseInstance,
                                fee_group=FeeStructuremasterInstance,
                                fee_structure_details=details,
                                element_name=details.element_type.element_name,
                                fee_applied_from=fee_applied_from_instance,
                                semester=semester_instance,
                                paid='N',
                                academic_year=student_instance.academic_year,
                                organization=FeeStructuremasterInstance.organization,
                                department=FeeStructuremasterInstance.department,
                                branch=FeeStructuremasterInstance.branch,
                                multiplying_factor=1,
                                element_amount=details.amount,
                                total_element_period_amount=details.amount,
                                paid_amount=0,
                                created_by=student_instance.created_by,
                                updated_by=student_instance.created_by
                            )

                    else:
                        semester_instance = Semester.objects.filter(
                            organization=student_instance.organization,
                            branch=student_instance.branch,
                            batch=student_instance.batch,
                            course=student_instance.course,
                            department=student_instance.department,

                        )
                        # period_times = len(period_instance)

                        studentCourseInstance = StudentCourse.objects.get(student=student_instance, is_active=True)

                        # for item in range(period_times):
                        # period_month= period_instance.period_name
                        for semester in semester_instance:
                            # period_month = period.id

                            # Try creating the student fee details record
                            student_fee_details_instance = StudentFeeDetail.objects.create(
                                student=student_instance,
                                student_course=studentCourseInstance,
                                fee_group=FeeStructuremasterInstance,
                                fee_structure_details=details,
                                element_name=details.element_type.element_name,
                                fee_applied_from=semester_instance[0],
                                semester=semester,
                                paid='N',
                                academic_year=student_instance.academic_year,
                                organization=student_instance.organization,
                                branch=student_instance.branch,
                                department=student_instance.department,
                                multiplying_factor=1,
                                element_amount=details.amount,
                                total_element_period_amount=details.amount,
                                paid_amount=0,
                                created_by=student_instance.created_by,
                                updated_by=student_instance.created_by
                            )

                return {'success': "Fee details processed successfully."}

        except Exception as e:
            # Log the error with details for debugging
            import traceback
            error_details = {
                'student_id': student_instance.id,
                'admission_no': student_instance.admission_no,
                'fee_group': fee_group,
                'error': str(e),
                'traceback': traceback.format_exc()
            }
            print(f" ERROR in process_fee_group for student {student_instance.admission_no}: {e}")
            print(f"Full traceback: {traceback.format_exc()}")
            
            # Still return success but with a warning flag
            return {'success': False, 'error': str(e), 'details': error_details}

    def ProcessFeeTransport_month(self, routedetailsId, amount, sorted_semester_ids, student_instance):
        try:
            # Get route Instance
            routeDetails_instance = RouteDetail.objects.get(id=routedetailsId)

            # print(routeDetails_instance)

            # Get pickup poin Id
            pickup_point_id = routeDetails_instance.pickup_point.id
            # print(pickup_pointId)

            # get Route Master Id
            routemasterId = routeDetails_instance.route_master.id
            # print(routemasterId)

            # Get route Instance
            TransportRouteMasterInstance = RouteMaster.objects.get(id=routemasterId)
            # print(TransportRouteMasterInstance)

            # Get pickup Instance
            pickup_point_instance = PickupPoint.objects.get(id=pickup_point_id)

            if amount > 0:
                # Insert data into database according month selected
                studentCourseInstance = StudentCourse.objects.get(student=student_instance.id, is_active=True)
                for item in sorted_semester_ids:
                    semesterInstance = Semester.objects.get(id=item)
                    student_fee_details_instance = StudentFeeDetail.objects.create(
                        student=student_instance,
                        student_course=studentCourseInstance,
                        element_name='Transport Fees',  # TransportRouteMasterInstance.transport_name,
                        # fee_group = ,
                        # fee_structure_details=details,
                        fee_applied_from=semesterInstance,
                        paid='N',
                        academic_year=student_instance.academic_year,
                        organization=pickup_point_instance.organization,
                        branch=student_instance.branch,
                        department=student_instance.department,
                        multiplying_factor=1,
                        element_amount=amount,
                        total_element_period_amount=pickup_point_instance.amount,
                        paid_amount=0,
                        created_by=student_instance.created_by,
                        updated_by=student_instance.created_by
                    )

            else:
                # Insert data into database according month selected

                studentCourseInstance = StudentCourse.objects.get(student=student_instance.id, is_active=True)

                for item in sorted_semester_ids:
                    semesterInstance = Semester.objects.get(id=item)
                    student_fee_details_instance = StudentFeeDetail.objects.create(
                        student=student_instance,
                        student_course=studentCourseInstance,
                        # fee_group= ,
                        # fee_structure_details=details,
                        # element_name=TransportRouteMasterInstance.transport_name,
                        element_name="Transport Fees",
                        fee_applied_from=semesterInstance,
                        semester=semesterInstance,
                        paid='N',
                        academic_year=student_instance.academic_year,
                        organization=pickup_point_instance.organization,
                        branch=student_instance.branch,
                        # batch=student_instance.batch,
                        department=student_instance.department,
                        multiplying_factor=1,
                        element_amount=pickup_point_instance.amount,
                        total_element_period_amount=pickup_point_instance.amount,
                        paid_amount=0,
                        created_by=student_instance.created_by,
                        updated_by=student_instance.created_by
                    )

            return {'success': "Transport processed successfully."}



        except Exception as e:
            error_message = f"Error processing Transport Availed: {str(e)}"
            # Raise an exception to be caught in the create method
            raise ValueError(error_message)

    def addressDetailsProcess(self, addressDetail, student_instance):

        try:
            present_address = addressDetail.get('present_address')
            present_pincode = addressDetail.get('present_pincode')
            present_city = addressDetail.get('present_city')
            present_state = addressDetail.get('present_state')
            present_country = addressDetail.get('present_country')
            present_phone_number = addressDetail.get('present_phone_number')
            permanent_address = addressDetail.get('permanent_address')
            permanent_pincode = addressDetail.get('permanent_pincode')
            permanent_city = addressDetail.get('permanent_city')
            permanent_state = addressDetail.get('permanent_state')
            permanent_country = addressDetail.get('permanent_country')
            permanent_phone_number = addressDetail.get('permanent_phone_number')
            # created_by = student_instance.get('created_by')

            #
            #         # Check this record already exist or not
            if Address.objects.filter(
                    reference_id=student_instance.id,
                    usertype='STUDENT',
                    is_active=True

            ).exists():
                return Response({'message': 'student address already added'},
                                status=status.HTTP_400_BAD_REQUEST)
            #         # create fee details & save
            student_address_instance = Address.objects.create(
                reference_id=student_instance.id,
                usertype='STUDENT',
                present_address=present_address,
                present_pincode=present_pincode,
                present_city=present_city,
                present_state=present_state,
                present_country=present_country,
                present_phone_number=present_phone_number,
                permanent_address=permanent_address,
                permanent_pincode=permanent_pincode,
                permanent_city=permanent_city,
                permanent_state=permanent_state,
                permanent_country=permanent_country,
                permanent_phone_number=permanent_phone_number,
                created_by=student_instance.created_by,
                updated_by=student_instance.created_by
            )

            student_address_instance.save()

            # Prepare the response data
            response_data = {
                'message': 'Added Successfully!',
                'data': {
                    'id': student_address_instance.id,
                    'reference_id': student_address_instance.reference_id,
                    'usertype': student_address_instance.usertype,
                    'present_address': student_address_instance.present_address,
                    'present_pincode': student_address_instance.present_pincode,
                    'present_city': student_address_instance.present_city,
                    'present_state': student_address_instance.present_state,
                    'present_country': student_address_instance.present_country,
                    'present_phone_number': student_address_instance.present_phone_number,
                    'permanent_address': student_address_instance.permanent_address,
                    'permanent_pincode': student_address_instance.permanent_pincode,
                    'permanent_city': student_address_instance.permanent_city,
                    'permanent_state': student_address_instance.permanent_state,
                    'permanent_country': student_address_instance.permanent_country,
                    'permanent_phone_number': student_address_instance.permanent_phone_number,

                }
            }

            return Response({'message': 'success', 'data': response_data}, status=status.HTTP_200_OK)

        except Exception as e:
            error_message = f"Error processing address: {str(e)}"
            # Raise an exception to be caught in the create method
            raise ValueError(error_message)

    def sibilingsProcess(self, sibilingDetail, student_instance):
        try:
            # Iterate through the sibling details
            for sibling in sibilingDetail:
                sibling_detail = sibling.get('sibling')
                # print(sibling_id)

                # Check if the combination of student_id and sibling_id already exists
                if SiblingDetail.objects.filter(student=student_instance, sibling=sibling_detail,
                                                is_active=True).exists():
                    return Response({'message': f'This sibling with ID {sibling_detail.id} has already been added.'},
                                    status=status.HTTP_400_BAD_REQUEST)

                # Save the siblings data in the SiblingDetail model
                sibling_instance = SiblingDetail.objects.create(
                    student=student_instance,  # Reference to the student instance
                    sibling=sibling_detail,  # Reference to the sibling
                    created_by=student_instance.created_by,
                    updated_by=student_instance.created_by
                )

            return Response({'message': 'Siblings added successfully!'}, status=status.HTTP_200_OK)

        except Exception as e:
            error_message = f"Error processing siblings: {str(e)}"
            raise ValueError(error_message)

    def EmergencyContactProcess(self, emegencyContact, student_instance):

        try:
            # Call siblings processing function if list is not empty
            for emergency in emegencyContact:
                name = emergency.get('name').upper()
                relationship = emergency.get('relationship').upper()
                mobile_number = emergency.get('mobile_number')
                remark = emergency.get('remark')

                # Check if the combination of data exist or not
                # if StudentEmergencyContact.objects.filter(name=name, relationship=relationship,mobile_number=mobile_number,
                #                                   is_active=True).exists():
                #     return Response({'message': 'This Emergency contact has already been added.'},
                #                     status=status.HTTP_400_BAD_REQUEST)

                # Save the Emergency contact on db
                StudentEmergencyContactData = StudentEmergencyContact.objects.create(
                    student=student_instance,
                    name=name,
                    relationship=relationship,
                    mobile_number=mobile_number,
                    remark=remark,
                    created_by=student_instance.created_by,
                    updated_by=student_instance.created_by
                )

            return Response({'message': 'Emergency contact added successfully!!'}, status=status.HTTP_200_OK)

        except Exception as e:

            error_message = f"Error processing Emergency contact: {str(e)}"
            # Raise an exception to be caught in the create method
            raise ValueError(error_message)

    def authorizedpickupProcess(self, authorizedpickup, student_instance):

        try:
            # Call siblings processing function if list is not empty
            for authorized in authorizedpickup:
                name = authorized.get('name').upper()
                relationship = authorized.get('relationship').upper()
                mobile_number = authorized.get('mobile_number')
                remark = authorized.get('remark')

                # Check if the combination of data exist or not
                # if AuthorisedPickup.objects.filter(name=name, relationship=relationship,mobile_number=mobile_number,
                #                                   is_active=True).exists():
                #     return Response({'message': 'This Authorized pickup data has already been added.'},
                #                     status=status.HTTP_400_BAD_REQUEST)

                # Save the Emergency contact on db
                AuthorizedPickupData = AuthorisedPickup.objects.create(
                    student=student_instance,
                    name=name,
                    relationship=relationship,
                    mobile_number=mobile_number,
                    remark=remark,
                    created_by=student_instance.created_by,
                    updated_by=student_instance.created_by
                )

            return Response({'message': 'Authorized pickup data added successfully!!'}, status=status.HTTP_200_OK)

        except Exception as e:

            error_message = f"Error processing Authorized pickup data: {str(e)}"
            # Raise an exception to be caught in the create method
            raise ValueError(error_message)

    def documentsDetailsProcess(self, request, documentsDetails, instance, document_files):
        try:
            count = 0
            for documents in documentsDetails:
                document_no = documents.get('document_no')
                document_type = documents.get('document_type')

                # Skip empty/invalid rows to prevent creating junk records
                if not document_no and not document_type:
                    continue

                if count < len(document_files):
                    document_pic = document_files[count]
                else:
                    document_pic = None
                start_from = documents.get('start_from')
                end_to = documents.get('end_to')

                # Check if the combination of data exist or not
                if StudentDocument.objects.filter(document_no=document_no, document_type=document_type,
                                                  is_active=True).exists():
                    raise ValueError(f"This Document data with document_no {document_no} has already been added.")

                # Save the Emergency contact on db
                StudentDocumentData = StudentDocument.objects.create(
                    student=instance,
                    document_no=document_no,
                    document_type=document_type,
                    document_pic=document_pic,
                    document_url="",
                    start_from=start_from,
                    end_to=end_to,
                    created_by=instance.created_by,
                    updated_by=instance.created_by
                )
                # Only build the URL if a document file was actually uploaded
                if document_pic:
                    StudentDocumentData.document_url = request.build_absolute_uri(StudentDocumentData.document_pic.url)
                    StudentDocumentData.save()
                count = count + 1
                # if document_files:
                #     for document_file in document_files:
                #         i=0
                #         StudentDocumentData.document_pic[i].save(document_file.name, document_file)
                #         StudentDocumentData.save()
                #         i = i+1
                #
                # serializer = self.get_serializer(data=documentsDetails)
                # serializer.is_valid(raise_exception=True)
                # response_data = serializer
                # if StudentDocumentData.document_pic:
                #     documentsDetails[0]['document_pic'] = request.build_absolute_uri(StudentDocumentData.document_pic.url)
                #     response.data()
                # else:
                #     documentsDetails[0]['document_pic'] = None
            return Response({'message': 'Document data added successfully!!', }, status=status.HTTP_200_OK)


        except Exception as e:

            error_message = f"Error processing document data: {str(e)}"
            # Raise an exception to be caught in the create method
            raise ValueError(error_message)

    def previousEducationDetailsProcess(self, previousEducationDetails, student_instance):
        try:
            for edudetails in previousEducationDetails:
                name_of_institution = edudetails.get('name_of_institution')
                location = edudetails.get('location')
                course_completed = edudetails.get('course_completed')
                year_from = edudetails.get('year_from')
                year_to = edudetails.get('year_to')
                language_of_instruction = edudetails.get('language_of_instruction')
                result = edudetails.get('result')

                # Check if the combination of data exist or not
                # if StudentPreviousEducation.objects.filter(name_of_institution=name_of_institution, location=location,course_completed=course_completed,year_from=year_from,year_to=year_to,language_of_instruction=language_of_instruction,result=result,
                #                                    is_active=True).exists():
                #     return Response({'message': 'This Previous Education has already been added.'},
                #                     status=status.HTTP_400_BAD_REQUEST)

                # Save the Emergency contact on db
                StudentDocumentData = StudentPreviousEducation.objects.create(
                    student=student_instance,
                    name_of_institution=name_of_institution,
                    location=location,
                    course_completed=course_completed,
                    year_from=year_from,
                    year_to=year_to,
                    language_of_instruction=language_of_instruction,
                    result=result,
                    created_by=student_instance.created_by,
                    updated_by=student_instance.created_by
                )
                # print('Previous Education Data added successfully!!')

            return Response({'message': 'Previous Education Data added successfully!!'}, status=status.HTTP_200_OK)


        except Exception as e:

            error_message = f"Error processing document data: {str(e)}"
            # Raise an exception to be caught in the create method
            raise ValueError(error_message)


from rest_framework.parsers import MultiPartParser, FormParser, JSONParser


# ----Student Registration Create----#
class StudentRegistrationCreate(CreateAPIView, UtilityGroupMixin):
    # permission_classes = [IsAuthenticated]
    # queryset = StudentRegistration.objects.all()
    serializer_class = StudentRegistrationSerializer
    parser_classes = [MultiPartParser, FormParser, JSONParser]  # Supports JSON & Multipart

    @transaction.atomic
    def create(self, request, *args, **kwargs):
        try:
            # Start a new atomic transaction
            with transaction.atomic():
                if request.content_type.startswith('multipart/form-data'):
                    data = request.POST.dict()  # Convert QueryDict to a mutable dictionary
                    # data = request.data['data']
                    data['student_basic_detail'] = json.loads(
                        data.get('student_basic_detail', '{}'))  # Convert string to dict
                    data['fee_detail'] = json.loads(data.get('fee_detail', '{}'))  # Convert string to list
                    data['transport_detail'] = json.loads(data.get('transport_detail', '{}'))  # Convert string to list
                    data['address_detail'] = json.loads(data.get('address_detail', '{}'))  # Convert string to list
                    data['sibling_detail'] = json.loads(data.get('sibling_detail', '[]'))  # Convert string to list
                    data['emergency_contact'] = json.loads(
                        data.get('emergency_contact', '[]'))  # Convert string to list
                    data['authorized_pickup'] = json.loads(
                        data.get('authorized_pickup', '[]'))  # Convert string to list
                    data['document_detail'] = json.loads(data.get('document_detail', '[]'))  # Convert string to list
                    data['previous_education_detail'] = json.loads(
                        data.get('previous_education_detail', '[]'))  # Convert string to list

                    if 'profile_pic' in request.FILES:
                        profile_pic = request.FILES['profile_pic']

                    # document_files = []
                    # for i in range(len(request.FILES.getlist('document_pic'))):
                    #     if request.FILES.getlist('document_pic')[i]:
                    #         document_files.append(request.FILES.getlist('document_pic')[i])
                    document_files = []
                    for item, item_obj in request.FILES.items():
                        if item != 'profile_pic':
                            document_files.append(item_obj)

                try:
                    serializer = self.get_serializer(data=data)
                    serializer.is_valid(raise_exception=True)
                except ValidationError as e:
                    return Response({"message": e.detail}, status=status.HTTP_400_BAD_REQUEST)
                except Exception as e:
                    print(e)
                    # return Response({"message":str(e)}, status.HTTP_400_BAD_REQUEST)

                # Get Serialized data

                student_basic_detail = serializer.validated_data.get('student_basic_detail')
                fee_detail = serializer.validated_data.get('fee_detail')
                transport_detail = serializer.validated_data.get('transport_detail')
                address_detail = serializer.validated_data.get('address_detail')
                sibling_detail = serializer.validated_data.get('sibling_detail')
                emergency_contact = serializer.validated_data.get('emergency_contact')
                authorized_pickup = serializer.validated_data.get('authorized_pickup')
                document_detail = serializer.validated_data.get('document_detail')
                previous_education_detail = serializer.validated_data.get('previous_education_detail')

                # Ensure that both student and fee details are provided
                if not student_basic_detail and not fee_detail:
                    return Response({'message': 'Please fill all the mandatory field of Student Tab & Fee Tab.'},
                                    status=status.HTTP_400_BAD_REQUEST)

                # Get student Details data
                # Get student Details data
                # Generate admission_no if it's not provided
                academic_year = student_basic_detail.get('academic_year')
                admission_no = student_basic_detail.get('admission_no')
                registration_no = student_basic_detail.get('registration_no')
                barcode = student_basic_detail.get('barcode')
                course = student_basic_detail.get('course')
                section = student_basic_detail.get('section')
                college_admission_no = student_basic_detail.get('college_admission_no')
                user_name = student_basic_detail.get('user_name')
                email = student_basic_detail.get('email')
                enrollment_no = student_basic_detail.get('enrollment_no')
                student_aadhaar_no = student_basic_detail.get('student_aadhaar_no')
                primary_guardian = student_basic_detail.get('primary_guardian')
                student_status = student_basic_detail.get('student_status')
                first_name = student_basic_detail.get('first_name')
                last_name = student_basic_detail.get('last_name')
                date_of_birth = student_basic_detail.get('date_of_birth')
                profile_pic = student_basic_detail.get('profile_pic')

                # Handle student aadhar no & email & registration_no
                if registration_no:
                    if StudentRegistration.objects.filter(registration_no=registration_no).exists():
                        return Response(
                            {'message': 'duplicate registration number, required unique registration number'},
                            status=status.HTTP_400_BAD_REQUEST)
                    else:
                        student_basic_detail['registration_no'] = registration_no
                else:
                    student_basic_detail['registration_no'] = ''
                # elif not registration_no or registration_no == '':
                #     last_student = StudentRegistration.objects.order_by('registration_no').last()
                #     registration_no = int(last_student.admission_no) + 1 if last_student else 1001
                #     student_basic_detail['registration_no'] = registration_no  # Store generated registration_no

                if not student_aadhaar_no or student_aadhaar_no == '':
                    student_aadhaar_no = None
                    student_basic_detail['student_aadhaar_no'] = student_aadhaar_no

                if not email or email == '':
                    email = None
                    student_basic_detail['email'] = email

                if not primary_guardian or primary_guardian == '':
                    primary_guardian = "FATHER"
                    student_basic_detail['primary_guardian'] = primary_guardian

                if not student_status or student_status == '':
                    student_status = "ACTIVE"
                    student_basic_detail['student_status'] = student_status

                if admission_no:
                    if StudentRegistration.objects.filter(admission_no=admission_no).exists():
                        return Response({'message': 'duplicate admission number, required unique admission number'},
                                        status=status.HTTP_400_BAD_REQUEST)
                    else:
                        student_basic_detail['admission_no'] = admission_no
                elif not admission_no or admission_no == '':
                    last_student = StudentRegistration.objects.order_by('admission_no').last()
                    admission_no = (int(last_student.admission_no) + 1) if last_student else 1001
                    student_basic_detail['admission_no'] = admission_no  # Store generated admission_no

                # if enrollment_no:
                #     last_student = StudentCourse.objects.filter(course=course,
                #                                                 section=section, academic_year=academic_year).last()
                #
                #     if StudentCourse.objects.filter(course=course,
                #                                     section=section, enrollment_no=enrollment_no,
                #                                     academic_year=academic_year).exists():
                #         return Response({'message': 'duplicate enrollment number, required unique enrollment number'},
                #                         status=status.HTTP_400_BAD_REQUEST)
                #     elif enrollment_no != (last_student.enrollment_no + 1):
                #         return Response({'message': 'duplicate enrollment number, required unique enrollment number'},
                #                         status=status.HTTP_400_BAD_REQUEST)
                #     else:
                #         student_basic_detail['enrollment_no'] = enrollment_no
                # elif not enrollment_no or enrollment_no == '':
                #     last_student = StudentRegistration.objects.filter(course=course,
                #                                                       section=section,
                #                                                       academic_year=academic_year).last()
                #     # last_student = Student_Class.objects.order_by('enrollment_no').last()
                #     # try:
                #     enrollment_no = (int(last_student.enrollment_no) + 1) if last_student else 1001
                #     student_basic_detail['enrollment_no'] = enrollment_no  # Store generated admission_no

                if barcode:
                    if StudentRegistration.objects.filter(barcode=barcode).exists():
                        return Response({'message': 'duplicate barcode, required unique barcode'},
                                        status=status.HTTP_400_BAD_REQUEST)
                    else:
                        student_basic_detail['barcode'] = barcode
                else:
                    student_basic_detail['barcode'] = ''
                # elif not barcode or barcode == '':
                #     barcode = admission_no
                #     student_basic_detail['barcode'] = barcode

                if not college_admission_no:
                    student_basic_detail['college_admission_no'] = admission_no

                if user_name:
                    if StudentRegistration.objects.filter(user_name=user_name).exists():
                        return Response({'message': 'duplicate user_name, required unique user_name'},
                                        status=status.HTTP_400_BAD_REQUEST)
                    else:
                        student_basic_detail['username'] = user_name
                elif not user_name or user_name == '':
                    username_generated = first_name + str(admission_no)
                    student_basic_detail['user_name'] = username_generated
                    # if not college_admission_no:
                    #     studentBasicDetails['username'] = admission_no
                    # else:
                    #     studentBasicDetails['username'] = college_admission_no

                # if not admission_no or admission_no == '':
                #     last_student = REGISTRATIONBYSTUDENT.objects.order_by('admission_no').last()
                #     admission_no = (last_student.admission_no + 1) if last_student else 1001
                #     studentBasicDetails['admission_no'] = admission_no  # Store generated admission_no

                # Now proceed to create the student instance
                student_instance = StudentRegistration.objects.create(

                    organization=student_basic_detail['organization'],
                    branch=student_basic_detail['branch'],
                    batch=student_basic_detail['batch'],
                    admission_type=student_basic_detail.get('admission_type', 'Regular'),
                    course=student_basic_detail['course'],
                    department=student_basic_detail['department'],
                    academic_year=student_basic_detail['academic_year'],
                    semester=student_basic_detail['semester'],
                    section=student_basic_detail['section'],
                    admission_no=student_basic_detail['admission_no'],
                    first_name=student_basic_detail['first_name'],
                    middle_name=student_basic_detail.get('middle_name', None),
                    last_name=student_basic_detail.get('last_name', None),
                    # Optional fields - now using .get() with None defaults
                    gender=student_basic_detail.get('gender', None),
                    date_of_admission=student_basic_detail.get('date_of_admission', None),
                    date_of_join=student_basic_detail.get('date_of_join', None),
                    barcode=student_basic_detail.get('barcode', ''),
                    registration_no=student_basic_detail.get('registration_no', ''),
                    college_admission_no=student_basic_detail.get('college_admission_no', None),
                    primary_guardian=student_basic_detail.get('primary_guardian', 'FATHER'),
                    status=student_basic_detail.get('status', 'ACTIVE'),
                    house=student_basic_detail.get('house', None),
                    religion=student_basic_detail.get('religion', None),
                    category=student_basic_detail.get('category', None),
                    blood=student_basic_detail.get('blood', None),
                    nationality=student_basic_detail.get('nationality', None),
                    email=student_basic_detail.get('email', None),
                    date_of_birth=student_basic_detail.get('date_of_birth', None),
                    children_in_family=student_basic_detail.get('children_in_family', None),
                    student_aadhaar_no=student_basic_detail.get('student_aadhaar_no', None),
                    user_name=student_basic_detail['user_name'],
                    remarks=student_basic_detail.get('remarks', None),
                    profile_pic=student_basic_detail.get('profile_pic', None),
                    father_name=student_basic_detail.get('father_name', None),
                    father_profession=student_basic_detail.get('father_profession', None),
                    father_contact_number=student_basic_detail.get('father_contact_number', None),
                    father_email=student_basic_detail.get('father_email', None),
                    father_aadhaar_no=student_basic_detail.get('father_aadhaar_no', None),
                    mother_tongue=student_basic_detail.get('mother_tongue', None),
                    mother_name=student_basic_detail.get('mother_name', None),
                    mother_profession=student_basic_detail.get('mother_profession', None),
                    mother_contact_number=student_basic_detail.get('mother_contact_number', None),
                    mother_email=student_basic_detail.get('mother_email', None),
                    mother_aadhaar_no=student_basic_detail.get('mother_aadhaar_no', None),
                    created_by=student_basic_detail['created_by'],
                    updated_by=student_basic_detail['created_by']
                )
                if profile_pic:
                    student_instance.profile_pic.save(profile_pic.name, profile_pic)
                    student_instance.save()
                # print(feeDetails,type(feeDetails))

                fee_group = fee_detail.get('fee_group')
                fee_applied_from = fee_detail.get('fee_applied_from')

                fee_structure_instance = FeeStructureMaster.objects.get(id=fee_group)
                semesterInstance = Semester.objects.get(id=fee_applied_from)

                # Transport Processing
                if transport_detail and transport_detail.get('transport_availed') is True:
                    choice_semester = transport_detail.get('choice_semester')
                    route_id = transport_detail.get('route_id')
                    route_detail_id = transport_detail.get('route_detail')

                    # Initialize amount to 0 if it's coming from registration
                    amount = 0

                    if choice_semester:
                        # Query periods and sort by sorting_order
                        sorted_semester = Semester.objects.filter(id__in=choice_semester)

                        # Extract sorted period IDs or names (whichever is relevant)
                        sorted_semester_ids = [semester.id for semester in sorted_semester]

                        # Get fee Group

                        # Create the student class entry linked to the student
                        StudentCourse.objects.create(
                            organization=student_instance.organization,
                            student=student_instance,
                            branch=student_instance.branch,
                            batch=student_instance.batch,
                            course=student_instance.course,
                            department=student_instance.department,
                            semester=student_instance.semester,
                            academic_year=student_instance.academic_year,
                            section=student_instance.section,
                            fee_group=fee_structure_instance,
                            fee_applied_from=semesterInstance,  # student_instance.feeappfrom.id,
                            enrollment_no=student_instance.enrollment_no,
                            house=student_instance.house if student_instance.house else House.objects.first(),
                            transport_availed=True,
                            route_id=route_detail_id,
                            choice_semester=sorted_semester_ids,
                            student_status="ACTIVE",
                            created_by=student_instance.created_by,
                            updated_by=student_instance.created_by

                        )
                        # Process Transport Details
                        self.ProcessFeeTransport_month(route_detail_id, amount, sorted_semester_ids, student_instance)
                # Skip transport processing if transportavailed is False
                else:
                    # Create the student class entry linked to the student
                    # if not transportDetails or transportDetails == "":
                    transport_availed = False
                    route_id = None
                    choice_semester = ""
                    if transport_detail:
                        if transport_detail.get('transport_availed') is False:
                            transport_availed = False
                            route_id = transport_detail.get("route_id") if transport_detail.get("route_id") else None
                            choice_semester = transport_detail.get('choice_semester') if transport_detail.get('choice_semester') else ""

                    StudentCourse.objects.create(
                        organization=student_instance.organization,
                        branch=student_instance.branch,
                        academic_year=student_instance.academic_year,
                        student=student_instance,
                        batch=student_instance.batch,
                        course=student_instance.course,
                        department=student_instance.department,
                        semester=student_instance.semester,
                        section=student_instance.section,
                        fee_group=fee_structure_instance,
                        fee_applied_from=semesterInstance,  # student_instance.feeappfrom.id,
                        enrollment_no=student_instance.enrollment_no,
                        house=student_instance.house if student_instance.house else House.objects.first(),
                        transport_availed=transport_availed,
                        route_id=route_id,
                        choice_semester=choice_semester,
                        student_status="ACTIVE",
                        created_by=student_instance.created_by,
                        updated_by=student_instance.created_by

                    )

                # print(feeappfrom)

                # fee_group = feeDetails['feegroup']

                # Call the reusable method for processing fee_group
                self.process_fee_group(fee_applied_from, fee_group, student_instance)

                # Process Address

                if address_detail:
                    self.addressDetailsProcess(address_detail, student_instance)

                # Check if sibilingsDetails has data
                if sibling_detail and len(sibling_detail) > 0:
                    self.sibilingsProcess(sibling_detail, student_instance)

                # check if Emergency contact number

                if emergency_contact and len(emergency_contact) > 0:
                    self.EmergencyContactProcess(emergency_contact, student_instance)
                else:
                    emergencyContact = []

                # check if authorized pickup
                if authorized_pickup and len(authorized_pickup) > 0:
                    self.authorizedpickupProcess(authorized_pickup, student_instance)
                else:
                    authorizedpickup = []
                # check if DocumentDetails
                if document_detail and len(document_detail) > 0 and len(document_files) > 0:
                    self.documentsDetailsProcess(request, document_detail, student_instance, document_files)
                else:
                    documentsDetails = []

                # document_instance = REGISTRATIONBYSTUDENT.objects.create(
                #     document_pic = Student_Document['document_pic'],documentsDetails
                # )
                # if document_file:
                #     document_instance.document_pic.save(document_file.name, document_file)
                #     document_instance.save()

                # check if DocumentDetails
                if previous_education_detail and len(previous_education_detail) > 0:

                    self.previousEducationDetailsProcess(previous_education_detail, student_instance)
                else:
                    previousEducationDetails = []

                # Handle parent_id generation and save parent record
                last_parent = Parent.objects.order_by('parent_id').last()
                parent_id = (last_parent.parent_id + 1) if last_parent else 101

                # Create the parent entry linked to the student
                Parent.objects.create(
                    parent_id=parent_id,
                    student=student_instance
                )

                # Create the student class entry linked to the student

                user_login = UserLogin.objects.create(
                    user_name=student_instance.user_name,
                    password=student_instance.first_name,
                    plain_password=student_instance.first_name,
                    reference_id=student_instance.id,
                    user_type=UserType.objects.get(id=2),
                    organization=student_instance.organization,
                    branch=student_instance.branch
                )

                # Hash the password and save the user login instance
                user_login.set_password(student_instance.first_name)
                user_login.save()

                # If everything is successful, return the response
                # Add the student to the response

                response_data = serializer.data
                response_data['student_id'] = student_instance.id

                # Get the absolute URL of the profile picture if it exists
                if student_instance.profile_pic:
                    response_data['profile_pic'] = request.build_absolute_uri(student_instance.profile_pic.url)
                else:
                    response_data['profile_pic'] = None  # or handle accordingly

                # def one_time_password():
                #     length = 12
                #     chars = string.ascii_letters + string.digits
                #
                #     password = ''.join(secrets.choice(chars) for _ in range(length))
                #     return password
                def send_welcome_email():
                    try:
                        if student_instance.email:  # Only send if email exists
                            send_mail(
                                subject="Welcome to Acadix!",
                                message=f"Hello {student_instance.first_name}, your registration was successful!"
                                        f" Your Login UserId is {student_instance.user_name} & "
                                        f"Your Login Password is {student_instance.first_name}",
                                # f"Your One Time Login Password is {one_time_password()}",
                                from_email=settings.DEFAULT_FROM_EMAIL,
                                recipient_list=[student_instance.email],
                                fail_silently=False,
                            )
                    except Exception as e:
                        # Log the email error but don't crash the request
                        print(f" Email sending failed: {str(e)}")
                        # Optionally log to your ExceptionTrack table
                        # ExceptionTrack.objects.create(
                        #     process_name='StudentRegistrationWelcomeEmail',
                        #     message=f'Failed to send welcome email: {str(e)}'
                        # )

                transaction.on_commit(send_welcome_email)
            return Response({"message": "Student Registered Successfully.", "data": response_data},
                            status=status.HTTP_201_CREATED)

        except ValidationError as e:
            # Rollback the transaction on validation error
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            # Rollback the transaction on database error
            # self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            # Rollback the transaction on any other exception
            # self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='StudentRegistration',
            message=error_message,
        )


class FeeStructureMixin:
    def FeeStructureProcess(self, feestructureDetail, feemasterStructureInstance):
        try:
            for feedetail in feestructureDetail:
                element_type = feedetail['element_type']
                element_frequency = feedetail['element_frequency']
                amount = feedetail['amount']
                semester_1 = feedetail['semester_1']
                semester_2 = feedetail['semester_2']
                semester_3 = feedetail['semester_3']
                semester_4 = feedetail['semester_4']
                semester_5 = feedetail['semester_5']
                semester_6 = feedetail['semester_6']
                semester_7 = feedetail['semester_7']
                semester_8 = feedetail['semester_8']
                adjustment_flag = feedetail['adjustment_flag']

                # Create Fee Details
                FeeDetailsInstance = FeeStructureDetail.objects.create(
                    fee_structure_master=feemasterStructureInstance,
                    element_type=element_type,
                    element_frequency=element_frequency,
                    amount=amount,
                    semester_1=semester_1,
                    semester_2=semester_2,
                    semester_3=semester_3,
                    semester_4=semester_4,
                    semester_5=semester_5,
                    semester_6=semester_6,
                    semester_7=semester_7,
                    semester_8=semester_8,
                    adjustment_flag=adjustment_flag,
                    created_by=feemasterStructureInstance.created_by,
                    updated_by=feemasterStructureInstance.created_by
                )

            return Response({'message': 'Fee Details added successfully!!'}, status=status.HTTP_200_OK)


        except Exception as e:

            error_message = f"Error processing Fee Details: {str(e)}"
            # Raise an exception to be caught in the create method
            raise ValueError(error_message)


class FeeStructureDetailCreateAPI(CreateAPIView, FeeStructureMixin):
    queryset = FeeStructureDetail.objects.all()
    serializer_class = FeeStructureMasterRequestSerializer

    @transaction.atomic
    def create(self, request, *args, **kwargs):
        try:
            # Start a new atomic transaction
            with transaction.atomic():
                # Validate and save data
                request.data['fee_structure_master_detail']['version_no'] = 1
                serializer = self.get_serializer(data=request.data)
                serializer.is_valid(raise_exception=True)

                # Get Serialized data

                fee_master_structure_detail = serializer.validated_data.get('fee_structure_master_detail')
                fee_structure_detail = serializer.validated_data.get('fee_structure_detail')

                feemasterStructureInstance = FeeStructureMaster.objects.create(
                    fee_structure_code=fee_master_structure_detail['fee_structure_code'],
                    fee_structure_description=fee_master_structure_detail['fee_structure_description'],
                    organization=fee_master_structure_detail['organization'],
                    branch=fee_master_structure_detail['branch'],
                    batch=fee_master_structure_detail['batch'],
                    course=fee_master_structure_detail['course'],
                    department=fee_master_structure_detail['department'],
                    academic_year=fee_master_structure_detail['academic_year'],
                    semester=fee_master_structure_detail['semester'],
                    enabled=fee_master_structure_detail['enabled'],
                    version_no=int(fee_master_structure_detail['version_no']),
                    category=fee_master_structure_detail['category'],
                    new_existing=fee_master_structure_detail['new_existing'],
                    created_by=fee_master_structure_detail['created_by'],
                    updated_by=fee_master_structure_detail['created_by']
                )

                # Process Fee Details Data

                if fee_structure_detail and len(fee_structure_detail) > 0:
                    self.FeeStructureProcess(fee_structure_detail, feemasterStructureInstance)

                return Response({'message': 'Fee Details Added successfully'}, status=status.HTTP_200_OK)




        except ValidationError as e:
            # Rollback the transaction on validation error

            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            # Rollback the transaction on database error
            self.log_exception(request, str(e))

            return Response({'error': 'A database error occurred: ' + str(e)},

                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:

            # Rollback the transaction on any other exception
            self.log_exception(request, str(e))

            return Response({'error': 'An unexpected error occurred: ' + str(e)},

                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='feestructuredetailsAdd',

            message=error_message,

        )


class StudentRegistrationListAPIView(ListAPIView):
    queryset = StudentRegistration.objects.all()
    serializer_class = StudentRegistrationListSerializer

    # def get_queryset(self):
    #     academicyearId = self.kwargs.get('academic_year_id')
    #
    #     return academicyearId

    def list(self, request, *args, **kwargs):

        try:
            serializer = self.get_serializer(data=request.query_params)
            serializer.is_valid(raise_exception=True)

            organization_id = serializer.validated_data.get('organization_id')
            branch_id = serializer.validated_data.get('branch_id')
            batch_id = serializer.validated_data.get('batch_id')
            course_id = serializer.validated_data.get('course_id')
            department_id = serializer.validated_data.get('department_id')
            academic_year_id = serializer.validated_data.get('academic_year_id')
            semester_id = serializer.validated_data.get('semester_id')
            section_id = serializer.validated_data.get('section_id')
            student_name = serializer.validated_data.get('student_name')
            gender = serializer.validated_data.get('gender')
            admission_no = serializer.validated_data.get('admission_no')
            from_date = serializer.validated_data.get('from_date')
            to_date = serializer.validated_data.get('to_date')
            student_status = serializer.validated_data.get('student_status')
            barcode = serializer.validated_data.get('barcode')
            college_admission_no = serializer.validated_data.get('college_admission_no')
            father_name = serializer.validated_data.get('father_name')
            mother_name = serializer.validated_data.get('mother_name')

            # organization_id,branch_id,batch_id,course_id,department_id,academic_year_id,semester_id,section_id,student_name,gender,
            # admission_no,from_date,to_date,student_status,barcode,college_admission_no,father_name,mother_name

            if organization_id and branch_id:
                try:
                    studentRegistrationList = StudentRegistration.objects.filter(organization=organization_id,
                                                                                 branch=branch_id,
                                                                                 is_active=True).order_by('-updated_at')
                except StudentRegistration.DoesNotExist:
                    return Response({"message": "student registration record not found !!!"},
                                    status=status.HTTP_404_NOT_FOUND)
            else:
                return Response({"message": "organization_id and branch_id is required !!!"},
                                status=status.HTTP_404_NOT_FOUND)

            if batch_id:
                studentRegistrationList = studentRegistrationList.filter(batch=batch_id).order_by('-updated_at')

            if course_id:
                studentRegistrationList = studentRegistrationList.filter(course=course_id).order_by('-updated_at')

            if department_id:
                studentRegistrationList = studentRegistrationList.filter(department=department_id).order_by(
                    '-updated_at')

            if academic_year_id:
                studentRegistrationList = studentRegistrationList.filter(academic_year=academic_year_id).order_by(
                    '-updated_at')

            if semester_id:
                studentRegistrationList = studentRegistrationList.filter(semester=semester_id).order_by('-updated_at')

            if section_id:
                studentRegistrationList = studentRegistrationList.filter(section=section_id).order_by('-updated_at')

            # try:
            #     academic_year_id = request.query_params.get('academic_year_id')
            #     academic_year_instance = AcademicYear.objects.get(id=academic_year_id)
            #     # query_params = request.query_params
            # except:
            #     academic_year_id = None
            # try:
            #     course_id = request.query_params.get('course_id')
            #     course_instance = Course.objects.get(id=course_id)
            # except:
            #     course_id = None
            # try:
            #     section_id = request.query_params.get('section_id')
            #     # class_section_instance = CourseSectionBind.objects.get(id=section_id)
            #     section_instance = Section.objects.get(id=section_id)
            # except:
            #     section_id = None
            #
            # try:
            #     admission_no = request.query_params.get('admission_no')
            #     studentRegistrationInstance = StudentRegistration.objects.get(admission_no=admission_no,is_active=True)
            # except:
            #     admission_no = None
            # # Step 1: Retrieve all students
            # #studentList = StudentRegistration.objects.filter(academic_year=academicyearId)
            # if course_id and section_id is not None:
            #     # student_list = StudentCourse.objects.filter(
            #     student_list=StudentRegistration.objects.filter(
            #         academic_year=academic_year_id,
            #         is_active=True,
            #         course=course_instance,
            #         section=section_instance).order_by('-updated_at')
            # elif course_id is not None:
            #     # student_list = StudentCourse.objects.filter(
            #     student_list = StudentRegistration.objects.filter(
            #         academic_year=academic_year_id,
            #         is_active=True,
            #         course=course_instance).order_by('-updated_at')
            if student_name:
                # studentName = request.query_params.get('studentName')
                name_parts = student_name.strip().split()
                if len(name_parts) == 1:
                    first = name_parts[0].strip()
                    studentRegistrationList = studentRegistrationList.filter(
                        Q(first_name__icontains=first) | Q(middle_name__icontains=first) | Q(last_name__icontains=first)
                        , is_active=True
                        ).order_by('-updated_at')

                elif len(name_parts) == 2:  # First + Last
                    first, last = name_parts
                    studentRegistrationList = studentRegistrationList.filter(
                        Q(first_name__iexact=first, last_name__iexact=last) |
                        Q(first_name__iexact=first, middle_name__isnull=False, last_name__iexact=last)
                        , is_active=True
                    ).order_by('-updated_at')

                elif len(name_parts) == 3:  # First + Middle + Last
                    first, middle, last = name_parts
                    studentRegistrationList = studentRegistrationList.filter(
                        first_name__iexact=first,
                        middle_name__iexact=middle,
                        last_name__iexact=last,
                        is_active=True
                    ).order_by('-updated_at')
                # studentNameSplit = studentName.split()
                # student_list = StudentRegistration.objects.filter(first_name__istartswith=studentName,
                #                                                     academic_year_id=academicyearId).order_by('-updated_at')
                # student_list = StudentRegistration.objects.filter(Q(first_name__icontains=studentName) | Q(middle_name__icontains=studentName) | Q(last_name__icontains=studentName))
                # if len(studentNameSplit) == 0:
                #     student_list = StudentRegistration.objects.filter(first_name__istartswith = studentName,academic_year_id=academicyearId).order_by('-updated_at')
                # elif len(studentNameSplit) > 0:
                #     student_list = StudentRegistration.objects.filter(first_name__istartswith = studentName[0],middle_name__istartswith=studentName[1] if len(studentNameSplit) > 1 else '',last_name__istartswith=studentName[2] if len(studentNameSplit) > 2 else '',academic_year_id=academicyearId).order_by('-updated_at')
            if gender:
                # gender = request.query_params.get('gender')
                studentRegistrationList = studentRegistrationList.filter(gender=gender).order_by('-updated_at')

            if admission_no:
                # admission_no = request.query_params.get('admission_no')
                studentRegistrationList = studentRegistrationList.filter(admission_no=admission_no).order_by(
                    '-updated_at')
            if from_date and to_date:
                # from_date = request.query_params.get('from_date')
                # to_date = request.query_params.get('to_date')
                studentRegistrationList = studentRegistrationList.filter(
                    created_at__range=(from_date, to_date)).order_by('-updated_at')
            if student_status:
                # student_status = request.query_params.get('student_status')
                studentRegistrationList = studentRegistrationList.filter(status=student_status).order_by('-updated_at')
            if barcode:
                # barcode = request.query_params.get('barcode')
                studentRegistrationList = studentRegistrationList.filter(barcode=barcode,
                                                                         ).order_by(
                    '-updated_at')
            # if admission_no:
            #     # admissionNo = request.query_params.get('admissionNo')
            #     studentRegistrationList = studentRegistrationList.filter(admission_no=admission_no,
            #                                                         ).order_by(
            #         '-updated_at')
            if college_admission_no:
                # schoolAdmissionNo = request.query_params.get('college_admission_no')
                studentRegistrationList = studentRegistrationList.filter(
                    college_admission_no=college_admission_no, ).order_by(
                    '-updated_at')
            if father_name:
                # fatherName = request.query_params.get('fatherName')
                studentRegistrationList = studentRegistrationList.filter(father_name__icontains=father_name,
                                                                         is_active=True)

            if mother_name:
                # motherName = request.query_params.get('motherName')
                studentRegistrationList = studentRegistrationList.filter(mother_name__icontains=mother_name,
                                                                         is_active=True)
                # name_parts = fatherName.strip().split()
                # if len(name_parts) == 1:
                #     first = name_parts[0].strip()
                #     student_list = StudentRegistration.objects.filter(father_name__icontains=first)
                #
                # elif len(name_parts) == 2:  # First + Last
                #     first, last = name_parts
                #     student_list = StudentRegistration.objects.filter(
                #         Q(first_name__iexact=first, last_name__iexact=last) |
                #         Q(first_name__iexact=first, middle_name__isnull=False, last_name__iexact=last)
                #     )
                #
                # elif len(name_parts) == 3:  # First + Middle + Last
                #     first, middle, last = name_parts
                #     student_list = StudentRegistration.objects.filter(
                #         first_name__iexact=first,
                #         middle_name__iexact=middle,
                #         last_name__iexact=last
                #     )
            # else:
            #     student_list = StudentRegistration.objects.filter(academic_year=academic_year_id,is_active=True).order_by('-updated_at')
            # student_list = StudentCourse.objects.filter(academic_year_id=academicyearId).filter(Q(is_active=True) | Q(is_promoted=True)).order_by('-updated_at')
            # print(studentList.update_at)
            # if admission_no:

            recordList = []
            for student in studentRegistrationList:
                # studentId = stu.id
                # studentId = stu.student_id
                # print('year id: ',stu.academic_year_id,"student_id: ", studentId.id)
                # if studentId.id==68:
                #     print("student_id: ", studentId)

                # Registration Instance
                # try:
                #     RegistrationInstance = StudentRegistration.objects.get(id=studentId)
                # except Exception as e:
                #     print(e)
                #     RegistrationInstance = None
                if student is not None:
                    # Step 2: Retrieve related data
                    feeDetails = StudentCourse.objects.filter(student=student, is_active=True)
                    transportDetails = StudentCourse.objects.filter(student=student, is_active=True)
                    addressDetails = Address.objects.filter(reference_id=student.id)
                    sibilingsDetails = SiblingDetail.objects.filter(student=student)
                    studentEmergencyContacts = StudentEmergencyContact.objects.filter(student=student)
                    authorizedPickups = AuthorisedPickup.objects.filter(student=student)
                    studentDocuments = StudentDocument.objects.filter(student=student)
                    previousEducations = StudentPreviousEducation.objects.filter(student=student)

                    # Manually serialize the feeDetails Data
                    feeDetailslist = []
                    if feeDetails.exists():

                        for item in feeDetails:
                            if item.fee_group.id == None or item.fee_applied_from.id == None:
                                continue
                            else:
                                feemasterInstance = FeeStructureMaster.objects.get(id=item.fee_group.id)
                                semesterInstance = Semester.objects.get(id=item.fee_applied_from.id)

                                feedata = {
                                    'fee_group_id': item.fee_group.id,
                                    'fee_group': feemasterInstance.fee_structure_code,
                                    'fee_applied_from_id': item.fee_applied_from.id,
                                    'semester': semesterInstance.semester_description
                                }

                                feeDetailslist.append(feedata)

                    # Manually serialize the sibilingsDetails data
                    sibilinglist = []
                    if sibilingsDetails.exists():
                        for sibiling in sibilingsDetails:
                            studentInstance = StudentRegistration.objects.get(id=sibiling.sibling.id)
                            courseInstance = Course.objects.get(id=studentInstance.course.id)
                            sectionInstance = Section.objects.get(id=studentInstance.section.id)
                            sibilingsdata = {
                                'sibling_id': sibiling.sibling.id,
                                'sibling_firstname': studentInstance.first_name,
                                'sibling_lastname': studentInstance.last_name,
                                'college_admission_no': studentInstance.college_admission_no,
                                'course_name': courseInstance.course_name,
                                'section_name': sectionInstance.section_name

                            }
                            sibilinglist.append(sibilingsdata)
                    # Fetch class and section details for student
                    courseInstance = Course.objects.get(id=student.course.id)
                    sectionInstance = Section.objects.get(id=student.section.id)

                    # Step 3: Serialize the data using respective serializers
                    student_data = {
                        'studentBasicDetails': {
                            **StudentBasicDetailSerializer(student).data,
                            'organization_description': student.organization.__dict__['organization_description'],
                            'branch_name': student.batch.branch.__dict__['branch_name'],
                            'batch_description': student.batch.__dict__['batch_description'],
                            'course_name': student.course.__dict__['course_name'],
                            'department_description': student.department.__dict__['department_description'],
                            'academic_year_description': student.academic_year.__dict__['academic_year_description'],
                            'semester_description': student.semester.__dict__['semester_description'],
                            'section_name': student.section.__dict__['section_name'],
                            'gender_name': student.gender.gender_name if student.gender else None,
                            'house_name': student.house.house_name if student.house else None,
                            'religion_name': student.religion.religion_name if student.religion else None,
                            'category_name': student.category.category_name if student.category else None,
                            'mother_tongue_name': student.mother_tongue.mother_tongue_name if student.mother_tongue else None,
                            'blood_name': student.blood.blood_name if student.blood else None,
                            'nationality_name': student.nationality.nationality_name if student.nationality else None,
                            'profile_pic': request.build_absolute_uri(
                                student.profile_pic.url) if student.profile_pic else None
                        },
                        'feeDetails': feeDetailslist,  # StudentFeeAppliedDetails(feeDetails).data,
                        'addressDetails': AddressDetailsSerializer(addressDetails, many=True).data,
                        'sibilingsDetails': sibilinglist,
                        # StudentSibilingsDetailsSerializer(sibilingsDetails, many=True).data,
                        'emegencyContact': StudentEmergencyContactDetailsSerializer(studentEmergencyContacts,
                                                                                    many=True).data,
                        'authorizedpickup': AuthorisedPickupDetailsSerializer(authorizedPickups, many=True).data,
                        'documentsDetails': StudentDocumentDetailsSerializer(studentDocuments, many=True).data,
                        'previousEducationDetails': StudentPreviousEducationDetailsSerializer(previousEducations,
                                                                                              many=True).data
                    }

                    recordList.append(student_data)

            # Step 4: Return the serialized response
            return Response({'message': 'Success', 'data': recordList}, status=status.HTTP_200_OK)


        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='StudentRegistrationList',
            message=error_message,
        )


# --- Student Registration Record Update --- #
class StudentRegistrationUpdateAPIView(UpdateAPIView, UtilityGroupMixin):
    # permission_classes = [IsAuthenticated]
    queryset = StudentRegistration.objects.all()
    serializer_class = StudentRegistrationUpdateSerializer
    parser_classes = [MultiPartParser, FormParser, JSONParser]

    # parser_classes = [MultiPartParser]

    def update(self, request, *args, **kwargs):
        try:
            # partial = kwargs.pop('partial', False)
            # instance = self.get_object()
            student_id = request.query_params.get('student_id')
            instance = StudentRegistration.objects.get(id=student_id)

            with transaction.atomic():
                if request.content_type.startswith('multipart/form-data'):
                    data = request.data.dict()  # Convert QueryDict to a mutable dictionary
                    # data = request.data['data']
                    data['student_basic_detail'] = json.loads(
                        data.get('student_basic_detail', '{}'))  # Convert string to dict
                    # data['fee_detail'] = json.loads(data.get('fee_detail', '{}'))  # Convert string to list
                    data['transport_detail'] = json.loads(data.get('transport_detail', '{}'))  # Convert string to list
                    data['address_detail'] = json.loads(data.get('address_detail', '{}'))  # Convert string to list
                    data['sibling_detail'] = json.loads(data.get('sibling_detail', '[]'))  # Convert string to list
                    data['emergency_contact'] = json.loads(
                        data.get('emergency_contact', '[]'))  # Convert string to list
                    data['authorized_pickup'] = json.loads(
                        data.get('authorized_pickup', '[]'))  # Convert string to list
                    data['document_detail'] = json.loads(data.get('document_detail', '[]'))  # Convert string to list
                    data['previous_education_detail'] = json.loads(
                        data.get('previous_education_detail', '[]'))  # Convert string to list


                    # Attach file fields if present
                    profile_pic = None  # Initialize to prevent UnboundLocalError
                    if 'profile_pic' in request.FILES:
                        profile_pic = request.FILES['profile_pic']

                    # document_files = []
                    # for i in range(len(request.FILES.getlist('document_pic'))):
                    #     if request.FILES.getlist('document_pic')[i]:
                    #         document_files.append(request.FILES.getlist('document_pic')[i])

                    document_files = []
                    for item, item_obj in request.FILES.items():
                        if item != 'profile_pic':
                            document_files.append(item_obj)


                        # if 'document_file' in request.FILES:
                    #     document_file = request.FILES['document_file']

                # uploaded_file = request.FILES.get('file')
                # data = request.data

                # validate input data
                serializer = self.get_serializer(instance, data=data)
                serializer.is_valid(raise_exception=True)


                # Access serializer data

                student_basic_detail = serializer.validated_data.get('student_basic_detail')
                address_detail = serializer.validated_data.get('address_detail')
                sibling_detail = serializer.validated_data.get('sibling_detail')
                emergency_contact = serializer.validated_data.get('emergency_contact')
                authorized_pickup = serializer.validated_data.get('authorized_pickup')
                document_detail = serializer.validated_data.get('document_detail')
                previous_education_detail = serializer.validated_data.get('previous_education_detail')

                registration_no = student_basic_detail.get('registration_no')
                barcode = student_basic_detail.get('barcode')

                if registration_no:
                    if StudentRegistration.objects.exclude(pk=instance.pk).filter(registration_no=registration_no).exists():
                        return Response(
                            {'message': 'duplicate registration number, required unique registration number'},
                            status=status.HTTP_400_BAD_REQUEST)
                    else:
                        student_basic_detail['registration_no'] = registration_no
                else:
                    student_basic_detail['registration_no'] = ''

                if barcode:
                    if StudentRegistration.objects.exclude(pk=instance.pk).filter(barcode=barcode).exists():
                        return Response({'message': 'duplicate barcode, required unique barcode'},
                                        status=status.HTTP_400_BAD_REQUEST)
                    else:
                        student_basic_detail['barcode'] = barcode
                else:
                    student_basic_detail['barcode'] = ''

                # , emegencyContact, authorizedpickup, documentsDetails, previousEducationDetails
                if student_basic_detail is None:
                    return Response({'message': 'studentBasicDetails required'}, status=status.HTTP_404_NOT_FOUND)
                if address_detail is None:
                    return Response({'message': 'addressDetails required'}, status=status.HTTP_404_NOT_FOUND)
                if student_basic_detail:
                    # instance.admission_no = studentBasicDetails.get('admission_no', instance.admission_no)
                    instance.admission_type = student_basic_detail.get('admission_type', instance.admission_type)
                    instance.first_name = student_basic_detail.get('first_name', instance.first_name)
                    instance.middle_name = student_basic_detail.get('middle_name', instance.middle_name)
                    instance.last_name = student_basic_detail.get('last_name', instance.last_name)
                    instance.batch = student_basic_detail.get('batch', instance.batch)
                    instance.course = student_basic_detail.get('course', instance.course)
                    instance.department = student_basic_detail.get('department', instance.department)
                    instance.academic_year = student_basic_detail.get('academic_year', instance.academic_year)
                    instance.semester = student_basic_detail.get('semester', instance.semester)
                    instance.section = student_basic_detail.get('section', instance.section)
                    instance.gender = student_basic_detail.get('gender', instance.gender)
                    instance.date_of_admission = student_basic_detail.get('date_of_admission',
                                                                          instance.date_of_admission)
                    instance.date_of_join = student_basic_detail.get('date_of_join', instance.date_of_join)
                    instance.barcode = student_basic_detail.get('barcode', instance.barcode)
                    instance.registration_no = student_basic_detail.get('registration_no', instance.registration_no)
                    # instance.college_admission_no = studentBasicDetails.get('college_admission_no', instance.college_admission_no)
                    # instance.cbse_reg_no = student_basic_detail.get('cbse_reg_no',instance.cbse_reg_no)
                    instance.house = student_basic_detail.get('house', instance.house)
                    instance.religion = student_basic_detail.get('religion', instance.religion)
                    instance.category = student_basic_detail.get('category', instance.category)
                    instance.mother_tongue = student_basic_detail.get('mother_tongue', instance.mother_tongue)
                    instance.blood = student_basic_detail.get('blood', instance.blood)
                    instance.nationality = student_basic_detail.get('nationality', instance.nationality)
                    instance.email = student_basic_detail.get('email', instance.email)
                    instance.date_of_birth = student_basic_detail.get('date_of_birth', instance.date_of_birth)
                    instance.children_in_family = student_basic_detail.get('children_in_family',
                                                                           instance.children_in_family)
                    instance.student_aadhaar_no = student_basic_detail.get('student_aadhaar_no',
                                                                           instance.student_aadhaar_no)
                    instance.user_name = student_basic_detail.get('user_name', instance.user_name)
                    instance.remarks = student_basic_detail.get('remarks', instance.remarks)
                    # instance.profile_pic = studentBasicDetails.get('profile_pic', instance.profile_pic)
                    instance.profile_pic = student_basic_detail.get('profile_pic', instance.profile_pic)
                    # instance.enrollment_no = studentBasicDetails.get('enrollment_no', instance.enrollment_no)
                    instance.primary_guardian = student_basic_detail.get('primary_guardian', instance.primary_guardian)
                    instance.status = student_basic_detail.get('status', instance.status)
                    instance.father_name = student_basic_detail.get('father_name', instance.father_name)
                    instance.father_profession = student_basic_detail.get('father_profession',
                                                                          instance.father_profession)
                    instance.father_contact_number = student_basic_detail.get('father_contact_number',
                                                                              instance.father_contact_number)
                    instance.father_email = student_basic_detail.get('father_email', instance.father_email)
                    instance.father_aadhaar_no = student_basic_detail.get('father_aadhaar_no',
                                                                          instance.father_aadhaar_no)
                    instance.mother_name = student_basic_detail.get('mother_name', instance.mother_name)
                    instance.mother_profession = student_basic_detail.get('mother_profession',
                                                                          instance.mother_profession)
                    instance.mother_contact_number = student_basic_detail.get('mother_contact_number',
                                                                              instance.mother_contact_number)
                    instance.mother_email = student_basic_detail.get('mother_email', instance.mother_email)
                    instance.mother_aadhaar_no = student_basic_detail.get('mother_aadhaar_no',
                                                                          instance.mother_aadhaar_no)
                    instance.updated_by = student_basic_detail.get('updated_by', instance.updated_by)


                    instance.save()

                    student_course_instance = StudentCourse.objects.get(student_id=student_id)


                    student_course_instance.batch = student_basic_detail.get('batch', student_course_instance.batch)
                    student_course_instance.course = student_basic_detail.get('course', student_course_instance.course)
                    student_course_instance.department = student_basic_detail.get('department',
                                                                                   student_course_instance.department)
                    student_course_instance.academic_year = student_basic_detail.get('academic_year',
                                                                                     student_course_instance.academic_year)
                    student_course_instance.semester = student_basic_detail.get('semester',
                                                                                student_course_instance.semester)
                    student_course_instance.section = student_basic_detail.get('section',
                                                                               student_course_instance.section)

                    # if student_basic_detail.get('student_status'):
                    #     instance.student_status = student_basic_detail.get('student_status', instance.student_status)
                    #     student_course_instance.student

                    student_course_instance.save()

                if profile_pic:
                    instance.profile_pic.save(profile_pic.name, profile_pic)
                    instance.save()

                # Process address Details
                if address_detail:
                    Address.objects.filter(reference_id=instance.id, is_active=True).update(is_active=False)
                    self.addressDetailsProcess(address_detail, instance)

                # print(sibilingsDetails,type(sibilingsDetails))
                # Process sibilings Details
                if sibling_detail and len(sibling_detail) > 0:
                    SiblingDetail.objects.filter(student=instance.id, is_active=True).update(is_active=False)
                    self.sibilingsProcess(sibling_detail, instance)

                # Emergency contact process
                if emergency_contact and len(emergency_contact) > 0:
                    StudentEmergencyContact.objects.filter(student=instance.id, is_active=True).update(is_active=False)
                    self.EmergencyContactProcess(emergency_contact, instance)

                # authorizedpickup process
                if authorized_pickup and len(authorized_pickup):
                    AuthorisedPickup.objects.filter(student=instance.id, is_active=True).update(is_active=False)
                    self.authorizedpickupProcess(authorized_pickup, instance)

                # documentsDetails process
                if document_detail and len(document_detail):
                    StudentDocument.objects.filter(student=instance.id, is_active=True).update(is_active=False)
                    self.documentsDetailsProcess(request, document_detail, instance, document_files)

                # previousEducationDetails process
                if previous_education_detail:
                    StudentPreviousEducation.objects.filter(student=instance.id, is_active=True).update(is_active=False)
                    self.previousEducationDetailsProcess(previous_education_detail, instance)

                return Response({'message': 'Student Updated Successfully!!'}, status=status.HTTP_200_OK)


        except Http404:
            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'message': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred.' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred: ' + str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='Student-Registration-update',
            message=error_message,
        )


class GetFeeStructureMasterAndDetailsListAPIView(ListAPIView):
    serializer_class = FeeStructureMasterRequestSerializer

    # def get_queryset(self):
    #     fee_structure_master_id = self.kwargs.get('fee_structure_master_id')
    #     academic_year_id= self.kwargs.get('academic_year_id')
    #     organization_id = self.kwargs.get('organization_id')
    #     branch_id = self.kwargs.get('branch_id')
    #
    #     #fetch the fee structure master based on provided parameters
    #
    #     feemasterDataInstance = FeeStructureMaster.objects.get(
    #         id=fee_structure_master_id,
    #         academic_year_id=academic_year_id,
    #         organization = organization_id,
    #         branch_id = branch_id
    #     )
    #     return feemasterDataInstance

    def list(self, request, *args, **kwargs):
        try:

            fee_structure_master_id = request.query_params.get('fee_structure_master_id')
            academic_year_id = request.query_params.get('academic_year_id')
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            # feemasterDataInstance = self.get_queryset()

            feemasterDataInstance = FeeStructureMaster.objects.get(
                id=fee_structure_master_id,
                # academic_year=academic_year_id,
                organization=organization_id,
                branch=branch_id
            )

            # Serialize the fee structure master instance
            feemasterRecord = FeeStructureMasterSerializer(feemasterDataInstance)

            # Get Fee Details
            feestructureDetails = FeeStructureDetail.objects.filter(id=feemasterDataInstance.id)

            feeDetailsRecord = FeeStructureDetailSerializer(feestructureDetails, many=True)

            organization_instance = Organization.objects.get(id=feemasterRecord.data['organization'])
            branch_instance = Branch.objects.get(id=feemasterRecord.data['branch'])
            batch_instance = Batch.objects.get(id=feemasterRecord.data['branch'])
            course_instance = Course.objects.get(id=feemasterRecord.data['batch'])
            department_instance = Department.objects.get(id=feemasterRecord.data['department'])
            academic_year_instance = AcademicYear.objects.get(id=feemasterRecord.data['academic_year'])
            semester_instance = Semester.objects.get(id=feemasterRecord.data['semester'])

            fee_master_structure_detail_data = dict(feemasterRecord.data)

            fee_master_structure_detail_data.update({
                "organization_description": organization_instance.organization_description,
                "branch_name": branch_instance.branch_name,
                "batch_description": batch_instance.batch_description,
                "course_name": course_instance.course_name,
                "department_description": department_instance.department_description,
                "academic_year_description": academic_year_instance.academic_year_description,
                "semester_description": semester_instance.semester_description,
            })
            fee_structure_detail_data_list = []
            for item in feeDetailsRecord.data:
                fee_structure_master_instance = FeeStructureMaster.objects.get(id=fee_structure_master_id)
                element_type_instance = FeeElementType.objects.get(id=item['element_type'])
                element_frequency_instance = FeeFrequency.objects.get(id=item['element_frequency'])

                fee_structure_detail_data = dict(item)

                fee_structure_detail_data.update({
                    "fee_structure_master_description": fee_structure_master_instance.fee_structure_description,
                    "element_description": element_type_instance.element_description,
                    "element_frequency_name": element_frequency_instance.fee_frequency_name
                })

                fee_structure_detail_data_list.append(fee_structure_detail_data)

            # Prepare the response data
            fee_structure_data = {
                'fee_master_structure_detail': fee_master_structure_detail_data,
                'fee_structure_detail': fee_structure_detail_data_list,
            }

            return Response(fee_structure_data)



        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='feemasterDetailslist',
            message=error_message,
        )


class GetFeeStructureMasterBasedOnAcademicYear(ListAPIView):
    serializer_class = FeeStructureMasterSerializer

    # def get_queryset(self):
    #     academic_yearId = self.kwargs.get('academic_year_id')
    #     if academic_yearId:
    #         return FeeStructureMaster.objects.filter(academic_year_id=academic_yearId,is_active=True)
    #     else:
    #         return FeeStructureMaster.objects.none()

    def list(self, request, *args, **kwargs):
        try:
            # response = super().list(request, *args, **kwargs)
            # resdata = response.data
            academic_year_id = request.query_params.get('academic_year_id')

            resdata = FeeStructureMaster.objects.filter(academic_year=academic_year_id, is_active=True)

            if resdata:
                responsedata = []
                for item in resdata:
                    # if item.get('is_active') == True:

                    # Prepare the custom response data
                    responsedata.append({
                        'id': item.get('id'),
                        'fee_structure_code': item.get('fee_structure_code'),
                        'fee_structure_desc': item.get('fee_structure_desc')

                    })
                    # else:
                    #     continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='findfeestructuretlistBasedOnAcademic',
            message=error_message,
        )


# class StudentFilterListAPIView(ListAPIView):
#     serializer_class = StudentFilterSerializer
#
#
#     def get_queryset(self):
#         studentId = self.kwargs.get('student')
#         college_admission_no = self.kwargs.get('college_admission_no')
#         barcodeno = self.kwargs.get('barcodeno')
#
#         if studentId !=0:
#             try:
#                 StudentInstance = StudentRegistration.objects.get(id=studentId, is_active=True)
#             except StudentRegistration.DoesNotExist:
#                 return Response({"message":"student details not found!!"})
#
#         if college_admission_no != 0:
#             try:
#                 StudentInstance = StudentRegistration.objects.get(college_admission_no=college_admission_no, is_active=True)
#             except StudentRegistration.DoesNotExist:
#                 return {"message":f"{college_admission_no} not matched any student record!!"}
#
#         if barcodeno != "" or barcodeno != None:
#             try:
#                 StudentInstance = StudentRegistration.objects.get(barcode=barcodeno, is_active=True)
#             except StudentRegistration.DoesNotExist:
#                 return {"message": f"{barcodeno} not matched any student !!"}
#
#         return StudentInstance
#
#     def list(self, request, *args, **kwargs):
#         try:
#             # Get the queryset based on the filters
#             queryset = self.get_queryset()
#             print(queryset)
#
#
#         except Exception as e:
#
#             # Log the exception
#
#             error_message = str(e)
#
#             self.log_exception(request, error_message)
#
#             return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#     def log_exception(self, request, error_message):
#
#         ExceptionTrack.objects.create(
#
#             request=str(request),
#
#             process_name='GetFilterSTUDENTList',
#
#             message=error_message,
#
#         )


class StudentFilterListAPIView(CreateAPIView):
    serializer_class = StudentFilterSerializer

    def create(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            # Get Serialize Data
            student_id = serializer.validated_data.get('student_id')
            barcode = serializer.validated_data.get('barcode')
            college_admission_no = serializer.validated_data.get('college_admission_no')

            # print(student_id,barcode,college_admission_no)

            if student_id:
                try:
                    StudentInstance = StudentRegistration.objects.get(id=student_id, is_active=True)
                except StudentRegistration.DoesNotExist:

                    return Response({"message": f"{student_id} not matched any student !!"},
                                    status=status.HTTP_200_OK)

            elif barcode:
                try:
                    StudentInstance = StudentRegistration.objects.get(barcode=barcode, is_active=True)
                except StudentRegistration.DoesNotExist:

                    return Response({"message": f"{barcode} not matched any student !!"},
                                    status=status.HTTP_200_OK)

            elif college_admission_no:
                StudentInstance = StudentRegistration.objects.filter(
                    Q(college_admission_no=college_admission_no) | Q(admission_no=college_admission_no),
                    is_active=True
                ).first()

                if not StudentInstance:
                     return Response({"message": f"{college_admission_no} not matched any student !!"},
                                    status=status.HTTP_200_OK)

            # Get Student Details

            if StudentInstance:

                # course_id = StudentInstance.addmitted_class

                # section_id = StudentInstance.addmitted_section

                courseInstance = Course.objects.get(id=StudentInstance.course.id, is_active=True)
                sectionInstance = Section.objects.get(id=StudentInstance.section.id, is_active=True)

                StudentCourseInstance = StudentCourse.objects.get(student=StudentInstance, is_active=True)

                FeeStructureMasterInstance = FeeStructureMaster.objects.get(id=StudentCourseInstance.fee_group.id)

                responsedata = {
                    'barcode': StudentInstance.barcode,
                    'college_admission_no': StudentInstance.college_admission_no,
                    'studentId': StudentInstance.id,
                    'course_name': courseInstance.course_name,
                    'section_name': sectionInstance.section_name,
                    'enrollment_no': StudentCourseInstance.enrollment_no,
                    'house': StudentCourseInstance.house.house_name,
                    'feegroup': FeeStructureMasterInstance.fee_structure_code
                }

                return Response({'message': 'success', 'data': responsedata}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No data found!!'}, status=status.HTTP_200_OK)

        except ValidationError as e:
            # Rollback the transaction on validation error

            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            # Rollback the transaction on database error
            self.log_exception(request, str(e))

            return Response({'error': 'A database error occurred: ' + str(e)},

                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='studentGetlist',

            message=error_message,

        )


class GetStudentFeeDetailListAPIView(ListAPIView):
    serializer_class = StudentFeeDetailSerializer

    # def get_queryset(self):
    #     studentId= self.kwargs.get('student_id')
    #     academicyearId = self.kwargs.get('academic_year_id')
    #     #print(studentId,academicyearId)
    #
    #     if not studentId or not academicyearId:
    #         raise ValidationError({'message': 'Please select both student and academic year ID'})
    #     return StudentFeeDetail.objects.filter(student=studentId, academic_year_id=academicyearId, is_active=True)

    def list(self, request, *args, **kwargs):
        try:
            # Get the queryset based on the filters
            # queryset = self.get_queryset()
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            student_id = request.query_params.get('student_id')
            # academicyearId = request.query_params.get('academic_year_id')

            if not (organization_id and branch_id and student_id):
                return Response({'message': 'organization_id, branch_id and student_id is required !!!'},
                                status=status.HTTP_404_NOT_FOUND)

            queryset = StudentFeeDetail.objects.filter(organization=organization_id, branch=branch_id,
                                                       student=student_id, is_active=True)

            responsedata = []
            for item in queryset:

                academicYearInstance = AcademicYear.objects.get(id=item.academic_year.id)
                organizationInstance = Organization.objects.get(id=item.organization.id)
                # branchInstance = Branches.objects.get(id=item.branch_id.id)
                try:
                    semesterInstance = Semester.objects.get(id=item.fee_applied_from.id, is_active=True)
                except ObjectDoesNotExist:
                    return Response({'message': 'semester not found'}, status=status.HTTP_404_NOT_FOUND)
                registrationInstance = StudentRegistration.objects.get(id=item.student.id)

                if item.fee_group:
                    fee_structure_id = item.fee_group.id
                    # fee_structure_id = item.fee_group.id
                else:
                    fee_structure_id = None

                if item.fee_structure_details:
                    fee_structure_details_id = item.fee_structure_details.id
                    # fee_structure_id = item.fee_group.id
                else:
                    fee_structure_details_id = None

                data = {
                    'id': item.id,
                    'student_id': registrationInstance.id,
                    'fee_structure_id': fee_structure_id,
                    'fee_structure_details_id': fee_structure_details_id,
                    'element_name': item.element_name,
                    'paid': item.paid,
                    'academic_year_id': academicYearInstance.id,
                    'academicYearName': academicYearInstance.academic_year_code,
                    'organization': organizationInstance.id,
                    'organizationName': organizationInstance.organization_code,
                    # 'branchId': branchInstance.id,
                    # 'branchName': branchInstance.branch_name,
                    'semester_id': semesterInstance.id,
                    'semester': semesterInstance.semester_description,
                    'multiplying_factor': item.multiplying_factor,
                    'element_amount': item.element_amount,
                    'total_element_period_amount': item.total_element_period_amount,
                    'paid_amount': item.paid_amount,
                    'remarks': item.remarks,
                    'reverse_flag': item.reverse_flag,

                }

                responsedata.append(data)

            if responsedata:
                return Response({'message': 'success', 'data': responsedata}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No data found'}, status=status.HTTP_200_OK)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='GetFilterSTUDENTList',

            message=error_message,

        )


class StudentFeeManagementAPIView(CreateAPIView):
    serializer_class = StudentFeeManageSerializer

    @transaction.atomic
    def create(self, request, *args, **kwargs):
        try:
            # Start a new atomic transaction
            with transaction.atomic():
                # Validate and save data
                serializer = self.get_serializer(data=request.data)
                serializer.is_valid(raise_exception=True)

                # Get Serialized data
                organization_id = serializer.validated_data.get('organization_id')
                branch_id = serializer.validated_data.get('branch_id')
                # batch= serializer.validated_data.get('organization_id')
                loginUser = serializer.validated_data.get('loginUser')
                studentIndividualFeeDetails = serializer.validated_data.get('studentIndividualFeeDetails')
                studentFeeDetails = serializer.validated_data.get('studentFeeDetails')
                addfeeElement = serializer.validated_data.get('addfeeElement')

                # print(studentIndividualFeeDetails,studentFeeDetails,addfeeElement)

                # If Individually update
                if studentIndividualFeeDetails and len(studentIndividualFeeDetails) > 0:

                    for item in studentIndividualFeeDetails:

                        if item['update_flag'] == True:

                            StudentFeeDetailInstance = StudentFeeDetail.objects.get(id=item['student_fee_details_id'])
                            # print(StudentFeeDetailInstance)

                            # Update amount on specific student fee details
                            StudentFeeDetailInstance.element_amount = item['update_amount']  # Update the amount
                            StudentFeeDetailInstance.total_element_period_amount = item['update_amount']
                            StudentFeeDetailInstance.updated_by = loginUser
                            StudentFeeDetailInstance.save()
                        # print('kumar')

                        elif item['remove_flag'] == True:
                            StudentFeeDetailInstance = StudentFeeDetail.objects.get(id=item['student_fee_details_id'])
                            StudentFeeDetailInstance.is_active = False
                            StudentFeeDetailInstance.updated_by = loginUser

                            StudentFeeDetailInstance.save()

                if studentFeeDetails and len(studentFeeDetails) > 0:
                    for item in studentFeeDetails:
                        student_id = item['student_id']
                        # academicyearId = item['academicyearId']
                        fee_element = item['fee_element']

                        # print(studentId,academicyearId,Feeelement)
                        # Get fee details
                        StudentFeeDetailRecord = StudentFeeDetail.objects.filter(
                            organization=organization_id, branch=branch_id,
                            student=student_id,
                            # academic_year= academicyearId,
                            element_name__iexact=fee_element.upper(),
                            paid_amount__lte=0
                        )
                        # print(StudentFeeDetailRecord)

                        if not StudentFeeDetailRecord:
                            continue

                        if item['update_flag'] == True and StudentFeeDetailRecord:
                            for data in StudentFeeDetailRecord:
                                data.element_amount = item['update_amount']  # Update the amount
                                data.total_element_period_amount = item['update_amount']
                                data.updated_by = loginUser
                                data.save()

                        elif item['remove_flag'] == True and StudentFeeDetailRecord:
                            for data in StudentFeeDetailRecord:
                                data.is_active = False
                                data.updated_by = loginUser
                                data.save()

                if addfeeElement and len(addfeeElement) > 0:

                    for item in addfeeElement:
                        feefrequencyInstance = FeeFrequency.objects.get(id=item['frequency_id'])
                        studentInstance = StudentRegistration.objects.get(id=item['student_id'])
                        # academicyearInstance = AcademicYear.objects.get(id=item['academic_year_id'])
                        organizationInstance = Organization.objects.get(id=item['organization_id'])
                        branchInstance = Branch.objects.get(id=item['branch_id'])
                        # branchesInstance = Branches.objects.get(id=item['branch_id'])

                        frequencytime = feefrequencyInstance.frequency_period
                        studentCourseInstance = StudentCourse.objects.get(student=studentInstance.id, is_active=True)
                        if frequencytime > 0:
                            for record in range(frequencytime):
                                if record == 0:
                                    semester = item['semester_1']
                                elif record == 1:
                                    semester = item['semester_2']
                                elif record == 2:
                                    semester = item['semester_3']
                                elif record == 3:
                                    semester = item['semester_4']
                                elif record == 4:
                                    semester = item['semester_5']
                                elif record == 5:
                                    semester = item['semester_6']
                                elif record == 6:
                                    semester = item['semester_7']
                                elif record == 7:
                                    semester = item['semester_8']

                                if semester and semester > 0:
                                    semester_instance = Semester.objects.get(id=semester, is_active=True)
                                    StudentFeeDetail.objects.create(
                                        student=studentInstance,
                                        student_course=studentCourseInstance,
                                        element_name=item['element_name'],
                                        fee_applied_from=semester_instance,
                                        semester=semester_instance,
                                        paid='N',
                                        academic_year=semester_instance.academic_year,
                                        organization=organizationInstance,
                                        branch=branchInstance,
                                        department=studentCourseInstance.department,
                                        multiplying_factor=1,
                                        element_amount=item['amount'],
                                        total_element_period_amount=item['amount'],
                                        paid_amount=0,
                                        remarks="",
                                        created_by=loginUser,
                                        updated_by=loginUser
                                    )
                                else:
                                    pass
                        else:
                            semester_instance = Semester.objects.filter(organization=organization_id, branch=branch_id,
                                                                        batch=studentInstance.branch,
                                                                        course=studentInstance.course,
                                                                        department=studentInstance.department,
                                                                        is_active=True).order_by('id')
                            studentCourseInstance = StudentCourse.objects.get(organization=organization_id,
                                                                              branch=branch_id,
                                                                              student=studentInstance.id,
                                                                              is_active=True)
                            for semester in semester_instance:
                                # period_month = period.id
                                #
                                StudentFeeDetail.objects.create(
                                    student=studentInstance,
                                    student_course=studentCourseInstance,
                                    element_name=item['element_name'],
                                    fee_applied_from=semester,
                                    semester=semester,
                                    paid='N',
                                    academic_year=semester.academic_year,
                                    organization=organizationInstance,
                                    branch_id=branchInstance,
                                    department=studentCourseInstance.department,
                                    multiplying_factor=1,
                                    element_amount=item['amount'],
                                    total_element_period_amount=item['amount'],
                                    paid_amount=0,
                                    remarks="",
                                    created_by=loginUser,
                                    updated_by=loginUser
                                )

                return Response({'message': 'Record Process Successfully!!'}, status=status.HTTP_200_OK)


        except ValidationError as e:

            # Rollback the transaction on validation error

            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)




        except DatabaseError as e:

            # Rollback the transaction on database error

            self.log_exception(request, str(e))

            return Response({'error': 'A database error occurred: ' + str(e)},

                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)




        except Exception as e:

            # Rollback the transaction on any other exception

            self.log_exception(request, str(e))

            return Response({'error': 'An unexpected error occurred: ' + str(e)},

                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='StudentFeesManagement',

            message=error_message,

        )


class StudentRegistrationBasedOnIdAPIView(RetrieveAPIView):
    serializer_class = StudentBasicDetailSerializer

    # def get_object(self):
    #     student_id = self.kwargs.get('student_id')
    #     try:
    #         # Fetch the registration instance based on student_id and is_active status
    #         return StudentRegistration.objects.get(id=student_id, is_active=True)
    #     except StudentRegistration.DoesNotExist:
    #         raise NotFound("Student not found.")

    def retrieve(self, request, *args, **kwargs):
        try:
            # Retrieve the main student registration object
            # student_instance = self.get_object()
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            student_id = request.query_params.get('student_id')

            if organization_id and branch_id and student_id:
                try:
                    student_instance = StudentRegistration.objects.get(id=student_id, organization=organization_id,
                                                                       branch=branch_id)
                    if not student_instance:
                        return Response({"message": "student record not found !!!"},
                                        status=status.HTTP_204_NO_CONTENT)
                except StudentRegistration.DoesNotExist:
                    return Response({"message": "student registration record not found !!!"},
                                    status=status.HTTP_204_NO_CONTENT)
            else:
                return Response({"message": "organization_id, branch_id and student_id is required !!!"},
                                status=status.HTTP_400_BAD_REQUEST)

            # Fetch related details
            try:
                academicyearInstance = AcademicYear.objects.get(id=student_instance.academic_year.id)
            except AcademicYear.DoesNotExist:
                raise NotFound("The Academic year ID was not found.")

            try:
                feeDetails = StudentCourse.objects.get(student=student_instance.id, is_active=True)
            except StudentCourse.DoesNotExist:
                return Response({"message": "The student ID was not found in StudentCourse."},
                                status=status.HTTP_400_BAD_REQUEST)

            try:
                courseInstance = Course.objects.get(id=student_instance.course.id)
            except Course.DoesNotExist:
                return Response({"message": "The course ID was not found."}, status=status.HTTP_400_BAD_REQUEST)

            try:
                sectionInstance = Section.objects.get(id=student_instance.section.id)
            except Section.DoesNotExist:
                return Response({"message": "The Section ID was not found."}, status=status.HTTP_400_BAD_REQUEST)
                # raise NotFound("The Section ID was not found.")

            try:
                if feeDetails.fee_group:
                    feemasterInstance = FeeStructureMaster.objects.get(id=feeDetails.fee_group.id)
                else:
                    feemasterInstance = None
            except FeeStructureMaster.DoesNotExist:
                return Response({"message": "The fee_group ID was not found."}, status=status.HTTP_400_BAD_REQUEST)

            try:
                if feeDetails.fee_applied_from:
                    semesterInstance = Semester.objects.get(id=feeDetails.fee_applied_from.id)
                else:
                    semesterInstance = None
            except (Semester.DoesNotExist, AttributeError):
                return Response({"message": "The fee_applied_from ID was not found."},
                                status=status.HTTP_400_BAD_REQUEST)

            # Fetch other related details
            addressDetails = Address.objects.filter(reference_id=student_instance.id, is_active=True)
            sibilingsDetails = SiblingDetail.objects.filter(student=student_instance, is_active=True)
            emegencyContact = StudentEmergencyContact.objects.filter(student=student_instance, is_active=True)
            authorizedpickup = AuthorisedPickup.objects.filter(student=student_instance, is_active=True)
            documentsDetails = StudentDocument.objects.filter(student=student_instance, is_active=True)
            previousEducationDetails = StudentPreviousEducation.objects.filter(student=student_instance,
                                                                               is_active=True)

            # Process siblings details
            sibilings_details = []
            for sibilings in sibilingsDetails:
                try:
                    registrationInstance = StudentRegistration.objects.get(id=sibilings.sibling.id, is_active=True)
                    studentCourseInstance = StudentCourse.objects.get(student=registrationInstance, is_active=True)
                    siblingCourseInstance = Course.objects.get(id=studentCourseInstance.course.id)
                    siblingSectionInstance = Section.objects.get(id=studentCourseInstance.section.id)

                    sibling_data = {
                        'id': sibilings.sibling.id,
                        'admission_no': registrationInstance.admission_no,
                        'first_name': registrationInstance.first_name,
                        'middle_name': registrationInstance.middle_name,
                        'last_name': registrationInstance.last_name,
                        'gender': registrationInstance.gender.gender_name if registrationInstance.gender else None,
                        'barcode': registrationInstance.barcode,
                        'registration_no': registrationInstance.registration_no,
                        'college_admission_no': registrationInstance.college_admission_no,
                        'course_name': siblingCourseInstance.course_name,
                        # 'department_name':
                        'section': siblingSectionInstance.section_name,
                    }
                    sibilings_details.append(sibling_data)
                except Exception as sibling_error:
                    continue

            # Process transport details
            transportDetails = {}
            if feeDetails.transport_availed:
                import ast
                choice_semester = feeDetails.choice_semester
                if choice_semester:
                    choice_semester = list(set(ast.literal_eval(choice_semester)))
                    # choice_month.remove(None)
                # if isinstance(choice_month, str):
                #     choice_month = choice_month.replace('[', '').replace(']', '').replace(' ', '')
                #     choice_month = list(map(int, choice_month.split(',')))
                else:
                    choice_semester = []

                choice_semester_list = []
                for item in choice_semester:
                    try:
                        semester_description = Semester.objects.get(id=item).semester_description
                        choice_semester_list.append(semester_description)
                    except Semester.DoesNotExist:
                        continue

                try:
                    routeDetailsInstance = RouteDetail.objects.get(id=feeDetails.route_id)
                    routemasterInstance = RouteMaster.objects.get(id=routeDetailsInstance.route_master.id)
                    pickuppointInstance = PickupPoint.objects.get(id=routeDetailsInstance.pickup_point.id)

                    transportDetails = {
                        'transport_availed': feeDetails.transport_availed,
                        'choice_semester_ids': choice_semester,
                        'choice_semester': choice_semester_list,
                        'routeId': routemasterInstance.id,
                        'routeName': routemasterInstance.transport_name,
                        'routeDetails': routeDetailsInstance.id,
                        'pickuppointName': pickuppointInstance.pickup_point_name,
                    }
                except (RouteDetail.DoesNotExist, RouteMaster.DoesNotExist, PickupPoint.DoesNotExist):
                    pass

            # Prepare the response data
            try:
                response_data = {
                    'student_basic_details': {
                        'id': student_instance.id,
                        'first_name': student_instance.first_name,
                        'middle_name': student_instance.middle_name,
                        'last_name': student_instance.last_name,
                        'organization_id': student_instance.organization.id,
                        'organization_description': student_instance.organization.organization_description,
                        'branch_id': student_instance.branch.id,
                        'branch_name': student_instance.branch.branch_name,
                        'batch_id': student_instance.batch.id,
                        'batch_name': student_instance.batch.batch_code,
                        'admission_type': student_instance.admission_type,
                        'course_id': courseInstance.id,
                        'course_name': courseInstance.course_name,
                        'department_id': student_instance.department.id,
                        'department_description': student_instance.department.department_description,
                        'academic_year_id': academicyearInstance.id,
                        'academic_year': academicyearInstance.academic_year_code,
                        'semester_id': student_instance.semester.id,
                        'semester_description': student_instance.semester.semester_description,
                        'section_id': sectionInstance.id,
                        'section_name': sectionInstance.section_name,
                        'admission_no': student_instance.admission_no,
                        'gender_id': student_instance.gender.id if student_instance.gender else None,
                        'gender_name': student_instance.gender.gender_name if student_instance.gender else None,
                        'date_of_admission': student_instance.date_of_admission,
                        'date_of_join': student_instance.date_of_join,
                        'barcode': student_instance.barcode,
                        'registration_no': student_instance.registration_no,
                        'college_admission_no': student_instance.college_admission_no,
                        # 'cbse_reg_no': student_instance.cbse_reg_no,
                        'house_id': student_instance.house.id if student_instance.house else None,
                        'house_name': student_instance.house.house_name if student_instance.house else None,
                        'religion_id': student_instance.religion.id if student_instance.religion else None,
                        'religion_name': student_instance.religion.religion_name if student_instance.religion else None,
                        'category_id': student_instance.category.id if student_instance.category else None,
                        'category_name': student_instance.category.category_name if student_instance.category else None,
                        'mother_tongue_id': student_instance.mother_tongue.id if student_instance.mother_tongue else None,
                        'mother_tongue': student_instance.mother_tongue.mother_tongue_name if student_instance.mother_tongue else None,
                        'enrollment_no': student_instance.enrollment_no,
                        'primary_guardian': student_instance.primary_guardian,
                        'status': student_instance.status,
                        'blood_group_id': student_instance.blood.id if student_instance.blood else None,
                        'blood_group': student_instance.blood.blood_name if student_instance.blood else None,
                        'nationality_id': student_instance.nationality.id if student_instance.nationality else None,
                        'nationality_name': student_instance.nationality.nationality_name if student_instance.nationality else None,
                        'email': student_instance.email,
                        'date_of_birth': student_instance.date_of_birth,
                        'children_in_family': student_instance.children_in_family,
                        'student_aadhaar_no': student_instance.student_aadhaar_no,
                        'username': student_instance.user_name,
                        'remarks': student_instance.remarks,
                        'profile_pic': request.build_absolute_uri(
                            student_instance.profile_pic.url) if student_instance.profile_pic else None,
                        'father_name': student_instance.father_name,
                        'father_profession': student_instance.father_profession,
                        'father_contact_number': student_instance.father_contact_number,
                        'father_email': student_instance.father_email,
                        'father_aadhaar_no': student_instance.father_aadhaar_no,
                        'mother_name': student_instance.mother_name,
                        'mother_profession': student_instance.mother_profession,
                        'mother_contact_number': student_instance.mother_contact_number,
                        'mother_email': student_instance.mother_email,
                        'mother_aadhaar_no': student_instance.mother_aadhaar_no,
                        'is_active': student_instance.is_active,
                        'created_by': student_instance.created_by,
                    },
                    'fee_details': {
                        'feegroupId': feemasterInstance.id if feemasterInstance else None,
                        'feegroup': feemasterInstance.fee_structure_code if feemasterInstance else None,
                        'semester_id': semesterInstance.id if semesterInstance else None,
                        'fee_applied_from': semesterInstance.semester_description if semesterInstance else None,
                    },
                    'transportDetails': transportDetails if transportDetails else {},
                    'address_details': AddressDetailsSerializer(addressDetails, many=True).data,
                    'sibilings_details': sibilings_details if sibilingsDetails else [],
                    'emergency_contact': StudentEmergencyContactDetailsSerializer(emegencyContact, many=True).data,
                    'authorized_pickup': AuthorisedPickupDetailsSerializer(authorizedpickup, many=True).data,
                    'documents_details': StudentDocumentDetailsSerializer(documentsDetails, many=True).data,
                    'previous_education_details': StudentPreviousEducationDetailsSerializer(previousEducationDetails,
                                                                                            many=True).data,
                }
            except Exception as e:
                print(str(e))
                return str(e)

            return Response({'message': 'success', 'data': response_data}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='StudentGetBasedOnId',
            message=error_message,
        )


# class StudentRegistrationBasedOnIdAPIView(RetrieveAPIView):
#     serializer_class = StudentBasicDetailSerializer
#
#     def get_object(self):
#         student_id = self.kwargs.get('student_id')
#         try:
#             # Fetching the registration instance based on student_id and is_active status
#             return StudentRegistration.objects.get(id=student_id, is_active=True)
#         except StudentRegistration.DoesNotExist:
#             raise NotFound("Student not found.")
#
#     def retrieve(self, request, *args, **kwargs):
#         try:
#             # Retrieve the main student registration object
#             student_instance = self.get_object()
#             #print(student_instance)
#
#             # Fetch related details
#             try:
#                 feeDetails = StudentCourse.objects.get(student_id=student_instance.id, is_active=True)
#                 #print(feeDetails)
#             except StudentCourse.DoesNotExist:
#                 raise NotFound("The student ID was not found.")
#
#             # Fetch academic year name
#             try:
#                 academicyearInstance = AcademicYear.objects.get(id=student_instance.academic_year.id)
#             except AcademicYear.DoesNotExist:
#                 raise NotFound("The Academic year ID was not found.")
#
#             # Fetch class name
#             try:
#                courseInstance = Course.objects.get(id=student_instance.addmitted_class.id)
#             except Course.DoesNotExist:
#                 raise NotFound("The class ID was not found.")
#
#
#             # Fetch section name
#             try:
#                 sectionInstance = Section.objects.get(id=student_instance.addmitted_section.id)
#             except Section.DoesNotExist:
#                 raise NotFound("The Section ID was not found.")
#
#             try:
#                 feemasterInstance= FeeStructureMaster.objects.get(id=feeDetails.fee_group)
#             except FeeStructureMaster.DoesNotExist:
#                 raise NotFound("The fee_group ID was not found.")
#
#             try:
#                 periodInstance = Period.objects.get(id=feeDetails.feeappfrom)
#                 periodInstance = Period.objects.get(id=feeDetails.feeappfrom)
#             except Period.DoesNotExist:
#                 raise NotFound("The fee_group ID was not found.")
#
#             #  Get Student Details on student_class
#             try:
#                 studentcourseInstance = StudentCourse.objects.get(student_id=student_instance.id, is_active=True)
#             except StudentCourse.DoesNotExist:
#                 raise NotFound("The student ID was not found on student class.")
#
#             # Fetch other related details
#             addressDetails = Address.objects.filter(reference_id=student_instance.id, is_active=True)
#             sibilingsDetails = SiblingDetail.objects.filter(student_id=student_instance.id, is_active=True)
#             emegencyContact = StudentEmergencyContact.objects.filter(student_id=student_instance.id, is_active=True)
#             authorizedpickup = AuthorisedPickup.objects.filter(student_id=student_instance.id, is_active=True)
#             documentsDetails = StudentDocument.objects.filter(student_id=student_instance.id, is_active=True)
#             previousEducationDetails = StudentPreviousEducation.objects.filter(student_id=student_instance.id,
#                                                                                  is_active=True)
#             #print(sibilingsDetails)
#
#             sibilings_details=[]
#             for sibilings in sibilingsDetails:
#                 RegistrationInstance = StudentRegistration.objects.get(id=sibilings.student_id.id,is_active=True)
#
#                 StudentCourseInstance = StudentCourse.objects.get(student_id_id=sibilings.student_id,is_active=True)
#                courseInstance = Course.objects.get(id=StudentCourseInstance.addmitted_class.id)
#                 sectionInstance = Section.objects.get(id=StudentCourseInstance.addmitted_section.id)
#
#                 sibilingsdata={
#                     'id':sibilings.sibling_id.id,
#                     'admission_no': RegistrationInstance.admission_no,
#                     'first_name': RegistrationInstance.first_name,
#                     'middle_name': RegistrationInstance.middle_name,
#                     'last_name': RegistrationInstance.last_name,
#                     'gender': RegistrationInstance.gender,
#                     'barcode': RegistrationInstance.barcode,
#                     'registration_no': RegistrationInstance.registration_no,
#                     'college_admission_no': RegistrationInstance.college_admission_no,
#                     'classname':courseInstance.classname,
#                     'section': sectionInstance.sectionname,
#
#                 }
#
#                 sibilings_details.append(sibilingsdata)
#
#             # Transport Process Details
#             choicMonthList = []
#             if studentcourseInstance.transport_availed == True:
#
#                 choice_month = studentcourseInstance.choice_month
#                 if isinstance(choice_month,str):
#                     choice_month = choice_month.replace('[', '').replace(']', '').replace(' ', '')
#                     choice_month = list(map(int,choice_month.split(',')))
#                 else:
#                     pass
#
#
#                 for item in choice_month:
#
#                     periodname = Period.objects.get(id=item).period_name
#
#                     choicMonthList.append(periodname)
#
#                 routeDetailsInstance = RouteDetail.objects.get(id=studentcourseInstance.route_id)
#
#                 routemasterInstance = RouteMaster.objects.get(id=routeDetailsInstance.route_master_id.id)
#
#                 # Get pickup point
#                 pickuppointInstance = PickupPoint.objects.get(id=routeDetailsInstance.pickup_point_id.id)
#
#                 transportDetails={
#                     'transportavailed':studentcourseInstance.transport_availed,
#                     'choiceMonthIds': choice_month,
#                     'choiceMonth': choicMonthList,
#                     'routeId': routemasterInstance.id,
#                     'routeName': routemasterInstance.transport_name,
#                     'routedetails': routeDetailsInstance.id,
#                     'pickuppointName': pickuppointInstance.pickup_point_name,
#                 }
#
#             # Prepare the response data
#             response_data = {
#                 'student_basic_details': {
#                     'id': student_instance.id,
#                     'academic_year': academicyearInstance.sesion_code,  # Pass the academic year name
#                     'admission_no': student_instance.admission_no,
#                     'first_name': student_instance.first_name,
#                     'middle_name': student_instance.middle_name,
#                     'last_name': student_instance.last_name,
#                     'course_id':courseInstance.id,
#                     'addmitted_class':courseInstance.classname,  # Pass the class name
#                     'section_id': sectionInstance.id,
#                     'addmitted_section': sectionInstance.sectionname,  # Pass the section name
#                     'gender': student_instance.gender,
#                     'date_of_admission': student_instance.date_of_admission,
#                     'doj': student_instance.doj,
#                     'barcode': student_instance.barcode,
#                     'registration_no': student_instance.registration_no,
#                     'college_admission_no': student_instance.college_admission_no,
#                     'cbse_reg_no': student_instance.cbse_reg_no,
#                     'house': student_instance.house,
#                     'religion': student_instance.religion,
#                     'category': student_instance.category,
#                     'nativelanguage': student_instance.nativelanguage,
#                     'enrollment_no': student_instance.enrollment_no,
#                     'primary_guardian': student_instance.primary_guardian,
#                     'student_status': student_instance.student_status,
#                     'bloodgroup': student_instance.bloodgroup,
#                     'nationality': student_instance.nationality,
#                     'email': student_instance.email,
#                     'dob': student_instance.dob,
#                     'childreninfamily': student_instance.childreninfamily,
#                     'studentaadharno': student_instance.studentaadharno,
#                     'username': student_instance.username,
#                     'remarks': student_instance.remarks,
#                     'profile_pic': student_instance.profile_pic if student_instance.profile_pic else None,
#                     'father_name': student_instance.father_name,
#                     'father_profession': student_instance.father_profession,
#                     'father_contact_number': student_instance.father_contact_number,
#                     'father_email': student_instance.father_email,
#                     'father_aadharno': student_instance.father_aadharno,
#                     'mother_name': student_instance.mother_name,
#                     'mother_profession': student_instance.mother_profession,
#                     'mother_contact_number': student_instance.mother_contact_number,
#                     'mother_email': student_instance.mother_email,
#                     'mother_aadharno': student_instance.mother_aadharno,
#                     'is_active': student_instance.is_active,
#                     'created_by': student_instance.created_by
#                 },
#                 'fee_details': {
#                     'feegroupId': feemasterInstance.id,
#                     'feegroup':feemasterInstance.fee_structure_code ,
#                     'periodId': periodInstance.id,
#                     'feeappfrom': periodInstance.period_name
#                 },
#                 'transportDetails':transportDetails,
#                 'address_details': AddressDetailsSerializer(addressDetails, many=True).data,
#                 'sibilings_details': sibilings_details, #StudentSibilingsDetailsSerializer(sibilingsDetails, many=True).data,
#                 'emergency_contact': StudentEmergencyContactDetailsSerializer(emegencyContact, many=True).data,
#                 'authorized_pickup': AuthorisedPickupDetailsSerializer(authorizedpickup, many=True).data,
#                 'documents_details': StudentDocumentDetailsSerializer(documentsDetails, many=True).data,
#                 'previous_education_details': StudentPreviousEducationDetailsSerializer(previousEducationDetails,
#                                                                                         many=True).data
#             }
#
#             # Return the response data
#             return Response({'message':'success','data':response_data},status=status.HTTP_200_OK)
#         except Http404:
#
#             return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)
#
#         except Exception as e:
#
#             # Log the exception
#
#             error_message = str(e)
#
#             self.log_exception(request, error_message)
#
#             return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#     def log_exception(self, request, error_message):
#
#         ExceptionTrack.objects.create(
#
#             request=str(request),
#
#             process_name='StudentGetBasedOnId',
#
#             message=error_message,
#
#         )

class GetPreviousAcademicYearBasedOnCurrentAcademicYearListAPIView(ListAPIView):
    serializer_class = AcademicYearSerializer

    def get_queryset(self):
        academicyearId = self.kwargs.get('academic_year_id')
        organization = self.kwargs.get('organization')
        # branchId = self.kwargs.get('branch_id')

        # Attempt to get the current academic year instance
        try:
            academicyearInstance = AcademicYear.objects.get(id=academicyearId)
        except AcademicYear.DoesNotExist:
            raise NotFound("The provided academic year ID was not found.")

        # Retrieve the previous academic year with the closest `date_to` that's less than the current years `date_from`
        previous_academic_year = AcademicYear.objects.filter(
            date_to__lt=academicyearInstance.date_from,
            is_active=True,
            organization=organization,
            # branch_id=branchId
        ).exclude(id=academicyearId).order_by('-date_to').first()

        # Return a QuerySet or an empty list if no previous academic year is found
        return [previous_academic_year] if previous_academic_year else []

    def list(self, request, *args, **kwargs):
        try:
            # Get the queryset with the closest previous academic year
            queryset = self.get_queryset()

            # Serialize the queryset
            serializer = self.get_serializer(queryset, many=True)
            response_data = serializer.data

            if response_data:
                # Return the response with serialized data
                return Response({'message': 'success', 'data': response_data}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Previous year available!!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='PreviousAcademicYearList',
            message=error_message,
        )


class FrequencyPeriodListAPIView(ListAPIView):
    queryset = FeeFrequency.objects.all()
    serializer_class = FeeFrequencySerializer

    def get_queryset(self):
        queryset = FeeFrequency.objects.filter(is_active=True)
        
        # Apply filters if provided in query params
        organization = self.request.query_params.get('organization')
        branch = self.request.query_params.get('branch')
        batch = self.request.query_params.get('batch')
        course = self.request.query_params.get('course')
        department = self.request.query_params.get('department')
        
        if organization:
            queryset = queryset.filter(organization=organization)
        if branch:
            queryset = queryset.filter(branch=branch)
        if batch:
            queryset = queryset.filter(batch=batch)
        if course:
            queryset = queryset.filter(course=course)
        if department:
            queryset = queryset.filter(department=department)
            
        return queryset

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            if resdata:
                responsedata = []
                for item in resdata:
                    if item.get('is_active') == True:

                        # # Get Data
                        # organization = item.get('organization')
                        # branch_id = item.get('branch_id')
                        #
                        #
                        # Organization_instance = Organization.objects.get(pk=organization)
                        #
                        # branch_instance = Branches.objects.get(pk=branch_id)

                        # Prepare the custom response data
                        responsedata.append({
                            'id': item.get('id'),
                            'fee_frequency_name': item.get('fee_frequency_name'),
                            'frequency_period': item.get('frequency_period'),
                            # 'organization': Organization_instance.id,
                            # 'organizationCode': Organization_instance.organization_code,
                            # 'branchId': branch_instance.id,
                            # 'branchName':branch_instance.branch_name,
                        })
                    else:
                        continue
                if responsedata:

                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='FrequencyPeriodlist',
            message=error_message,
        )


class CopyFeeStructureToDifferentCourse(CreateAPIView):
    serializer_class = CopyFeeStructureSerializers

    @transaction.atomic
    def create(self, request, *args, **kwargs):
        try:
            with transaction.atomic():

                # Get Validate Data
                serializers = self.get_serializer(data=request.data)
                serializers.is_valid(raise_exception=True)

                organization_id = serializers.validated_data.get('organization_id')
                branch_id = serializers.validated_data.get('branch_id')
                loginUser = serializers.validated_data.get('loginUser')

                # academicyearId = serializers.validated_data.get('academicyearId')

                previous_fee_structure_ids = serializers.validated_data.get('previous_fee_structure_ids')
                batch_ids = serializers.validated_data.get('batch_ids')
                course_ids = serializers.validated_data.get('course_ids')
                department_ids = serializers.validated_data.get('department_ids')
                academic_year_ids = serializers.validated_data.get('academic_year_ids')
                semester_ids = serializers.validated_data.get('semester_ids')
                fee_frequency_list = serializers.validated_data.get('fee_frequency_list')
                # current_academicyearId = academicyearId+1

                # AcademicYearInstance = AcademicYear.objects.get(id=current_academicyearId)
                # feestructureId = 39
                # print(academicyearId,feestructureId,course_ids)
                # Get fee structure Instance
                # FeeStructureInstance = FeeStructureMaster.objects.get(id=feestructureId,academic_year_id=academicyearId)
                # FeeStructureInstance = FeeStructureMaster.objects.filter(course_id__in=course_ids,academic_year_id=academicyearId)
                PreviousFeeStructureInstance = FeeStructureMaster.objects.filter(organization=organization_id,
                                                                                 branch=branch_id,
                                                                                 id__in=previous_fee_structure_ids)

                # print(FeeStructureInstance)
                PreviousFeeStructureDetails = []
                for item in PreviousFeeStructureInstance:
                    PreviousFeeStructureDetails.append(
                        FeeStructureDetail.objects.filter(fee_structure_master__organization=organization_id,
                                                          fee_structure_master__branch=branch_id,
                                                          fee_structure_master=item))

                for batch_id, course_id, department_id, academic_year_id, semester_id in zip(batch_ids, course_ids,
                                                                                             department_ids,
                                                                                             academic_year_ids,
                                                                                             semester_ids):
                    batchInstance = Batch.objects.get(organization=organization_id, branch=branch_id, id=batch_id)
                    courseInstance = Course.objects.get(organization=organization_id, branch=branch_id, id=course_id)
                    departmentInstance = Department.objects.get(organization=organization_id, branch=branch_id,
                                                                id=department_id)
                    academicYearInstance = AcademicYear.objects.get(organization=organization_id, branch=branch_id,
                                                                    id=academic_year_id)
                    semesterInstance = Semester.objects.get(organization=organization_id, branch=branch_id,
                                                            id=semester_id)
                    # for cls in course_ids:
                    #     courseInstance = Course.objects.get(id=cls)
                    for PreviousFeeStructure, PreviousFeeStructureDetail, fee_frequency in product(
                            PreviousFeeStructureInstance, PreviousFeeStructureDetails, fee_frequency_list):
                        feeMasterStructureInstance = FeeStructureMaster.objects.create(
                            fee_structure_code=PreviousFeeStructure.fee_structure_code,
                            fee_structure_description=PreviousFeeStructure.fee_structure_description,
                            # academic_year_id=FeeStructureInstance.academic_year_id,

                            organization=PreviousFeeStructure.organization,
                            branch=PreviousFeeStructure.branch,
                            batch=batchInstance,
                            course=courseInstance,
                            department=departmentInstance,
                            academic_year=academicYearInstance,
                            semester=semesterInstance,
                            enabled=PreviousFeeStructure.enabled,
                            version_no=PreviousFeeStructure.version_no,
                            category=PreviousFeeStructure.category,
                            new_existing=PreviousFeeStructure.new_existing,
                            created_by=loginUser,
                            updated_by=loginUser
                        )
                        for item in PreviousFeeStructureDetail:
                            # for item in record:
                            feeStructureDetailsInstance = FeeStructureDetail.objects.create(
                                fee_structure_master=feeMasterStructureInstance,
                                element_type=item.element_type,
                                element_frequency=item.element_frequency,
                                amount=item.amount,
                                semester_1=fee_frequency[0] if fee_frequency[0] else None,
                                semester_2=fee_frequency[1] if fee_frequency[1] else None,
                                semester_3=fee_frequency[2] if fee_frequency[2] else None,
                                semester_4=fee_frequency[3] if fee_frequency[3] else None,
                                semester_5=fee_frequency[4] if fee_frequency[4] else None,
                                semester_6=fee_frequency[5] if fee_frequency[5] else None,
                                semester_7=fee_frequency[6] if fee_frequency[6] else None,
                                semester_8=fee_frequency[7] if fee_frequency[7] else None,
                                created_by=loginUser,
                                updated_by=loginUser
                            )
                            # else:
                            #     feeStructureDetailsInstance = FeeStructureDetail.objects.create(
                            #         FeeStructureMaster_id=feeMasterStructureInstance,
                            #         element_type_id=record.element_type_id,
                            #         element_frequency=record.element_frequency,
                            #         amount=record.amount,
                            #         period_1=record.period_1,
                            #         period_2=record.period_2,
                            #         period_3=record.period_3,
                            #         period_4=record.period_4,
                            #         period_5=record.period_5,
                            #         period_6=record.period_6,
                            #         created_by=loginUser,
                            #         updated_by=loginUser
                            #     )

                return Response({'message': 'Fees applied successfully on selected classes!!'},
                                status=status.HTTP_200_OK)


        except ValidationError as e:
            # Rollback the transaction on validation error

            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:

            # Rollback the transaction on database error

            self.log_exception(request, str(e))

            return Response({'error': 'A database error occurred: ' + str(e)},

                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:

            # Rollback the transaction on any other exception

            self.log_exception(request, str(e))

            return Response({'error': 'An unexpected error occurred: ' + str(e)},

                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='CopyFeeStructureforCoursees',

            message=error_message,

        )


class GetFeeDetailsBasedOnFeeMasterListAPIView(ListAPIView):
    serializer_class = FeeStructureMasterRequestSerializer

    def list(self, request, *args, **kwargs):
        try:
            # Get the fee structure master ID from the URL
            feestructuremasterId = self.kwargs.get('FeeStructureMaster_id')

            # Retrieve the fee master instance
            try:
                feemasterInstance = FeeStructureMaster.objects.get(id=feestructuremasterId)
            except FeeStructureMaster.DoesNotExist:
                return Response({"error": "Fee master not found."}, status=status.HTTP_404_NOT_FOUND)

            # Get related class name (assuming Course model has a 'name' field)
            course_name = Course.objects.get(id=feemasterInstance.course_id.id).course_name

            # Get related organization name (assuming Organization model has a 'name' field)
            organizationname = Organization.objects.get(id=feemasterInstance.organization.id).organization_code

            # branch name
            # branchname = Branches.objects.get(id=feemasterInstance.branch_id.id).branch_name

            # Academic year name
            sessioncode = AcademicYear.objects.get(id=feemasterInstance.academic_year_id.id).academic_year_code

            # Get the fee structure details related to this fee master
            feedetailsData = FeeStructureDetail.objects.filter(FeeStructureMaster_id=feemasterInstance)

            feeDetailsresponseData = []

            for item in feedetailsData:
                ElementTypename = FeeElementType.objects.get(id=item.element_type_id.id).element_name
                FrequencyTypeName = FeeFrequency.objects.get(id=item.element_frequency.id).FeeFrequency_name

                feestructuredata = {
                    'id': item.id,
                    'element_type_id': item.element_type_id.id,
                    'element_type_name': ElementTypename,
                    'element_frequency': item.element_frequency.id,
                    'element_frequency_name': FrequencyTypeName,
                    'amount': item.amount,
                    'period_1': item.period_1,
                    'period_2': item.period_2,
                    'period_3': item.period_3,
                    'period_4': item.period_4,
                    'period_5': item.period_5,
                    'period_6': item.period_6,
                    'adjustment_flag': item.adjustment_flag,

                }
                feeDetailsresponseData.append(feestructuredata)

            responsedata = {
                'feemasterStructureDetails': {
                    'id': feemasterInstance.id,
                    'fee_structure_code': feemasterInstance.fee_structure_code,
                    'fee_structure_desc': feemasterInstance.fee_structure_desc,
                    'enabled': feemasterInstance.enabled,
                    'organization': feemasterInstance.organization.id,
                    'organization_code': organizationname,
                    # 'branch_id': feemasterInstance.branch_id.id,
                    # 'branchname':branchname,
                    'course_id': feemasterInstance.course.id,
                    'course_name': course_name,
                    'academic_year_id': feemasterInstance.academic_year.id,
                    'academicYear': sessioncode,
                    'version_no': feemasterInstance.version_no,
                    'category_code': feemasterInstance.category_code,
                    'new_existing': feemasterInstance.new_existing,

                },
                'feestructureDetails': feeDetailsresponseData
            }

            return Response({'message': 'success', 'data': responsedata}, status=status.HTTP_200_OK)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='feestructuremasterfeestructureDetailsGet',

            message=error_message,

        )


class ClubGroupFilterAPIView(ListAPIView):
    # serializer_class = GetClubBasedOnCourseDepartmentSerializer
    serializer_class = GetClubGroupSerializer

    def list(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.query_params)
            serializer.is_valid(raise_exception=True)

            organization_id = serializer.validated_data.get('organization_id')
            branch_id = serializer.validated_data.get('branch_id')
            club_group_id = serializer.validated_data.get('club_group_id')

            if organization_id and branch_id:
                filterdata = ClubGroup.objects.filter(
                    organization=organization_id,
                    branch=branch_id,
                    is_active=True)
            else:
                return Response({'message': "organization_id and branch_id is required !!!"},
                                status=status.HTTP_400_BAD_REQUEST)

            if club_group_id:
                filterdata = filterdata.filter(id=club_group_id)
            # if not serializer.validated_data.get('section_id'):
            #     try:
            #         CourseClubsInstance_record = Club.objects.filter(
            #             organization=serializer.validated_data.get('organization'),
            #             branch=serializer.validated_data.get('branch_id'),
            #             # academic_year_id=serializer.validated_data.get('academic_year_id'),
            #             # subject_group_id=serializer.validated_data.get('subject_group_id'),
            #             # course_id=serializer.validated_data.get('course_id'),
            #             is_active=True)
            #     except:
            #         CourseClubsInstance_record = []
            #
            # else:
            #     try:
            #         CourseClubsInstance_record = Club.objects.filter(
            #             organization=serializer.validated_data.get('organization'),
            #             branch=serializer.validated_data.get('branch_id'),
            #             # academic_year=serializer.validated_data.get('academic_year_id'),
            #             # club_group_id=serializer.validated_data.get('club_group_id'),
            #             # course_id=serializer.validated_data.get('course_id'),
            #             # section_id=serializer.validated_data.get('section_id'),
            #             is_active=True)
            #     except:
            #         CourseClubsInstance_record = []

            if filterdata:

                response_data = []
                # unique_id = set()

                for item in filterdata:
                    # if item.is_active == True and item.id not in unique_id:

                    data = {
                        'organization_id': item.organization.id,
                        'organization': item.organization.organization_description,
                        'branch_id': item.branch.id,
                        'branch': item.branch.branch_name,
                        'club_group_id': item.id,
                        'club_group_code': item.club_group_code,
                        'club_group_description': item.club_group_description
                    }

                    response_data.append(data)
                    # unique_id.add(item.id)
                    # else:
                    #     continue

                return Response({'message': 'success', 'data': response_data}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found'}, status=status.HTTP_204_NO_CONTENT)

        except ValidationError as e:

            return Response({'message': e.detail}, status=status.HTTP_400_BAD_REQUEST)


        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='class-club-filter',

            message=error_message,

        )


class ClubFilterAPIView(ListAPIView):
    # serializer_class = GetClubBasedOnCourseDepartmentSerializer
    serializer_class = GetClubSerializer

    def list(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.query_params)
            serializer.is_valid(raise_exception=True)

            organization_id = serializer.validated_data.get('organization_id')
            branch_id = serializer.validated_data.get('branch_id')
            club_group_id = serializer.validated_data.get('club_group_id')
            club_id = serializer.validated_data.get('club_id')

            if organization_id and branch_id:
                filterdata = Club.objects.filter(
                    organization=organization_id,
                    branch=branch_id,
                    # academic_year_id=serializer.validated_data.get('academic_year_id'),
                    # subject_group_id=serializer.validated_data.get('subject_group_id'),
                    # course_id=serializer.validated_data.get('course_id'),
                    is_active=True)
            else:
                return Response({'message': "organization_id and branch_id is required !!!"},
                                status=status.HTTP_400_BAD_REQUEST)

            if club_group_id:
                filterdata = filterdata.filter(club_group=club_group_id)

            if club_id:
                filterdata = filterdata.filter(id=club_id)
            # if not serializer.validated_data.get('section_id'):
            #     try:
            #         CourseClubsInstance_record = Club.objects.filter(
            #             organization=serializer.validated_data.get('organization'),
            #             branch=serializer.validated_data.get('branch_id'),
            #             # academic_year_id=serializer.validated_data.get('academic_year_id'),
            #             # subject_group_id=serializer.validated_data.get('subject_group_id'),
            #             # course_id=serializer.validated_data.get('course_id'),
            #             is_active=True)
            #     except:
            #         CourseClubsInstance_record = []
            #
            # else:
            #     try:
            #         CourseClubsInstance_record = Club.objects.filter(
            #             organization=serializer.validated_data.get('organization'),
            #             branch=serializer.validated_data.get('branch_id'),
            #             # academic_year=serializer.validated_data.get('academic_year_id'),
            #             # club_group_id=serializer.validated_data.get('club_group_id'),
            #             # course_id=serializer.validated_data.get('course_id'),
            #             # section_id=serializer.validated_data.get('section_id'),
            #             is_active=True)
            #     except:
            #         CourseClubsInstance_record = []

            if filterdata:

                response_data = []
                # unique_id = set()

                for item in filterdata:
                    # if item.is_active == True and item.id not in unique_id:

                    data = {
                        'organization_id': item.organization.id,
                        'organization': item.organization.organization_description,
                        'branch_id': item.branch.id,
                        'branch': item.branch.branch_name,
                        'club_group_id': item.club_group.id,
                        'club_group': item.club_group.club_group_description,
                        'club_id': item.id,
                        'club_code': item.club_code,
                        'club_description': item.club_description
                    }

                    response_data.append(data)
                    # unique_id.add(item.id)
                    # else:
                    #     continue

                return Response({'message': 'success', 'data': response_data}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found'}, status=status.HTTP_204_NO_CONTENT)

        except ValidationError as e:

            return Response({'message': e.detail}, status=status.HTTP_400_BAD_REQUEST)


        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='class-club-filter',

            message=error_message,

        )


class CourseSubjectsFilterAPIView(ListAPIView):
    serializer_class = GetSubjectBasedOnCourseDepartmentSemesterSerializer

    def list(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.query_params)
            serializer.is_valid(raise_exception=True)

            # Required in serializer: organization_id, branch_id, batch_id
            organization_id = serializer.validated_data.get('organization_id')
            branch_id = serializer.validated_data.get('branch_id')
            batch_id = serializer.validated_data.get('batch_id')

            # Optional filters  if provided, they should just narrow down the search
            course_id = serializer.validated_data.get('course_id')
            department_id = serializer.validated_data.get('department_id')
            academic_year_id = serializer.validated_data.get('academic_year_id')  # currently not used on model
            semester_id = serializer.validated_data.get('semester_id')
            # subject_group_id = serializer.validated_data.get('subject_group_id')  # not present on CourseDepartmentSubject

            # Base queryset: always scoped to org/branch/batch and active records
            subjects_qs = CourseDepartmentSubject.objects.filter(
                organization_id=organization_id,
                branch_id=branch_id,
                batch_id=batch_id,
                is_active=True,
            )

            # Apply optional filters only when provided
            if course_id:
                subjects_qs = subjects_qs.filter(course_id=course_id)
            if department_id:
                subjects_qs = subjects_qs.filter(department_id=department_id)
            if semester_id:
                subjects_qs = subjects_qs.filter(semester_id=semester_id)
            # academic_year_id is ignored here because CourseDepartmentSubject has no academic_year field

            if subjects_qs.exists():
                response_data = []
                unique_codes = set()

                for item in subjects_qs:
                    # Ensure unique subjects by subject_code
                    if item.subject_code not in unique_codes:
                        data = {
                            'id': item.id,
                            'subjectcode': item.subject_code,
                            'subjectdescription': item.subject_description,
                        }
                        response_data.append(data)
                        unique_codes.add(item.subject_code)

                return Response({'message': 'success', 'data': response_data}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found'}, status=status.HTTP_200_OK)

        except ValidationError as e:

            return Response({'message': e.detail}, status=status.HTTP_400_BAD_REQUEST)


        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='class-subjects-filter',

            message=error_message,

        )


class GetSubjectsFilterByDepartmentAPIView(ListAPIView):
    serializer_class = GetSubjectBasedOnCourseDepartmentSemesterSerializer

    def list(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.query_params)
            serializer.is_valid(raise_exception=True)

            organization_id = serializer.validated_data.get('organization_id')
            branch_id = serializer.validated_data.get('branch_id')
            batch_id = serializer.validated_data.get('department_id')
            course_id = serializer.validated_data.get('course_id')
            department_id = serializer.validated_data.get('department_id')
            academic_year_id = serializer.validated_data.get('academic_year_id')
            semester_id = serializer.validated_data.get('semester_id')
            subject_group_id = serializer.validated_data.get('subject_group_id')

            # if organization_id and branch_id:
            #     CourseDepartmentSubjectInstance_record = CourseDepartmentSubject.objects.filter(
            #         organization=serializer.validated_data.get('organization_id'),
            #         branch=serializer.validated_data.get('branch_id'),is_active=True)
            # else:
            #     return Response()
            # if not serializer.validated_data.get('section_id'):
            if organization_id and branch_id and batch_id and course_id and department_id:
                try:
                    CourseDepartmentSubjectInstance_record = CourseDepartmentSubject.objects.filter(
                        organization=serializer.validated_data.get('organization_id'),
                        branch=serializer.validated_data.get('branch_id'),
                        batch=serializer.validated_data.get('batch_id'),
                        course=serializer.validated_data.get('course_id'),
                        department=serializer.validated_data.get('department_id'),
                        # academic_year=serializer.validated_data.get('academic_year_id'),
                        # subject_group_id=serializer.validated_data.get('subject_group_id'),

                        is_active=True)
                except:
                    CourseDepartmentSubjectInstance_record = []

            else:
                return Response(
                    {"message": "organization_id, branch_id, batch_id, course_id and department_id is required !!!"},
                    status=status.HTTP_400_BAD_REQUEST)
                # try:
                #     CourseDepartmentSubjectInstance_record = CourseDepartmentSubject.objects.filter(
                #         organization=serializer.validated_data.get('organization_id'),
                #         # branch_id=serializer.validated_data.get('branch_id'),
                #         academic_year_id=serializer.validated_data.get('academic_year_id'),
                #         subject_group_id=serializer.validated_data.get('subject_group_id'),
                #         course_id=serializer.validated_data.get('course_id'),
                #         section_id = serializer.validated_data.get('section_id'),
                #         is_active=True)
                # except:
                #     CourseSubjectsInstance_record=[]
                #

            if CourseDepartmentSubjectInstance_record:

                response_data = []
                unique_id = set()

                for item in CourseDepartmentSubjectInstance_record:
                    # if item.subject_master_id.is_active == True and item.subject_master_id.id not in unique_id:

                    data = {
                        'organization_id': item.organization.id,
                        'organization': item.organization.organization_description,
                        'branch_id': item.branch.id,
                        'branch': item.branch.branch_name,
                        'batch_id': item.batch.id,
                        'batch': item.batch.batch_code,
                        'course_id': item.course.id,
                        'course': item.course.course_name,
                        'department_id': item.department.id,
                        'department': item.department.department_description,
                        'academic_year_id': item.academic_year.id,
                        'academic_year': item.academic_year.academic_year_description,
                        'semester_id': item.semester.id,
                        'semester': item.semester.semester_description,
                        'id': item.id,
                        'subject_code': item.subject_code,
                        'subject_description': item.subject_description
                    }

                    response_data.append(data)
                    # unique_id.add(item.subject_master_id.id)
                    # else:
                    #     continue

                return Response({'message': 'success', 'data': response_data}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found'}, status=status.HTTP_204_NO_CONTENT)

        except ValidationError as e:

            return Response({'message': e.detail}, status=status.HTTP_400_BAD_REQUEST)


        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='get-subjects-by-department',

            message=error_message,

        )


class GetSubjectsBasedonLectureAPIView(ListAPIView):
    serializer_class = GetSubjectBasedOnLectureSerializer

    def list(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.query_params)
            serializer.is_valid(raise_exception=True)

            # Get and validate date parameter
            date = request.query_params.get('date')
            if not date:
                return Response({"error": "Date parameter is required."},
                                status=status.HTTP_400_BAD_REQUEST)
            
            try:
                date_obj = datetime.strptime(date, '%Y-%m-%d')
                day_of_week = date_obj.strftime('%A')  # Converts to full weekday name, e.g., "Monday"
            except ValueError:
                return Response({"error": "Invalid date format. Use 'YYYY-MM-DD'."},
                                status=status.HTTP_400_BAD_REQUEST)

            try:
                TimeTableInstance = TimeTable.objects.filter(
                    organization=serializer.validated_data.get('organization_id'),
                    branch=serializer.validated_data.get('branch_id'),
                    batch=serializer.validated_data.get('batch_id'),
                    course=serializer.validated_data.get(
                        'course_id'),
                    department=serializer.validated_data.get(
                        'department_id'),
                    academic_year=serializer.validated_data.get('academic_year_id'),
                    semester=serializer.validated_data.get('semester_id'),
                    section=serializer.validated_data.get('section_id'),
                    lecture_period=serializer.validated_data.get('lecture_id'),
                    schedule_day=day_of_week.lower(),
                    # subject_group_id=serializer.validated_data.get('subject_group_id'),

                    is_active=True)
            except Exception as e:
                # Log the specific database query error
                error_message = f"TimeTable query error: {str(e)}"
                self.log_exception(request, error_message)
                TimeTableInstance = []

            # else:
            #     try:
            #         CourseDepartmentSubjectInstance_record = TimeTable.objects.filter(
            #             organization=serializer.validated_data.get('organization_id'),
            #             # branch_id=serializer.validated_data.get('branch_id'),
            #             academic_year_id=serializer.validated_data.get('academic_year_id'),
            #             subject_group_id=serializer.validated_data.get('subject_group_id'),
            #             course_id=serializer.validated_data.get('course_id'),
            #             section_id = serializer.validated_data.get('section_id'),
            #             is_active=True)
            #     except:
            #         CourseSubjectsInstance_record=[]

            if TimeTableInstance:

                response_data = []
                unique_id = set()

                for item in TimeTableInstance:

                    # Check if subject exists and is active
                    if item.subject and item.subject.is_active == True and item.subject.id not in unique_id:

                        data = {
                            'id': item.subject.id,
                            'subjectcode': item.subject.subject_code,
                            'subjectdescription': item.subject.subject_description
                        }

                        response_data.append(data)
                        unique_id.add(item.subject.id)
                    else:
                        continue

                return Response({'message': 'success', 'data': response_data}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found'}, status=status.HTTP_204_NO_CONTENT)

        except ValidationError as e:

            return Response({'message': e.detail}, status=status.HTTP_400_BAD_REQUEST)


        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='class-subjects-filter',

            message=error_message,

        )


class GetStudentListBasedOnClub(ListAPIView):
    # serializer_class = GetStudentListBasedOnGroupCourseSubjectSerializer
    serializer_class = StudentListBasedOnClubSerializer

    def list(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.query_params)
            serializer.is_valid(raise_exception=True)

            organization_id = serializer.validated_data.get('organization_id')
            branch_id = serializer.validated_data.get('branch_id')
            batch_id = serializer.validated_data.get('batch_id')
            course_id = serializer.validated_data.get('course_id')
            department_id = serializer.validated_data.get('department_id')
            academic_year_id = serializer.validated_data.get('academic_year_id')
            semester_id = serializer.validated_data.get('semester_id')
            section_id = serializer.validated_data.get('section_id')
            club_group_id = serializer.validated_data.get('club_group_id')
            club_id = serializer.validated_data.get('club_id')
            student_id = serializer.validated_data.get('student_id')

            # Get all students from Student_Club
            # try:
            #     filterdata = StudentClub.objects.filter(
            #                     academic_year_id=serializer.validated_data.get('academic_year_id'),
            #                     student_id__organization= serializer.validated_data.get('organization'),
            #                     student_id__branch_id = serializer.validated_data.get('branch_id'),
            #                     subject_master_id= serializer.validated_data.get('subject_group_id'),
            #                     is_active=True).values_list('student_id', flat=True)
            # except:
            #     return Response({'message':'No student Record Found '},status=status.HTTP_204_NO_CONTENT)

            # Basic Filter student class

            if organization_id and branch_id:
                try:
                    studentCourseList = StudentCourse.objects.filter(organization=organization_id, branch=branch_id,
                                                                     is_active=True).order_by('-updated_at')
                except StudentCourse.DoesNotExist:
                    return Response({"message": "student course record not found !!!"},
                                    status=status.HTTP_404_NOT_FOUND)
            else:
                return Response({"message": "organization_id and branch_id is required !!!"},
                                status=status.HTTP_404_NOT_FOUND)

            # try:
            #     filterdata = StudentCourse.objects.filter(
            #         organization= organization_id,
            #         branch= branch_id,
            #         is_active=True
            #     )

            if batch_id:
                studentCourseList = studentCourseList.filter(batch=batch_id)

            if course_id:
                studentCourseList = studentCourseList.filter(course=course_id)

            if department_id:
                studentCourseList = studentCourseList.filter(department=department_id)

            if academic_year_id:
                studentCourseList = studentCourseList.filter(academic_year=academic_year_id)

            if semester_id:
                studentCourseList = studentCourseList.filter(semester=semester_id)

            if section_id:
                studentCourseList = studentCourseList.filter(section=section_id)

            # if club_group_id:
            #     filterdata = filterdata.filter(club_group=club_group_id)
            #
            # if club_id:
            #     filterdata = filterdata.filter(club=club_id)

            if student_id:
                studentCourseList = studentCourseList.filter(student=student_id)

            # except:
            #     return Response({'message':'No student Record Found '},status=status.HTTP_204_NO_CONTENT)

            # If provide class
            # if serializer.validated_data.get('course_id'):
            #     filterdata = filterdata.filter(course=serializer.validated_data.get('course_id'))

            # Filter Based On subject_group_id

            if club_group_id:
                existing_student_course_ids = StudentClub.objects.filter(
                    organization=organization_id,
                    branch=branch_id,
                    club_group=club_group_id,
                    is_active=True
                ).values_list('student_course', flat=True)
                studentCourseList = studentCourseList.filter(id__in=existing_student_course_ids)
            if club_id:
                # Get Particular subject_group_id Associated data
                existing_student_course_ids = StudentClub.objects.filter(
                    organization=organization_id,
                    branch=branch_id,
                    club=club_id,
                    is_active=True
                ).values_list('student_course', flat=True)
                studentCourseList = studentCourseList.filter(id__in=existing_student_course_ids)

            # if serializer.validated_data.get('section_id'):
            #     filterdata = filterdata.filter(section=serializer.validated_data.get('section_id'))
            #
            # if serializer.validated_data.get('student_id'):
            #     filterdata= filterdata.filter(student=serializer.validated_data.get('student_id'))

            # if serializer.validated_data.get('clubId'):
            #     filterdata = filterdata.filter(subject_master_id=serializer.validated_data.get('student_id'))
            #
            # try:
            #     filterdata = filterdata.filter

            if studentCourseList:
                response_data = []
                # filterdataIds = filterdata.values_list("student_id_id", flat=True)
                # StudentClubMaster = StudentClub.objects.filter(student_id_id__in=filterdataIds)
                count = 0
                for item in studentCourseList:
                    if item.student.first_name and item.student.middle_name and item.student.last_name:
                        student_name = item.student.first_name + ' ' + item.student.middle_name + ' ' + item.student.last_name
                    elif item.student.first_name and item.student.middle_name:
                        student_name = item.student.first_name + ' ' + item.student.middle_name
                    elif item.student.first_name and item.student.last_name:
                        student_name = item.student.first_name + ' ' + item.student.last_name
                    else:
                        student_name = item.student.first_name

                    try:
                        StudentClubData = StudentClub.objects.get(student_course=item, is_active=True)
                    except StudentClub.DoesNotExist:
                        StudentClubData = None
                    # StudentClubData = StudentClubMaster[count]
                    # if serializer.validated_data.get('subject_group_id'):
                    #     try:
                    #         StudentClubInstance= StudentClub.objects.get(student_id=item.student_id)
                    #     except Exception as e:
                    #         return Response({'message':str(e)},status=status.HTTP_400_BAD_REQUEST)

                    # SubjectMasterInstance = SubjectMaster.objects.get(id=ClubInstance.subject_master_id.id)
                    if StudentClubData is not None:
                        data = {
                            'student_id': item.student.id,
                            'course_name': item.course.course_name,
                            'section_name': item.section.section_name,
                            'enrollment_no': item.enrollment_no,
                            'studentName': student_name,
                            'college_admission_no': item.student.college_admission_no,
                            'registration_no': item.student.registration_no,
                            'barcode': item.student.barcode,
                            'father_name': item.student.father_name,
                            'mother_name': item.student.mother_name,
                            'house': item.house.house_name,
                            'club_group_id': StudentClubData.club_group.id,
                            'club_group': StudentClubData.club_group.club_group_description,
                            'club_id': StudentClubData.club.id,
                            'club': StudentClubData.club.club_description

                            # 'subjectname': StudentClubInstance.subject_master_id.subject_code if StudentClubInstance else ""
                        }
                    else:
                        data = {
                            'studentId': item.student.id,
                            'course_name': item.course.course_name,
                            'section_name': item.section.section_name,
                            'enrollment_no': item.enrollment_no,
                            'studentName': student_name,
                            'college_admission_no': item.student.college_admission_no,
                            'registration_no': item.student.registration_no,
                            'barcode': item.student.barcode,
                            'father_name': item.student.father_name,
                            'mother_name': item.student.mother_name,
                            'house': item.house.house_name,
                            'club_group_id': "",
                            'club_group': "",
                            'club_name': "",
                            'club_id': ""
                        }
                    response_data.append(data)
                return Response({'message': 'success', 'data': response_data}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found'}, status=status.HTTP_204_NO_CONTENT)

        except ValidationError as e:

            return Response({'message': e.detail}, status=status.HTTP_400_BAD_REQUEST)


        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='studentListBasedOnGroup',

            message=error_message,

        )


class GetStudentListBasedOnGroupCourseSubject(ListAPIView):
    # serializer_class = GetStudentListBasedOnGroupCourseSubjectSerializer
    serializer_class = GetStudentListBasedOnGroupCourseSubjectSerializer

    def list(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.query_params)
            serializer.is_valid(raise_exception=True)

            # Get all students from Student_Club
            # try:
            #     filterdata = StudentClub.objects.filter(
            #                     academic_year_id=serializer.validated_data.get('academic_year_id'),
            #                     student_id__organization= serializer.validated_data.get('organization'),
            #                     student_id__branch_id = serializer.validated_data.get('branch_id'),
            #                     subject_master_id= serializer.validated_data.get('subject_group_id'),
            #                     is_active=True).values_list('student_id', flat=True)
            # except:
            #     return Response({'message':'No student Record Found '},status=status.HTTP_204_NO_CONTENT)

            # Basic Filter student class
            try:
                filterdata = StudentCourse.objects.filter(
                    academic_year=serializer.validated_data.get('academic_year_id'),
                    student__organization=serializer.validated_data.get('organization'),
                    # student_id__branch_id= serializer.validated_data.get('branch_id'),
                    is_active=True
                )
            except:
                return Response({'message': 'No student Record Found '}, status=status.HTTP_204_NO_CONTENT)

            # If provide class
            if serializer.validated_data.get('course_id'):
                filterdata = filterdata.filter(course=serializer.validated_data.get('course_id'))

            # Filter Based On subject_group_id

            if serializer.validated_data.get('club_id'):
                # Get Particular subject_group_id Associated data
                existing_student_ids = StudentClub.objects.filter(
                    academic_year_id=serializer.validated_data.get('academic_year_id'),
                    student__organization=serializer.validated_data.get('organization'),
                    # student_id__branch_id = serializer.validated_data.get('branch_id'),
                    club_master_id=serializer.validated_data.get('club_id'),
                    is_active=True
                ).values_list('student', flat=True)
                filterdata = filterdata.filter(student_id__in=existing_student_ids)

            if serializer.validated_data.get('section_id'):
                filterdata = filterdata.filter(section=serializer.validated_data.get('section_id'))

            if serializer.validated_data.get('student_id'):
                filterdata = filterdata.filter(student=serializer.validated_data.get('student_id'))

            # if serializer.validated_data.get('clubId'):
            #     filterdata = filterdata.filter(subject_master_id=serializer.validated_data.get('student_id'))
            #
            # try:
            #     filterdata = filterdata.filter

            if filterdata:
                response_data = []
                # filterdataIds = filterdata.values_list("student_id_id", flat=True)
                # StudentClubMaster = StudentClub.objects.filter(student_id_id__in=filterdataIds)
                count = 0
                for item in filterdata:
                    if item.student.first_name and item.student.middle_name and item.student.last_name:
                        student_name = item.student.first_name + ' ' + item.student.middle_name + ' ' + item.student.last_name
                    elif item.student.first_name and item.student.middle_name:
                        student_name = item.student.first_name + ' ' + item.student.middle_name
                    elif item.student.first_name and item.student.last_name:
                        student_name = item.student.first_name + ' ' + item.student.last_name
                    else:
                        student_name = item.student.first_name

                    try:
                        StudentClubData = StudentClub.objects.get(student=item.student)
                    except StudentClub.DoesNotExist:
                        StudentClubData = None
                    # StudentClubData = StudentClubMaster[count]
                    # if serializer.validated_data.get('subject_group_id'):
                    #     try:
                    #         StudentClubInstance= StudentClub.objects.get(student_id=item.student_id)
                    #     except Exception as e:
                    #         return Response({'message':str(e)},status=status.HTTP_400_BAD_REQUEST)

                    # SubjectMasterInstance = SubjectMaster.objects.get(id=ClubInstance.subject_master_id.id)
                    if StudentClubData is not None:
                        data = {
                            'studentId': item.student.id,
                            'course_name': item.course.course_name,
                            'section_name': item.section.section_name,
                            'enrollment_no': item.enrollment_no,
                            'studentName': student_name,
                            'college_admission_no': item.student.college_admission_no,
                            'barcode': item.student.barcode,
                            'father_name': item.student.father_name,
                            'mother_name': item.student.mother_name,
                            'house': item.house,
                            'club_name': StudentClubData.club_master.club_code,
                            'club_id': StudentClubData.club_master.id

                            # 'subjectname': StudentClubInstance.subject_master_id.subject_code if StudentClubInstance else ""
                        }
                    else:
                        data = {
                            'studentId': item.student.id,
                            'course_name': item.course.course_name,
                            'section_name': item.section.section_name,
                            'enrollment_no': item.enrollment_no,
                            'studentName': student_name,
                            'college_admission_no': item.student.college_admission_no,
                            'barcode': item.student.barcode,
                            'father_name': item.student.father_name,
                            'mother_name': item.student.mother_name,
                            'house': item.house,
                            'club_name': "",
                            'club_id': ""
                        }
                    response_data.append(data)
                return Response({'message': 'success', 'data': response_data}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found'}, status=status.HTTP_204_NO_CONTENT)

        except ValidationError as e:

            return Response({'message': e.detail}, status=status.HTTP_400_BAD_REQUEST)


        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='studentListBasedOnGroup',

            message=error_message,

        )


# Student Club backup code

# class CourseSubjectsFilterAPIView(ListAPIView):
#     serializer_class = GetSubjectMasterListSerializer
#
#     def get_queryset(self):
#         organization = self.kwargs.get('organization')
#         branchId = self.kwargs.get('branch_id')
#         academicyearId = self.kwargs.get('academic_year_id')
#         SubjectGroupId = self.kwargs.get('subject_group_id')
#         course_id = self.kwargs.get('class_id')
#         section_id = self.kwargs.get('section_id')
#
#         if section_id == 0 or section_id == None:
#             CourseSubjectsInstance = CourseSubjects.objects.filter(organization=organization,branch_id=branchId,academic_year_id=academicyearId,subject_group_id=SubjectGroupId,class_id=course_id)
#         else:
#             CourseSubjectsInstance = CourseSubjects.objects.filter(organization=organization, branch_id=branchId,academic_year_id=academicyearId,subject_group_id=SubjectGroupId,
#                                                                        class_id=course_id,section_id=section_id)
#
#         return CourseSubjectsInstance
#
#     def list(self, request, *args, **kwargs):
#         try:
#             queryset = self.get_queryset()
#             responsedata = []
#             unique_id=set()
#             if queryset:
#                 for item in queryset:
#                     subjectmasterInstance = item.subject_master_id
#
#                     if subjectmasterInstance.is_active==True:
#                         if subjectmasterInstance.id not in unique_id:
#
#                             data={
#                                 'id':subjectmasterInstance.id,
#                                 'subjectcode': subjectmasterInstance.subject_code,
#                                 'subjectdescription': subjectmasterInstance.subject_description
#                             }
#                             responsedata.append(data)
#                             unique_id.add(subjectmasterInstance.id)
#                     else:
#                         continue
#
#
# return Response({'message': 'success', 'data': responsedata}, status=status.HTTP_200_OK)
#             else:
#                 return Response({'message': 'success', 'data': responsedata}, status=status.HTTP_200_OK)
#
#
#         except Http404:
#
#             return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)
#
#         except Exception as e:
#
#             # Log the exception
#
#             error_message = str(e)
#
#             self.log_exception(request, error_message)
#
#             return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#     def log_exception(self, request, error_message):
#
#         ExceptionTrack.objects.create(
#
#             request=str(request),
#
#             process_name='class-subjects-filter',
#
#             message=error_message,
#
#         )


# class GetStudentListBasedOnGroupCourseSubject(ListAPIView):
#     serializer_class = StudentGroupBasedOnCourseSection
#
#     def get_queryset(self):
#
#         organization = self.kwargs.get('organization')   # This field mandatory
#         branchId = self.kwargs.get('branch_id')  # This field mandatory
#         academicyearId = self.kwargs.get('academic_year_id')  # This field mandatory
#         course_id = self.kwargs.get('class_id')
#         section_id = self.kwargs.get('section_id')
#         SubjectMasterId = self.kwargs.get('subject_master_id')
#         studentId = self.kwargs.get('student_id')
#
#
#         if academicyearId and course_id==0 and section_id==0 and SubjectMasterId ==0 and studentId ==0:
#
#             student_CourseData= StudentCourse.objects.filter(academic_year=academicyearId,is_active=True)
#
#
#
#             # Exclude students who are already in StudentClub for the given academic year
#             existing_student_ids = StudentClub.objects.filter(
#                 academic_year_id=academicyearId,is_active=True
#             ).values_list('student_id', flat=True)
#
#
#
#             # Filter out students not in StudentClub
#             student_queryset = student_CourseData.exclude(student_id__in=existing_student_ids)
#             # print(student_queryset)
#
#             responsedata = []
#
#             for item in student_queryset:
#                # print(item.student_id.id)
#
#                 studentcourseInstance = StudentCourse.objects.get(student_id=item.student_id.id)
#                 #print(studentcourseInstance)
#                 studentregistrationinstance = StudentRegistration.objects.get(id=item.student_id.id)
#                # print(studentregistrationinstance)
#                courseInstance = Course.objects.get(id=studentcourseInstance.addmitted_class.id, is_active=True)
#                 sectionInstance = Section.objects.get(id=studentcourseInstance.addmitted_section.id, is_active=True)
#
#                 data={
#                     'studentId': studentcourseInstance.student_id.id,
#                     'classname':courseInstance.classname,
#                     'sectionname': sectionInstance.sectionname,
#                     'enrollment_no': studentcourseInstance.enrollment_no,
#                     'studentName': f'{studentregistrationinstance.first_name} {studentregistrationinstance.middle_name}{studentregistrationinstance.last_name}',
#                     'college_admission_no': studentregistrationinstance.college_admission_no,
#                     'barcode': studentregistrationinstance.barcode,
#                     'father_name': studentregistrationinstance.father_name,
#                     'mother_name': studentregistrationinstance.mother_name,
#                     'house': studentregistrationinstance.house,
#                     'subjectname':""
#                 }
#                 responsedata.append(data)
#
#             return responsedata
#
#         elif academicyearId and course_id and section_id==0 and SubjectMasterId ==0 and studentId==0:
#             student_CourseData = StudentCourse.objects.filter(academic_year=academicyearId, addmitted_class=course_id,is_active=True)
#
#
#             # Exclude students who are already in StudentClub for the given academic year
#             existing_student_ids = StudentClub.objects.filter(
#                 academic_year_id=academicyearId, is_active=True
#             ).values_list('student_id', flat=True)
#
#             # Filter out students not in StudentClub
#             student_queryset = student_CourseData.exclude(student_id__in=existing_student_ids)
#             # print(student_queryset)
#
#             responsedata = []
#
#             for item in student_queryset:
#                 studentcourseInstance = StudentCourse.objects.get(student_id=item.student_id.id)
#                 # print(studentcourseInstance)
#                 studentregistrationinstance = StudentRegistration.objects.get(id=item.student_id.id)
#                 # print(studentregistrationinstance)
#                courseInstance = Course.objects.get(id=studentcourseInstance.addmitted_class.id, is_active=True)
#                 sectionInstance = Section.objects.get(id=studentcourseInstance.addmitted_section.id, is_active=True)
#
#                 data = {
#                     'studentId': studentcourseInstance.student_id.id,
#                     'classname':courseInstance.classname,
#                     'sectionname': sectionInstance.sectionname,
#                     'enrollment_no': studentcourseInstance.enrollment_no,
#                     'studentName': f'{studentregistrationinstance.first_name} {studentregistrationinstance.middle_name}{studentregistrationinstance.last_name}',
#                     'college_admission_no': studentregistrationinstance.college_admission_no,
#                     'barcode': studentregistrationinstance.barcode,
#                     'father_name': studentregistrationinstance.father_name,
#                     'mother_name': studentregistrationinstance.mother_name,
#                     'house': studentregistrationinstance.house,
#                     'subjectname': ""
#                 }
#                 responsedata.append(data)
#
#             return responsedata
#         elif academicyearId and course_id and section_id and SubjectMasterId ==0 and studentId==0:
#             student_CourseData = StudentCourse.objects.filter(academic_year=academicyearId, addmitted_class=course_id,addmitted_section=section_id,
#                                                              is_active=True)
#
#             # Exclude students who are already in StudentClub for the given academic year
#             existing_student_ids = StudentClub.objects.filter(
#                 academic_year_id=academicyearId, is_active=True
#             ).values_list('student_id', flat=True)
#
#             # Filter out students not in StudentClub
#             student_queryset = student_CourseData.exclude(student_id__in=existing_student_ids)
#             # print(student_queryset)
#
#
#
#             responsedata = []
#
#             for item in student_queryset:
#                 studentcourseInstance = StudentCourse.objects.get(student_id=item.student_id.id)
#                 # print(studentcourseInstance)
#                 studentregistrationinstance = StudentRegistration.objects.get(id=item.student_id.id)
#                 # print(studentregistrationinstance)
#
#                courseInstance = Course.objects.get(id=studentcourseInstance.addmitted_class.id, is_active=True)
#                 sectionInstance = Section.objects.get(id=studentcourseInstance.addmitted_section.id, is_active=True)
#
#
#
#
#                 data = {
#                     'studentId': studentcourseInstance.student_id.id,
#                     'classname':courseInstance.classname,
#                     'sectionname': sectionInstance.sectionname,
#                     'enrollment_no': studentcourseInstance.enrollment_no,
#                     'studentName': f'{studentregistrationinstance.first_name} {studentregistrationinstance.middle_name}{studentregistrationinstance.last_name}',
#                     'college_admission_no': studentregistrationinstance.college_admission_no,
#                     'barcode': studentregistrationinstance.barcode,
#                     'father_name': studentregistrationinstance.father_name,
#                     'mother_name': studentregistrationinstance.mother_name,
#                     'house': studentregistrationinstance.house,
#                     'subjectname': ""
#                 }
#                 responsedata.append(data)
#
#             return responsedata
#
#         elif academicyearId and course_id and section_id and SubjectMasterId and studentId==0:
#             student_CourseData = StudentCourse.objects.filter(academic_year=academicyearId, addmitted_class=course_id,addmitted_section=section_id,
#                                                              is_active=True)
#             # print(student_CourseData)
#
#             # Exclude students who are already in StudentClub for the given academic year
#             existing_student_ids = StudentClub.objects.filter(
#                 academic_year_id=academicyearId,subject_master_id=SubjectMasterId, is_active=True
#             ).values_list('student_id', flat=True)
#
#             # print(existing_student_ids)
#
#             # Filter out students not in StudentClub
#             student_queryset = student_CourseData.filter(student_id__id__in=existing_student_ids)
#             # print(student_queryset)
#
#             responsedata = []
#
#             for item in student_queryset:
#
#                 studentcourseInstance = StudentCourse.objects.get(student_id=item.student_id.id)
#                 # print(studentcourseInstance)
#                 studentregistrationinstance = StudentRegistration.objects.get(id=item.student_id.id,is_active=True)
#
#                 studentclubInstance = StudentClub.objects.get(student_id=item.student_id.id,is_active=True)
#
#                 subjectmasterInstance = SubjectMaster.objects.get(id=studentclubInstance.subject_master_id.id,is_active=True)
#
#                courseInstance = Course.objects.get(id=studentcourseInstance.addmitted_class.id, is_active=True)
#
#                 sectionInstance = Section.objects.get(id=studentcourseInstance.addmitted_section.id, is_active=True)
#
#                 data = {
#                     'studentId': studentcourseInstance.student_id.id,
#                     'classname':courseInstance.classname,
#                     'sectionname': sectionInstance.sectionname,
#                     'enrollment_no': studentcourseInstance.enrollment_no,
#                     'studentName': f'{studentregistrationinstance.first_name} {studentregistrationinstance.middle_name}{studentregistrationinstance.last_name}',
#                     'college_admission_no': studentregistrationinstance.college_admission_no,
#                     'barcode': studentregistrationinstance.barcode,
#                     'father_name': studentregistrationinstance.father_name,
#                     'mother_name': studentregistrationinstance.mother_name,
#                     'house': studentregistrationinstance.house,
#                     'subjectname': subjectmasterInstance.subject_code
#                 }
#                 responsedata.append(data)
#
#             return responsedata
#
#         elif academicyearId and course_id and section_id==0 and SubjectMasterId and studentId==0:
#             student_CourseData = StudentCourse.objects.filter(academic_year=academicyearId, addmitted_class=course_id,
#                                                              is_active=True)
#
#             # Exclude students who are already in StudentClub for the given academic year
#             existing_student_ids = StudentClub.objects.filter(
#                 academic_year_id=academicyearId,subject_master_id=SubjectMasterId, is_active=True
#             ).values_list('student_id', flat=True)
#
#             # Filter out students not in StudentClub
#             student_queryset = student_CourseData.filter(student_id__id__in=existing_student_ids)
#
#
#             responsedata = []
#
#             for item in student_queryset:
#                 studentcourseInstance = StudentCourse.objects.get(student_id=item.student_id.id)
#
#                 studentregistrationinstance = StudentRegistration.objects.get(id=item.student_id.id)
#
#                 studentclubInstance = StudentClub.objects.get(student_id=item.student_id.id)
#
#                 subjectmasterInstance = SubjectMaster.objects.get(id=studentclubInstance.subject_master_id.id,is_active=True)
#
#                courseInstance = Course.objects.get(id=studentcourseInstance.addmitted_class.id, is_active=True)
#
#                 sectionInstance = Section.objects.get(id=studentcourseInstance.addmitted_section.id, is_active=True)
#
#                 data = {
#                     'studentId': studentcourseInstance.student_id.id,
#                     'classname':courseInstance.classname,
#                     'sectionname': sectionInstance.sectionname,
#                     'enrollment_no': studentcourseInstance.enrollment_no,
#                     'studentName': f'{studentregistrationinstance.first_name} {studentregistrationinstance.middle_name}{studentregistrationinstance.last_name}',
#                     'college_admission_no': studentregistrationinstance.college_admission_no,
#                     'barcode': studentregistrationinstance.barcode,
#                     'father_name': studentregistrationinstance.father_name,
#                     'mother_name': studentregistrationinstance.mother_name,
#                     'house': studentregistrationinstance.house,
#                     'subjectname':subjectmasterInstance.subject_code
#                 }
#                 responsedata.append(data)
#
#             return responsedata
#
#
#         elif academicyearId and studentId and course_id and (section_id or section_id==0) :
#             registrationInstance = StudentRegistration.objects.get(id=studentId,is_active=True)
#
#
#             # Exclude students who are already in StudentClub for the given academic year
#             existing_student_ids = StudentClub.objects.filter(
#                 academic_year_id=academicyearId,is_active=True
#             ).values_list('student_id', flat=True)
#
#
#             studentcourseInstance = StudentCourse.objects.get(student_id=studentId, is_active=True)
#
#             responsedata=[]
#             if registrationInstance.id in existing_student_ids:
#
#
#                 studentclubInstance = StudentClub.objects.get(student_id=studentId,is_active=True)
#
#                 if SubjectMasterId !=0:
#                     if studentclubInstance.subject_master_id.id== SubjectMasterId:
#                         # Get Subject Master Instance
#                         subjectmasterInstance = SubjectMaster.objects.get(id=studentclubInstance.subject_master_id.id)
#                        courseInstance = Course.objects.get(id=studentcourseInstance.addmitted_class.id, is_active=True)
#                         sectionInstance = Section.objects.get(id=studentcourseInstance.addmitted_section.id,
#                                                               is_active=True)
#
#                         data = {
#                             'studentId': studentcourseInstance.student_id.id,
#                             'classname':courseInstance.classname,
#                             'sectionname': sectionInstance.sectionname,
#                             'enrollment_no': studentcourseInstance.enrollment_no,
#                             'studentName': f'{registrationInstance.first_name} {registrationInstance.middle_name}{registrationInstance.last_name}',
#                             'college_admission_no': registrationInstance.college_admission_no,
#                             'barcode': registrationInstance.barcode,
#                             'father_name': registrationInstance.father_name,
#                             'mother_name': registrationInstance.mother_name,
#                             'house': studentcourseInstance.house,
#                             'subjectname': subjectmasterInstance.subject_code
#                         }
#                         responsedata.append(data)
#                     else:
#                         return "No Data Found!!"
#                 elif SubjectMasterId == 0:
#                     return "No Data Found!!"
#
#
#             return responsedata
#
#     def list(self, request, *args, **kwargs):
#         try:
#             queryset = self.get_queryset()
#             return Response({'message':queryset},status=status.HTTP_200_OK)
#
#         except Http404:
#
#             return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)
#
#         except Exception as e:
#
#             # Log the exception
#
#             error_message = str(e)
#
#             self.log_exception(request, error_message)
#
#             return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#     def log_exception(self, request, error_message):
#
#         ExceptionTrack.objects.create(
#
#             request=str(request),
#
#             process_name='studentListBasedOnGroup',
#
#             message=error_message,
#
#         )


class StudentClubUpdateorCreateAPIView(UpdateAPIView):
    queryset = StudentClub.objects.all()
    serializer_class = StudentClubUpdateCreateSerializer

    def update(self, request, *args, **kwargs):

        try:
            # student_id = self.kwargs.get('student_id')
            # partial = kwargs.pop('partial', False)

            # Validate and extract input data
            serializer = self.get_serializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            organization_id = serializer.validated_data['organization_id']
            branch_id = serializer.validated_data['branch_id']
            club_group_ids = serializer.validated_data['club_group_ids']
            club_ids = serializer.validated_data['club_ids']
            student_ids = serializer.validated_data['student_ids']
            # Retrieve related instances
            try:
                organization_instance = Organization.objects.get(id=organization_id, is_active=True)
            except Organization.DoesNotExist:
                return Response({"message": "organization record not found !!!"},
                                status=status.HTTP_404_NOT_FOUND)

            try:
                branch_instance = Branch.objects.get(id=branch_id, is_active=True)
            except Branch.DoesNotExist:
                return Response({"message": "branch record not found !!!"},
                                status=status.HTTP_404_NOT_FOUND)
            # try:
            #     club_group_record = ClubGroup.objects.filter(organization=organization_id,branch=branch_id,id__in=club_group_ids, is_active=True)
            # except ClubGroup.DoesNotExist:
            #     return Response({"message": "club_group record not found !!!"},
            #                     status=status.HTTP_404_NOT_FOUND)
            # try:
            #     club_record = Club.objects.filter(organization=organization_id,branch=branch_id,id__in=club_ids, is_active=True)
            # except Club.DoesNotExist:
            #     return Response({"message": "club record not found !!!"},
            #                     status=status.HTTP_404_NOT_FOUND)
            # # academic_year_instance = AcademicYear.objects.get(id=serializer.validated_data['academic_year_id'])
            # try:
            #     student_course_record = StudentCourse.objects.filter(organization=organization_id,branch=branch_id,student__in=student_ids,is_active=True)
            #     if not student_course_record:
            #         return Response({"message": "student_course record not found !!!"},
            #                         status=status.HTTP_404_NOT_FOUND)
            # except StudentCourse.DoesNotExist:
            #     return Response({"message": "student_course record not found !!!"},
            #                     status=status.HTTP_404_NOT_FOUND)

            # records = []
            created = False
            response_data = []
            for club_group_id, club_id, student_id in zip(club_group_ids, club_ids, student_ids):
                # for club_group, club, student_course in zip(club_group_record, club_record, student_course_record):
                # club_group = club_group[0] if isinstance(club_group, tuple) else club_group
                # club = club[0] if isinstance(club, tuple) else club
                # student_course = student_course[0] if isinstance(student_course, tuple) else student_course
                try:
                    club_group = ClubGroup.objects.get(organization=organization_id, branch=branch_id, id=club_group_id,
                                                       is_active=True)
                except ClubGroup.DoesNotExist:
                    return Response({"message": "club_group record not found !!!"},
                                    status=status.HTTP_404_NOT_FOUND)
                try:
                    club = Club.objects.get(organization=organization_id, branch=branch_id, id=club_id, is_active=True)
                except Club.DoesNotExist:
                    return Response({"message": "club record not found !!!"},
                                    status=status.HTTP_404_NOT_FOUND)
                # academic_year_instance = AcademicYear.objects.get(id=serializer.validated_data['academic_year_id'])
                try:
                    student_course = StudentCourse.objects.get(organization=organization_id, branch=branch_id,
                                                               student=student_id, is_active=True)
                    if not student_course:
                        return Response({"message": f"student_course record not found {student_id} !!!"},
                                        status=status.HTTP_404_NOT_FOUND)
                except StudentCourse.DoesNotExist:
                    return Response({"message": f"student_course record not found !!! {student_id}"},
                                    status=status.HTTP_404_NOT_FOUND)
                try:
                    student_club_instance = StudentClub.objects.get(student_course=student_course.id, is_active=True)
                except:
                    student_club_instance = None

                # club_group = club_group

                if student_club_instance:
                    # student_club_instance.student_course = student_course,
                    # student_club_instance.organization = organization_instance,
                    # student_club_instance.branch = branch_instance,
                    # student_club_instance.batch = student_course.batch,
                    # student_club_instance.course = student_course.course,
                    # student_club_instance.department = student_course.department,
                    # student_club_instance.academic_year = student_course.academic_year,
                    # student_club_instance.semester = student_course.semester,
                    # student_club_instance.section = student_course.section,
                    student_club_instance.club_group = club_group
                    student_club_instance.club = club
                    student_club_instance.is_active = True
                    student_club_instance.save()

                    response_data.append({
                        "student_course_id": student_course.id,
                        "student_name": student_course.student.first_name,
                        "updated_or_created": "updated"
                    })

                else:
                    StudentClub.objects.create(
                        student_course=student_course,
                        organization=student_course.organization,
                        branch=student_course.branch,
                        batch=student_course.batch,
                        course=student_course.course,
                        department=student_course.department,
                        academic_year=student_course.academic_year,
                        semester=student_course.semester,
                        section=student_course.section,
                        club_group=club_group,
                        club=club,
                        is_active=True
                    )
                    # created = True
                    response_data.append({
                        "student_course_id": student_course.id,
                        "student_name": student_course.student.first_name,
                        "updated_or_created": "created"
                    })

                # records.append(
                #     StudentClub(
                #         student_course=student_course,
                #         organization=organization_instance,
                #         branch=branch_instance,
                #         batch=student_course.batch,
                #         course=student_course.course,
                #         department=student_course.department,
                #         academic_year=student_course.academic_year,
                #         semester=student_course.semester,
                #         section=student_course.section,
                #         club_group=club_group,
                #         club=club,
                #         is_active=True
                #     )
                # )

            # Step A: Identify existing records based on unique constraints
            # existing = StudentClub.objects.filter(
            #     student_course__in=[r.student_course for r in records],
            #     # club_group__in=[r.club_group for r in records],
            #     # club__in=[r.club for r in records]
            # ).values_list("id",flat=True)
            #
            # existing_map = {sc for sc in existing}
            #
            # # Step B: Split records into create vs update sets
            # to_create = []
            # to_update = []
            #
            # for r in records:
            #     key = (r.id)
            #     if key in existing_map:
            #         to_update.append(r)  # record exists  update
            #     else:
            #         to_create.append(r)  # record missing  create
            #
            # # Step C: Bulk actions
            # created = False
            # if to_create:
            #     StudentClub.objects.bulk_create(to_create)
            #     created =True
            # if to_update:
            #     StudentClub.objects.bulk_update(
            #         to_update,
            #         [
            #             'organization',
            #             'branch',
            #             'batch',
            #             'course',
            #             'department',
            #             'academic_year',
            #             'semester',
            #             'section',
            #             "club_group",
            #             "club",
            #             'is_active'
            #         ]
            #     )
            #
            #

            # Update or create the student club record
            # created = False
            # for club_group,club,student_course in product(club_group_record,club_record,student_course_record):
            #     student_record, created = StudentClub.objects.update_or_create(
            #         student_course=student_course,
            #
            #         defaults={
            #             'organization': organization_instance,
            #             'branch': branch_instance,
            #             'batch': student_course.batch,
            #             'course': student_course.course,
            #             'department': student_course.department,
            #             'academic_year': student_course.academic_year,
            #             'semester': student_course.semester,
            #             'section':student_course.section,
            #             "club_group" : club_group,
            #             "club" : club,
            #             'is_active': True
            #         }
            #     )
            #     student_record.save()
            #     created = created
            # name_part = filter(None, [
            #     student_course_instance.student.first_name,
            #     student_course_instance.student.middle_name,
            #     student_course_instance.student.last_name
            # ])
            # student_name = " ".join(name_part)
            #
            # responseData = {
            #     "student_id":student_course_instance.student.id,
            #     "student_name": student_name,
            #     'organization_id': organization_instance.id,
            #     'organization': organization_instance.organization_description,
            #     'branch_id': branch_instance.id,
            #     'branch': branch_instance.branch_name,
            #     'batch_id': student_course_instance.batch.id,
            #     'course_id': student_course_instance.course.id,
            #     'course': student_course_instance.course.course_name,
            #     'department_id': student_course_instance.department.id,
            #     'department': student_course_instance.department.department_description,
            #     'academic_year_id': student_course_instance.academic_year.id,
            #     'academic_year': student_course_instance.academic_year.academic_year_code,
            #     'semester_id': student_course_instance.semester.id,
            #     'semester': student_course_instance.semester.semester_description,
            #     'section_id': student_course_instance.section.id,
            #     'section': student_course_instance.section.section_name,
            #     'club_group_id': club_group_instance.id,
            #     'club_group': club_group_instance.club_group_description,
            #     'club_id': club_instance.id,
            #     'club': club_instance.club_description,
            #     'is_active': True
            # }
            # serializer = self.get_serializer(data=student_record)
            # serializer.is_valid(raise_exception=True)
            # Determine response based on creation or update
            return Response({'message': 'Club record created_or_updated successfully.', 'data': response_data},
                            status=status.HTTP_200_OK)

            # if created:
            #     return Response({'message': 'Club record created successfully.'}, status=status.HTTP_201_CREATED)
            # else:
            #     return Response({'message': 'Club updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred: ' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='studentRecordUpdate',
            message=error_message,
        )


# class StudentClubUpdateAPIView(UpdateAPIView):
#     queryset = StudentClub.objects.all()
#     serializer_class = ClubUpdateSerializer
#
#     def update(self, request, *args, **kwargs):
#         try:
#             partial = kwargs.pop('partial', False)
#             student_id = self.kwargs.get('student_id')
#
#             studentrecord = StudentClub.objects.get(student_id=student_id,is_active=True)
#
#             if studentrecord:
#                 # validate input data
#                 serializer = self.get_serializer(studentrecord, data=request.data, partial=partial)
#                 # print(serializer)
#                 serializer.is_valid(raise_exception=True)
#
#                 # Access serializer data
#                 subject_master_id = serializer.validated_data.get('subjectmasterId')
#
#                 subjectmasterInstance = SubjectMaster.objects.get(id=subject_master_id, is_active=True)
#
#                 studentrecord.subject_master_id = subjectmasterInstance
#
#                 studentrecord.save()
#
#                 return Response({'message': 'Club Updated Successfully!!'}, status=status.HTTP_200_OK)
#             else:
#                 serializer = self.get_serializer(studentrecord, data=request.data, partial=partial)
#                 # print(serializer)
#                 serializer.is_valid(raise_exception=True)
#                 subject_master_id = serializer.validated_data.get('subjectmasterId')
#
#                 subjectmasterInstance = SubjectMaster.objects.get(id=subject_master_id, is_active=True)
#
#
#
#
#
#
#         except:pass


# def get_object(self):
#     student_id= self.kwargs.get('student_id')
#     return

# def get_object(self):
#     # Override get_object to retrieve the StudentClub instance based on student_id
#     student_id = self.kwargs.get('student_id')
#
#     return StudentClub.objects.get(student_id=student_id,is_active=True)

# def update(self, request, *args, **kwargs):
#     try:
#         partial = kwargs.pop('partial', False)
#         instance = self.get_object()
#
#
# # validate input data
# serializer = self.get_serializer(instance, data=request.data, partial=partial)
# # print(serializer)
# serializer.is_valid(raise_exception=True)
#
# # Access serializer data
# subject_master_id = serializer.validated_data.get('subjectmasterId')
#
# subjectmasterInstance= SubjectMaster.objects.get(id=subject_master_id,is_active=True)
#
# instance.subject_master_id=subjectmasterInstance
#
# instance.save()
#
# return Response({'message': 'Club Updated Successfully!!'}, status=status.HTTP_200_OK)

#
#     except Http404:
#         return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)
#
#     except ValidationError as e:
#         return Response({'message': e.detail}, status=status.HTTP_400_BAD_REQUEST)
#
#     except DatabaseError as e:
#         self.log_exception(request, str(e))
#         return Response({'error': 'A database error occurred.' + str(e)},
#                         status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#     except Exception as e:
#         self.log_exception(request, str(e))
#         return Response({'error': 'An unexpected error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
# def log_exception(self, request, error_message):
#     ExceptionTrack.objects.create(
#         request=str(request),
#         process_name='studentRecordUpdate',
#         message=error_message,
#     )

class StudentSearchBasedOnIdBarcodeCollegeAdmissionNo(ListAPIView):
    serializer_class = StudentFilterBasedOnIdBarcodeAdmissionNoSerializer

    def list(self, request, *args, **kwargs):
        try:
            # Fetch query parameters
            flag = request.query_params.get('flag').upper()
            studentCourseId = request.query_params.get('student_course_id')
            barcode = request.query_params.get('barcode')
            college_admission_no = request.query_params.get('college_admission_no')
            academic_year_id = request.query_params.get('academic_year_id')

            # print(studentId,barcode,college_admission_no,flag)
            if studentCourseId:
                try:
                    # StudentInstance = StudentRegistration.objects.get(id=studentId)
                    StudentCourseInstance = StudentCourse.objects.get(id=studentCourseId)
                # except StudentRegistration.DoesNotExist:
                except StudentCourse.DoesNotExist:
                    return Response({"message": f"{studentCourseId} not matched any student !!"},
                                    status=status.HTTP_200_OK)

            elif barcode:
                try:
                    StudentCourseInstance = StudentCourse.objects.get(student__barcode=barcode, is_active=True)
                except StudentCourse.DoesNotExist:
                    return Response({"message": f"{barcode} not matched any student !!"},
                                    status=status.HTTP_200_OK)

            elif college_admission_no:
                StudentCourseInstance = StudentCourse.objects.filter(
                    Q(student__college_admission_no=college_admission_no) | Q(student__admission_no=college_admission_no),
                    is_active=True
                ).first()
                if not StudentCourseInstance:
                    return Response({"message": f"{college_admission_no} not matched any student !!"},
                                    status=status.HTTP_200_OK)

            if StudentCourseInstance:

                courseInstance = Course.objects.get(id=StudentCourseInstance.course.id, is_active=True)
                sectionInstance = Section.objects.get(id=StudentCourseInstance.section.id, is_active=True)

                # StudentCourseInstance = StudentCourse.objects.get(id=StudentCourseInstance.id, is_active=True)

                FeeStructureMasterInstance = None
                try:
                    FeeStructureMasterInstance = FeeStructureMaster.objects.get(id=StudentCourseInstance.fee_group.id)
                except ObjectDoesNotExist:
                    FeeStructureMasterInstance = None

                student_name = ""
                if StudentCourseInstance.student:
                    name_part = filter(None, [
                        StudentCourseInstance.student.first_name,
                        StudentCourseInstance.student.middle_name,
                        StudentCourseInstance.student.last_name
                    ])
                    student_name = " ".join(name_part)
                #
                # if StudentCourseInstance.student.first_name and StudentCourseInstance.student.middle_name and StudentCourseInstance.student.last_name:
                #     student_name = StudentCourseInstance.student.first_name + ' ' +StudentCourseInstance.student.middle_name + ' ' + StudentCourseInstance.student.last_name
                #
                # elif StudentCourseInstance.student.first_name and StudentCourseInstance.student.last_name:
                #     student_name = StudentCourseInstance.student.first_name + ' ' + StudentCourseInstance.student.last_name
                #
                # elif StudentCourseInstance.student.first_name and StudentCourseInstance.student.middle_name:
                #     student_name = StudentCourseInstance.student.first_name + ' ' + StudentCourseInstance.student.middle_name

                if flag == "Y":
                    # print("going")
                    # Get All Data For Specific Student ID On Student Fee Details Table

                    StudentFeeDetailData = StudentFeeDetail.objects.filter(student=StudentCourseInstance.student,
                                                                           is_active=True, )
                    feestructuredetailsdata = []
                    element_discount_amount = ''
                    for item in StudentFeeDetailData:

                        academicYearInstance = AcademicYear.objects.get(id=item.academic_year.id)
                        organizationInstance = Organization.objects.get(id=item.organization.id)
                        # branchInstance = Branches.objects.get(id=item.branch_id.id)
                        # FeeStructureDetail_Instance = FeeStructureDetail.objects.get(id=item.fee_structure_details_id)
                        if item.element_name == 'DISCOUNT':
                            element_discount_amount = item.element_amount

                        semesterInstance = None
                        try:
                            semesterInstance = Semester.objects.get(id=item.semester.id)
                        except ObjectDoesNotExist:
                            semesterInstance = None
                        # registrationInstance = StudentRegistration.objects.get(id=item.student_id.id)

                        if item.fee_group:
                            fee_structure_code = item.fee_group.fee_structure_code
                            fee_structure_description = item.fee_group.fee_structure_description
                        else:
                            fee_structure_code = None
                            fee_structure_description = ""

                        data = {
                            'id': item.id,
                            'student_id': StudentCourseInstance.student.id,
                            'student_name': student_name,
                            'fee_structure_code': fee_structure_code,
                            'fee_structure_description': fee_structure_description,
                            # 'fee_structure_code': item.fee_group.fee_structure_code if FeeStructureMasterInstance else None,
                            # 'fee_structure_description': item.fee_group.fee_structure_description if FeeStructureMasterInstance else None,

                            'element_name': item.element_name,
                            'paid': item.paid,
                            'academic_year_id': academicYearInstance.id,
                            'academicYearName': academicYearInstance.academic_year_code,
                            'organization': organizationInstance.id,
                            'organizationName': organizationInstance.organization_code,
                            # 'branchId': branchInstance.id,
                            # 'branchName': branchInstance.branch_name,
                            'semester_id': semesterInstance.id if semesterInstance else None,
                            'semester': semesterInstance.semester_description if semesterInstance else None,
                            'multiplying_factor': item.multiplying_factor,
                            'element_amount': item.element_amount,
                            'total_element_period_amount': item.total_element_period_amount,
                            'paid_amount': item.paid_amount,
                            'remarks': item.remarks,
                            'reverse_flag': item.reverse_flag,
                            # 'element_discount_amount': StudentFeeDetailData[2].__dict__['element_amount']

                        }

                        feestructuredetailsdata.append(data)

                    # fee_details_serialized = studentfeedetails_Serializer(StudentFeeDetailData, many=True)
                    #
                    # feedetailsdata= fee_details_serialized.data

                    responsedata = {
                        'studentId': StudentCourseInstance.student.id,
                        'student_name': student_name,
                        'barcode': StudentCourseInstance.student.barcode,
                        'college_admission_no': StudentCourseInstance.student.college_admission_no,
                        'course_name': courseInstance.course_name,
                        'section_name': sectionInstance.section_name,
                        'enrollment_no': StudentCourseInstance.enrollment_no,
                        'house': StudentCourseInstance.house.house_name if StudentCourseInstance.house else '',
                        'feegroupId': FeeStructureMasterInstance.id if FeeStructureMasterInstance else None,
                        # 'feegroup': FeeStructureMasterInstance.fee_structure_code if FeeStructureMasterInstance else None,
                        'feegroup': FeeStructureMasterInstance.fee_structure_description if FeeStructureMasterInstance else '',
                        'feedetails': feestructuredetailsdata,
                        'element_discount_amount': element_discount_amount
                    }
                else:
                    responsedata = {
                        'studentId': StudentCourseInstance.student.id,
                        'student_name': student_name,
                        'barcode': StudentCourseInstance.student.barcode,
                        'college_admission_no': StudentCourseInstance.student.college_admission_no,
                        'course_name': courseInstance.course_name,
                        'section_name': sectionInstance.section_name,
                        'enrollment_no': StudentCourseInstance.enrollment_no,
                        'house': StudentCourseInstance.house,
                        'feegroupId': FeeStructureMasterInstance.id if FeeStructureMasterInstance else None,
                        # 'feegroup': FeeStructureMasterInstance.fee_structure_code if FeeStructureMasterInstance else None,
                        # 'fee_structure_desc': FeeStructureMasterInstance.fee_structure_desc if FeeStructureMasterInstance else '',
                        'feegroup': FeeStructureMasterInstance.fee_structure_description if FeeStructureMasterInstance else '',

                    }

                return Response({'message': 'success!!', 'data': responsedata}, status=status.HTTP_200_OK)

        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='studentfilterdata',

            message=error_message,

        )


class PaymentMethodListAPIView(ListAPIView):
    queryset = PaymentMethod.objects.all()
    serializer_class = PaymentMethodSerializer

    def list(self, request, *args, **kwargs):
        try:
            # response = super().list(request, *args, **kwargs)
            # resdata = response.data

            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')

            payment_method_instance = PaymentMethod.objects.filter(organization=organization_id, branch=branch_id,
                                                                   is_active=True)

            if payment_method_instance:
                responsedata = []
                for payment_method in payment_method_instance:
                    # if item.get('is_active') == True:

                    # organizationInstance = Organization.objects.get(id=item.get("organization"))
                    # branchInstance = Branches.objects.get(id=item.get("branch_id"))

                    # Prepare the custom response data
                    responsedata.append({
                        'id': payment_method.id,
                        'payment_method': payment_method.payment_method,
                        'payment_method_desc': payment_method.payment_method_desc,
                        'organization_id': payment_method.organization.id,
                        'organization_name': payment_method.organization.organization_code,
                        'branch_id': payment_method.branch.id,
                        'branch_name': payment_method.branch.branch_name

                    })
                    # else:
                    #     continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='paymentmethodlist',
            message=error_message,
        )


# class SubjectGroupListAPIView(ListAPIView):
#     queryset = CourseDepartmentSubject.objects.all()
#     serializer_class = GetSubjectBasedOnCourseDepartmentSemesterSerializer
#
#     def list(self, request, *args, **kwargs):
#         try:
#             organization = self.kwargs.get('organization')
#             # branchId = self.kwargs.get('branch_id')
#             # print(organization,branchId)
#
#             SubjectGroupQueryData = CourseDepartmentSubject.objects.filter(organization=organization)
#             # print(SubjectGroupQueryData)
#
#
#             if SubjectGroupQueryData.exists():
#                 responsedata = []
#                 for item in SubjectGroupQueryData:
#                     if item.is_active == True:
#
#                         organizationInstance = Organization.objects.get(id=item.organization.id)
#                         # branchInstance = Branches.objects.get(id=item.branch_id.id)
#
#                         # Prepare the custom response data
#                         responsedata.append({
#                             'id': item.id,
#                             'subject_code': item.subject_code,
#                             'subject_description': item.subject_group_desc,
#                             'organization': organizationInstance.id,
#                             'organizationName': organizationInstance.organization_code,
#                             # 'branch_id': branchInstance.id,
#                             # 'branchName': branchInstance.branch_name
#
#                         })
#                     else:
#                         continue
#
#                 if responsedata:
#                     return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
#                 else:
#                     return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
#
#             else:
#                 return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
#
#         except Exception as e:
#             # Log the exception
#             error_message = str(e)
#             self.log_exception(request, error_message)
#             return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#     def log_exception(self, request, error_message):
#         ExceptionTrack.objects.create(
#             request=str(request),
#             process_name='SubjectGrouplist',
#             message=error_message,
#         )

class StudentFeeReceiptCreateAPIView(CreateAPIView):
    queryset = StudentFeeReceiptHeader.objects.all()
    serializer_class = StudentFeeReceiptSerializer

    @transaction.atomic
    def create(self, request, *args, **kwargs):
        try:
            # Start a new atomic transaction
            with transaction.atomic():
                # Validate and save data
                serializer = self.get_serializer(data=request.data)
                serializer.is_valid(raise_exception=True)
                # print(serializer)

                login_id = serializer.validated_data.get('login_id')
                student_id = serializer.validated_data.get('student_id')
                academic_year_id = serializer.validated_data.get('academic_year_id')
                receipt_date = serializer.validated_data.get('receipt_date')
                payment_method_id = serializer.validated_data.get('payment_method_id')
                # bank_id = serializer.validated_data.get('bank_id')
                # account_number = serializer.validated_data.get('account_number')
                remarks = serializer.validated_data.get('remarks')
                # reference_date = serializer.validated_data.get('reference_date')
                student_fee_details_ids = serializer.validated_data.get('student_fee_details_ids')
                semester_ids = serializer.validated_data.get('semester_ids')
                late_fee = serializer.validated_data.get('late_fee')

                discount_fee = serializer.validated_data.get('discount_fee')
                check_bounce_fee = serializer.validated_data.get('check_bounce_fee')
                readmission_fees = serializer.validated_data.get('readmission_fees')
                # total_amount = serializer.validated_data.get('total_amount')  # payment amount
                payment_detail = serializer.validated_data.get('payment_detail')
                # for ids in stdfeedetailsIds:
                #     student_fee_detail = StudentFeeDetail.objects.get(id=stdfeedetailsIds[0])
                #     get_element_name = student_fee_detail.element_name

                payment_type = payment_detail.get("payment_type")
                cheque_number = payment_detail.get("cheque_number")
                cheque_bank_name = payment_detail.get("cheque_bank_name")
                cheque_branch_name = payment_detail.get("cheque_branch_name")
                remarks = payment_detail.get("remarks")
                reference_date = payment_detail.get("reference_date")
                reference = payment_detail.get("reference")
                total_amount = payment_detail.get("total_amount")
                beneficiary_bank_id = payment_detail.get("beneficiary_bank_id")
                beneficiary_account_id = payment_detail.get("beneficiary_account_id")

                fee_detail_list = []

                for id in student_fee_details_ids:
                    fee_detail_list.append(StudentFeeDetail.objects.get(id=id, student=student_id))

                previous_paid_amount = 0
                # count = 0
                for item in fee_detail_list:
                    if not StudentFeeReceiptDetail.objects.filter(id=item.id).exists():
                        previous_paid_amount = 0
                        # count = count + 1
                    else:
                        previous_paid_amount_detail = StudentFeeReceiptDetail.objects.get(id=item.id)
                        previous_paid_amount = previous_paid_amount + previous_paid_amount_detail.amount

                # print(studentId,academicyearId,reciptdate,paymentmethodId,bankId,accountnumber,remark,referencedate,stdfeedetailsIds,latefees,totalamount)
                # Process StdFeeReceiptHeader
                # RegistartionInstance = StudentRegistration.objects.get(id=studentId)
                try:
                    studentcourseInstance = StudentCourse.objects.get(student=student_id, is_active=True)
                except ObjectDoesNotExist:
                    return Response({'message': 'Student Course Details Not Found'}, status=status.HTTP_404_NOT_FOUND)

                # print(RegistartionInstance)

                # # Academic Year Instance
                # AcademicYearInstance = AcademicYear.objects.get(id=academicyearId)

                # print(AcademicYearInstance)

                # Payment Method
                try:
                    paymentmethodInstance = PaymentMethod.objects.get(id=payment_method_id, is_active=True)
                except ObjectDoesNotExist:
                    return Response({'message': 'Payment method Details Not Found'}, status=status.HTTP_404_NOT_FOUND)

                # print(paymentmethodInstance)

                # Period Month records

                semester_record = Semester.objects.filter(id__in=semester_ids, is_active=True)

                if not semester_record.exists():
                    return Response({'message': 'No valid Period found'}, status=status.HTTP_404_NOT_FOUND)

                # Get Max period

                max_semester = semester_record.order_by('-id').first()

                # period Instance
                try:
                    semesterInstance = Semester.objects.get(id=max_semester.id, is_active=True)
                except ObjectDoesNotExist:
                    return Response({'message': 'Period Details Not Found'}, status=status.HTTP_404_NOT_FOUND)

                # check to generate receipt_no
                def generate_receipt_number(academic_year_id):
                    # Filter by the given academic year ID and get the max receipt_no within that year
                    max_receipt_no = \
                    StudentFeeReceiptHeader.objects.filter(academic_year_id=academic_year_id).aggregate(
                        Max('receipt_no'))['receipt_no__max']

                    if max_receipt_no is None:
                        return 1  # Set to 1 if no receipts exist for this academic year
                    return max_receipt_no + 1

                new_receipt_no = generate_receipt_number(academic_year_id)
                # print(new_receipt_no)




                StudentFeeReceiptHeaderInstance = StudentFeeReceiptHeader.objects.create(

                    receipt_no=new_receipt_no,
                    organization=studentcourseInstance.organization,
                    branch=studentcourseInstance.branch,
                    batch=studentcourseInstance.batch,
                    course=studentcourseInstance.course,
                    department=studentcourseInstance.department,
                    academic_year=studentcourseInstance.academic_year,
                    semester=studentcourseInstance.semester,
                    # section = studentcourseInstance.semester,
                    # period_month = periodInstance,
                    receipt_date=receipt_date,
                    student=studentcourseInstance.student,
                    receipt_amount=total_amount,
                    payment_method=paymentmethodInstance,
                    # payment_reference=remarks,
                    payment_detail=payment_detail,
                    # payment_date=reference_date,
                    receipt_status="APPROVED",
                    cancellation_remarks="",
                    balance=total_amount,

                    created_by=login_id

                )
                StudentFeeReceiptHeaderInstance.save()
                if beneficiary_bank_id:
                    try:
                        bank_instance = Bank.objects.get(id=beneficiary_bank_id,is_active=True)
                    except Bank.DoesNotExist:
                        return Response({"message":"bank record not found"}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    bank_instance = None

                if beneficiary_account_id:
                    try:
                        bank_account_instance = BankAccountDetail.objects.get(id=beneficiary_account_id,is_active=True)
                    except BankAccountDetail.DoesNotExist:
                        return Response({"message":"BankAccountDetail record not found"}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    bank_account_instance = None

                StudentPaymentInstance = StudentPayment.objects.create(
                    # organization=
                    receipt=StudentFeeReceiptHeaderInstance,
                    payment_method=paymentmethodInstance,
                    amount=total_amount,
                    bank=bank_instance,
                    bank_account=bank_account_instance,
                    payment_reference=reference,
                    payment_date=receipt_date,
                    reference_date=reference_date
                )

                StudentPaymentInstance.save()

                # Total amount paid by Student
                grand_Paid_Amount = total_amount

                # Insert object for particular student

                if discount_fee:
                    grand_Paid_Amount = grand_Paid_Amount + discount_fee
                    semester_ids_sorted = list(sorted(set(semester_ids)))  # in future need to be sort based on date

                    for semester_id in semester_ids_sorted:
                        # print(prd)
                        total_payment_amount = 0
                        total_paid_amount = 0
                        # pending_payment_amount=0

                        # Get period month instance
                        semesterInstance = Semester.objects.get(id=semester_id, is_active=True)
                        studentfeedetailsrecord = StudentFeeDetail.objects.filter(student=student_id,
                                                                                  fee_applied_from=semesterInstance.id,
                                                                                  is_active=True)
                        # print(studentfeedetailsrecord)
                        # print(studentfeedetailsrecord)

                        for feedetailsId in student_fee_details_ids:
                            try:
                                # Use get() to fetch the specific student fee detail
                                matching_record = studentfeedetailsrecord.get(id=feedetailsId)

                                # Add element_amount and paid_amount to the totals
                                total_payment_amount += matching_record.element_amount
                                total_paid_amount += matching_record.paid_amount
                            except StudentFeeDetail.DoesNotExist:
                                # Log the missing record and continue with the remaining IDs
                                # print(f"Student Fee Detail with id {feedetailsId} does not exist. Skipping.")
                                continue  # Skip to the next ID

                        pending_amount = total_payment_amount - total_paid_amount

                        if discount_fee > pending_amount:

                            # Insert record in student fee details DB
                            studentFeeDetailsInsertfeesInstance = StudentFeeDetail.objects.create(
                                student=studentcourseInstance.student,
                                student_course=studentcourseInstance,
                                fee_group=None,
                                fee_structure_details=None,
                                element_name="DISCOUNT",
                                fee_applied_from=semesterInstance,
                                semester=semesterInstance,
                                paid='Y',
                                academic_year=studentcourseInstance.academic_year,
                                organization=studentcourseInstance.organization,
                                branch=studentcourseInstance.branch,
                                department=studentcourseInstance.department,
                                multiplying_factor=1,
                                element_amount=-pending_amount,
                                total_element_period_amount=-pending_amount,
                                paid_amount=-pending_amount,
                                remarks="",
                                reverse_flag="",
                                created_by=login_id,
                                updated_by=login_id,

                            )

                            # Insert Record into StdFeeReceiptDetail

                            stdfeereceiptInstance = StudentFeeReceiptDetail.objects.create(
                                receipt=StudentFeeReceiptHeaderInstance,
                                fee_detail=studentFeeDetailsInsertfeesInstance,
                                amount=-pending_amount,
                                discount_amount=-pending_amount,
                                created_by=login_id
                            )
                            stdfeereceiptInstance.save()

                            discount_fee -= pending_amount
                            continue

                        elif discount_fee < pending_amount:

                            # Insert record in student fee details DB
                            studentFeeDetailsInsertfeesInstance = StudentFeeDetail.objects.create(
                                student=studentcourseInstance.student,
                                student_course=studentcourseInstance,
                                fee_group=None,
                                fee_structure_details=None,
                                element_name="DISCOUNT",
                                fee_applied_from=semesterInstance,
                                semester = semesterInstance,
                                paid='Y',
                                academic_year=studentcourseInstance.academic_year,
                                organization=studentcourseInstance.organization,
                                branch=studentcourseInstance.branch,
                                department=studentcourseInstance.department,
                                multiplying_factor=1,
                                element_amount=-discount_fee,
                                total_element_period_amount=-discount_fee,
                                paid_amount=-discount_fee,
                                remarks="",
                                reverse_flag="",
                                created_by=login_id,
                                updated_by=login_id,

                            )

                            # Insert Record into StdFeeReceiptDetail
                            stdfeereceiptInstance = StudentFeeReceiptDetail.objects.create(
                                receipt=StudentFeeReceiptHeaderInstance,
                                fee_detail=studentFeeDetailsInsertfeesInstance,
                                amount=-discount_fee,
                                discount_amount=-discount_fee,
                                created_by=login_id
                            )
                            stdfeereceiptInstance.save()
                            discount_fee -= discount_fee
                            break

                if late_fee:
                    if grand_Paid_Amount > late_fee:

                        # Insert New data into Student fee details
                        studentFeeDetailsInsertlatefeesInstance = StudentFeeDetail.objects.create(
                            student=studentcourseInstance.student,
                            student_course=studentcourseInstance,
                            fee_group=None,
                            fee_structure_details=None,
                            element_name="LATE FEES",
                            fee_applied_from=semesterInstance,  # periodmonthInstance.id,
                            semester = semesterInstance,
                            paid='Y',
                            academic_year=studentcourseInstance.academic_year,
                            organization=studentcourseInstance.organization,
                            branch=studentcourseInstance.branch,
                            department=studentcourseInstance.department,
                            multiplying_factor=1,
                            element_amount=late_fee,
                            total_element_period_amount=late_fee,
                            paid_amount=late_fee,
                            remarks="",
                            reverse_flag="",
                            created_by=login_id,
                            updated_by=login_id,

                        )

                        studentFeeDetailsInsertlatefeesInstance.save()
                        grand_Paid_Amount = grand_Paid_Amount - late_fee

                        # Insert Record into StdFeeReceiptDetail
                        stdfeereceiptInstance = StudentFeeReceiptDetail.objects.create(
                            receipt=StudentFeeReceiptHeaderInstance,
                            fee_detail=studentFeeDetailsInsertlatefeesInstance,
                            amount=late_fee,
                            discount_amount=0,
                            created_by=login_id
                        )
                        stdfeereceiptInstance.save()



                    elif grand_Paid_Amount != 0 and grand_Paid_Amount < late_fee:
                        # Insert New data into Student fee details
                        studentFeeDetailsInsertlatefeesInstance = StudentFeeDetail.objects.create(
                            student=studentcourseInstance.student,
                            student_course=studentcourseInstance,
                            fee_group=None,
                            fee_structure_details=None,
                            element_name="LATE FEES",
                            fee_applied_from=semesterInstance,  # periodmonthInstance.id,
                            semester = semesterInstance,
                            paid='Y',
                            academic_year=studentcourseInstance.academic_year,
                            organization=studentcourseInstance.organization,
                            branch=studentcourseInstance.branch,
                            department=studentcourseInstance.department,
                            multiplying_factor=1,
                            element_amount=late_fee,
                            total_element_period_amount=late_fee,
                            paid_amount=grand_Paid_Amount,
                            remarks="",
                            reverse_flag="",
                            created_by=login_id,
                            updated_by=login_id,

                        )

                        studentFeeDetailsInsertlatefeesInstance.save()
                        grand_Paid_Amount = grand_Paid_Amount - grand_Paid_Amount

                        # Insert Record into StdFeeReceiptDetail
                        stdfeereceiptInstance = StudentFeeReceiptDetail.objects.create(
                            receipt=StudentFeeReceiptHeaderInstance,
                            fee_detail=studentFeeDetailsInsertlatefeesInstance,
                            amount=grand_Paid_Amount,
                            discount_amount=0,
                            created_by=login_id
                        )
                        stdfeereceiptInstance.save()

                if check_bounce_fee:
                    if grand_Paid_Amount > check_bounce_fee:
                        studentFeeDetailsInsertcheckbouncefeesInstance = StudentFeeDetail.objects.create(
                            student=studentcourseInstance.student,
                            student_course=studentcourseInstance,
                            fee_group=None,
                            fee_structure_details_id=None,
                            element_name="CHECK BOUNCE",
                            fee_applied_from=semesterInstance,  # periodmonthInstance.id,
                            semester = semesterInstance,
                            paid='Y',
                            academic_year=studentcourseInstance.academic_year,
                            organization=studentcourseInstance.organization,
                            branch=studentcourseInstance.branch,
                            department=studentcourseInstance.department,
                            multiplying_factor=1,
                            element_amount=check_bounce_fee,
                            total_element_period_amount=check_bounce_fee,
                            paid_amount=check_bounce_fee,
                            remarks="",
                            reverse_flag="",
                            created_by=login_id,
                            updated_by=login_id,

                        )

                        studentFeeDetailsInsertcheckbouncefeesInstance.save()
                        grand_Paid_Amount = grand_Paid_Amount - check_bounce_fee

                        # Insert Record into StdFeeReceiptDetail
                        stdfeereceiptInstance = StudentFeeReceiptDetail.objects.create(
                            receipt=StudentFeeReceiptHeaderInstance,
                            fee_detail=studentFeeDetailsInsertcheckbouncefeesInstance,
                            amount=check_bounce_fee,
                            discount_amount=0,
                            created_by=login_id
                        )
                        stdfeereceiptInstance.save()

                    elif grand_Paid_Amount != 0 and grand_Paid_Amount < check_bounce_fee:
                        studentFeeDetailsInsertcheckbouncefeesInstance = StudentFeeDetail.objects.create(
                            student=studentcourseInstance.student,
                            student_course=studentcourseInstance,
                            fee_group=None,
                            fee_structure_details=None,
                            element_name="CHECK BOUNCE",
                            fee_applied_from=semesterInstance,  # periodmonthInstance.id,
                            semester = semesterInstance,
                            paid='Y',
                            academic_year=studentcourseInstance.academic_year,
                            organization=studentcourseInstance.organization,
                            branch=studentcourseInstance.branch,
                            department=studentcourseInstance.department,
                            multiplying_factor=1,
                            element_amount=check_bounce_fee,
                            total_element_period_amount=check_bounce_fee,
                            paid_amount=grand_Paid_Amount,
                            remarks="",
                            reverse_flag="",
                            created_by=login_id,
                            updated_by=login_id,

                        )

                        studentFeeDetailsInsertcheckbouncefeesInstance.save()
                        grand_Paid_Amount = grand_Paid_Amount - grand_Paid_Amount

                        # Insert Record into StdFeeReceiptDetail
                        stdfeereceiptInstance = StudentFeeReceiptDetail.objects.create(
                            receipt=StudentFeeReceiptHeaderInstance,
                            fee_detail=studentFeeDetailsInsertcheckbouncefeesInstance,
                            amount=check_bounce_fee,
                            discount_amount=0,
                            created_by=login_id
                        )
                        stdfeereceiptInstance.save()

                if readmission_fees:
                    if grand_Paid_Amount > readmission_fees:
                        studentFeeDetailsInsertreadmissionfeesInstance = StudentFeeDetail.objects.create(
                            student=studentcourseInstance.student,
                            student_course=studentcourseInstance,
                            fee_group=None,
                            fee_structure_details=None,
                            element_name="RE ADMISSION",
                            fee_applied_from=semesterInstance,  # periodmonthInstance.id,
                            semester = semesterInstance,
                            paid='Y',
                            academic_year=studentcourseInstance.academic_year,
                            organization=studentcourseInstance.organization,
                            branch=studentcourseInstance.branch,
                            department=studentcourseInstance.department,
                            multiplying_factor=1,
                            element_amount=readmission_fees,
                            total_element_period_amount=readmission_fees,
                            paid_amount=readmission_fees,
                            remarks="",
                            reverse_flag="",
                            created_by=login_id,
                            updated_by=login_id,

                        )

                        studentFeeDetailsInsertreadmissionfeesInstance.save()
                        grand_Paid_Amount = grand_Paid_Amount - readmission_fees

                        # Insert Record into StdFeeReceiptDetail
                        stdfeereceiptInstance = StudentFeeReceiptDetail.objects.create(
                            receipt=StudentFeeReceiptHeaderInstance,
                            fee_detail=studentFeeDetailsInsertreadmissionfeesInstance,
                            amount=readmission_fees,
                            discount_amount=0,
                            created_by=login_id
                        )
                        stdfeereceiptInstance.save()

                    elif grand_Paid_Amount != 0 and grand_Paid_Amount < readmission_fees:
                        studentFeeDetailsInsertreadmissionfeesInstance = StudentFeeDetail.objects.create(
                            student=studentcourseInstance.student,
                            student_course=studentcourseInstance.student,
                            fee_group=None,
                            fee_structure_details=None,
                            element_name="RE ADMISSION",
                            fee_applied_from=semesterInstance,  # periodmonthInstance.id,
                            semester = semesterInstance,
                            paid='N',
                            academic_year=studentcourseInstance.academic_year,
                            organization=studentcourseInstance.organization,
                            branch=studentcourseInstance.branch,
                            department=studentcourseInstance.department,
                            multiplying_factor=1,
                            element_amount=readmission_fees,
                            total_element_period_amount=readmission_fees,
                            paid_amount=grand_Paid_Amount,
                            remarks="",
                            reverse_flag="",
                            created_by=login_id,
                            updated_by=login_id,

                        )

                        studentFeeDetailsInsertreadmissionfeesInstance.save()
                        grand_Paid_Amount = grand_Paid_Amount - grand_Paid_Amount

                        # Insert Record into StdFeeReceiptDetail
                        stdfeereceiptInstance = StudentFeeReceiptDetail.objects.create(
                            receipt=StudentFeeReceiptHeaderInstance,
                            fee_detail=studentFeeDetailsInsertreadmissionfeesInstance,
                            amount=grand_Paid_Amount,
                            discount_amount=0,
                            created_by=login_id
                        )
                        stdfeereceiptInstance.save()

                # fee_detail_list = []
                # print(grand_Paid_Amount)
                if grand_Paid_Amount != 0:
                    # StudentFeeDetail.objects.filter(element_name='FEES ADJUSTMENT', student_id=137, feeappfrom=11)
                    for item in fee_detail_list:
                        # print(item)
                        # StudentFeeDetail.objects.filter(student_id=128, feeappfrom=13, is_active=True)
                        try:
                            studentFeedetailsInstance = StudentFeeDetail.objects.get(id=item.id, is_active=True)
                        except ObjectDoesNotExist:
                            return Response({'message': 'Student Fee Details Does Not Found'},
                                            status=status.HTTP_404_NOT_FOUND)
                        paymentamount = studentFeedetailsInstance.element_amount - studentFeedetailsInstance.paid_amount

                        if grand_Paid_Amount >= paymentamount:
                            studentFeedetailsInstance.paid_amount = paymentamount + studentFeedetailsInstance.paid_amount
                            # studentFeedetailsInstance.total_element_period_amount = studentFeedetailsInstance.element_amount
                            studentFeedetailsInstance.paid = "Y"
                            studentFeedetailsInstance.save()
                            grand_Paid_Amount = grand_Paid_Amount - paymentamount

                            # Insert Record into StdFeeReceiptDetail
                            stdfeereceiptInstance = StudentFeeReceiptDetail.objects.create(
                                receipt=StudentFeeReceiptHeaderInstance,
                                fee_detail=studentFeedetailsInstance,
                                amount=paymentamount,
                                discount_amount=0,
                                created_by=login_id
                            )
                            stdfeereceiptInstance.save()

                            continue

                        if grand_Paid_Amount < paymentamount and grand_Paid_Amount != 0:
                            studentFeedetailsInstance.paid_amount = studentFeedetailsInstance.paid_amount + grand_Paid_Amount
                            # studentFeedetailsInstance.total_element_period_amount = grand_Paid_Amount
                            # studentFeelateDetailsInstance.paid = "N"
                            studentFeedetailsInstance.save()
                            # grand_Paid_Amount = grand_Paid_Amount - grand_Paid_Amount

                            # Insert Record into StdFeeReceiptDetail
                            stdfeereceiptInstance = StudentFeeReceiptDetail.objects.create(
                                receipt=StudentFeeReceiptHeaderInstance,
                                fee_detail=studentFeedetailsInstance,
                                amount=grand_Paid_Amount,
                                discount_amount=0,
                                created_by=login_id
                            )
                            stdfeereceiptInstance.save()

                            break
                # make response

                studentId = StudentFeeReceiptHeaderInstance.student.id

                # Get Student Basic Details Based on Student Id
                RegistrationInstance = StudentRegistration.objects.get(id=studentId)

                # Get student current Details in Student class DB

                StudentCourseInstance = StudentCourse.objects.get(student=studentId, is_active=True)

                courseInstance = Course.objects.get(id=StudentCourseInstance.course.id)

                sectionInstance = Section.objects.get(id=StudentCourseInstance.section.id)

                # Recipt Details

                academicyearInstance = AcademicYear.objects.get(id=StudentFeeReceiptHeaderInstance.academic_year.id)

                # Fee period Get

                # Get Payment Method & detials

                StudentPaymentInstance = StudentPayment.objects.get(receipt_id=StudentFeeReceiptHeaderInstance.id)

                # payment Method Instance
                PaymentmethodInstance = PaymentMethod.objects.get(id=StudentPaymentInstance.payment_method.id)

                # Get Student Fee Recipt Based On Receipt

                feereceiptsobjects = StudentFeeReceiptDetail.objects.filter(
                    receipt_id=StudentFeeReceiptHeaderInstance.id)

                # Get fee payment By Student
                fee_periods = []
                paid_element = {}

                for item in feereceiptsobjects:

                    # Get Student Fee Details Instance

                    studentfeedetailsInstance = StudentFeeDetail.objects.get(id=item.fee_detail.id)

                    # print(studentfeedetailsInstance)

                    fee_periods.append(studentfeedetailsInstance.semester.semester_description)

                    element_name = studentfeedetailsInstance.element_name
                    paid_amount = studentfeedetailsInstance.paid_amount
                    # paid_amount = studentfeedetailsInstance.paid_amount + grand_Paid_Amount

                    # Update paid_element dictionary
                    if element_name in paid_element:
                        # Add to existing amount if element_name already exists
                        paid_element[element_name]["amount"] += paid_amount
                    else:
                        # Create a new entry if element_name does not exist
                        paid_element[element_name] = {"element_name": element_name, "amount": paid_amount}

                Total_fees_objects = StudentFeeDetail.objects.filter(student=studentId, is_active=True)
                # print(Total_academic_year_fees_objects)
                # print(Total_academic_year_fees_objects)

                # Ensure the queryset is not empty
                if Total_fees_objects.exists():
                    # Calculate total amount (sum of element_amount)
                    total_amount = Total_fees_objects.aggregate(
                        total=Sum('element_amount')
                    )['total'] or 0

                    # Calculate total paid amount (sum of paid_amount)
                    total_paid_amount = Total_fees_objects.aggregate(
                        total_paid=Sum('paid_amount')
                    )['total_paid'] or 0
                else:
                    # Handle the case where no records are found
                    total_amount = 0
                    total_paid_amount = 0

                # Calculate remaining amount
                remaining_amount = total_amount - total_paid_amount

                name_part = filter(None, [
                    RegistrationInstance.first_name,
                    RegistrationInstance.middle_name,
                    RegistrationInstance.last_name
                ])
                student_name = " ".join(name_part)

                responsedata = {
                    'id': StudentFeeReceiptHeaderInstance.id,
                    'receipt_no': StudentFeeReceiptHeaderInstance.receipt_no,
                    'academic_year': academicyearInstance.academic_year_code,
                    'receipt_date': StudentFeeReceiptHeaderInstance.receipt_date,
                    'student_name': student_name,
                    'admission_no': RegistrationInstance.admission_no,
                    'course_name': courseInstance.course_name,
                    'section_name': sectionInstance.section_name,
                    'father_name': RegistrationInstance.father_name,
                    'payment_method': PaymentmethodInstance.payment_method,
                    'payment_reference': StudentPaymentInstance.payment_reference,
                    'payment_detail': StudentFeeReceiptHeaderInstance.payment_detail,
                    'amount': StudentPaymentInstance.amount,
                    'fee_periods': sorted(set(fee_periods)),
                    'payment_element_list': paid_element,
                    'total_academic_year_fees': total_amount,
                    'total_paid': total_paid_amount,
                    'remaining_amount': remaining_amount
                }

                # print(grand_Paid_Amount)

                return Response({'message': 'Your Payment Received Successfully!!', 'receipt_data': responsedata},
                                status=status.HTTP_200_OK)  # recipt no need to send


        except ValidationError as e:

            # Rollback the transaction on validation error

            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)


        except DatabaseError as e:

            # Rollback the transaction on database error

            self.log_exception(request, str(e))

            return Response({'error': 'A database error occurred: ' + str(e)},

                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)


        except Exception as e:

            # Rollback the transaction on any other exception

            self.log_exception(request, str(e))

            return Response({'error': 'An unexpected error occurred: ' + str(e)},

                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='feereciptscreate',

            message=error_message,

        )


# class StudentFeeReciptsCreateAPIView(CreateAPIView):
#     queryset = StdFeeReceiptHeader.objects.all()
#     serializer_class = StdFeeReceiptSerializer
#
#     @transaction.atomic
#     def create(self, request, *args, **kwargs):
#         try:
#             # Start a new atomic transaction
#             with transaction.atomic():
#                 # Validate and save data
#                 serializer = self.get_serializer(data=request.data)
#                 serializer.is_valid(raise_exception=True)
#                 # print(serializer)
#
#                 loginId = serializer.validated_data.get('loginId')
#                 studentId= serializer.validated_data.get('studentId')
#                 academicyearId = serializer.validated_data.get('academicyearId')
#                 reciptdate = serializer.validated_data.get('reciptdate')
#                 paymentmethodId = serializer.validated_data.get('paymentmethodId')
#                 bankId = serializer.validated_data.get('bankId')
#                 accountnumber = serializer.validated_data.get('accountnumber')
#                 remarks = serializer.validated_data.get('remarks')
#                 referencedate = serializer.validated_data.get('referencedate')
#                 stdfeedetailsIds = serializer.validated_data.get('stdfeedetailsIds')
#                 period_month = serializer.validated_data.get('period_month')
#                 latefees = serializer.validated_data.get('latefees')
#
#                 discountfees = serializer.validated_data.get('discountfees')
#                 checkbouncefees = serializer.validated_data.get('checkbouncefees')
#                 readmissionfees = serializer.validated_data.get('readmissionfees')
#                 totalamount = serializer.validated_data.get('totalamount')
#
#
#
#                 #print(studentId,academicyearId,reciptdate,paymentmethodId,bankId,accountnumber,remark,referencedate,stdfeedetailsIds,latefees,totalamount)
#                 # Process StdFeeReceiptHeader
#                 RegistartionInstance = StudentRegistration.objects.get(id=studentId)
#
#                 # print(RegistartionInstance)
#
#                 # Academic Year Instance
#                 AcademicYearInstance = AcademicYear.objects.get(id=academicyearId)
#
#                 # print(AcademicYearInstance)
#
#                 #Payment Method
#                 paymentmethodInstance = GLPaymentMethod.objects.get(id=paymentmethodId)
#
#                 # print(paymentmethodInstance)
#
#                 # Period Month Instance
#
#                 #print(max(period_month))
#                 periodmonthInstance = Period.objects.get(id=max(period_month))
#                 #print(periodmonthInstance)
#
#
#
#
#
#                 # check to generate receipt_no
#                 def generate_receipt_number(academic_year_id):
#                     # Filter by the given academic year ID and get the max receipt_no within that year
#                     max_receipt_no = StdFeeReceiptHeader.objects.filter(academic_year_id=academic_year_id).aggregate(
#                         Max('receipt_no'))['receipt_no__max']
#
#                     if max_receipt_no is None:
#                         return 1  # Set to 1 if no receipts exist for this academic year
#                     return max_receipt_no + 1
#                 new_receipt_no= generate_receipt_number(academicyearId)
#                 # print(new_receipt_no)
#
#
#                 StdFeeReceiptHeaderInstance = StdFeeReceiptHeader.objects.create(
#
#                     receipt_no = new_receipt_no,
#                     academic_year_id = AcademicYearInstance,
#                     period_month = periodmonthInstance,
#                     receipt_date = reciptdate,
#                     student_id = RegistartionInstance,
#                     receipt_amount = totalamount,
#                     payment_method=paymentmethodInstance,
#                     payment_reference=remarks,
#                     payment_date = referencedate,
#                     receipt_status="APPROVED",
#                     cancellation_remarks= "",
#                     balance=totalamount,
#                     organization = AcademicYearInstance.organization,
#                     branch_id= AcademicYearInstance.branch_id,
#                     created_by=loginId
#
#
#                 )
#                 StdFeeReceiptHeaderInstance.save()
#
#
#
#                 StdPaymentInstance = StdPayment.objects.create(
#                     receipt_id=StdFeeReceiptHeaderInstance,
#                     payment_method=paymentmethodInstance,
#                     amount = totalamount,
#                     bank_id =bankId,   # dought
#                     bank_account_id = accountnumber,
#                     payment_reference = remarks,
#                     payment_date= reciptdate,
#                     reference_date=referencedate
#
#                 )
#
#                 StdPaymentInstance.save()
#
#                 # Total amount paid by Student
#                 grand_Paid_Amount = totalamount
#
#                 # Insert object for particular student
#
#                 if discountfees:
#                     grand_Paid_Amount = grand_Paid_Amount + discountfees
#                     period_month = list(sorted(set(period_month)))
#
#                     for prd in period_month:
#                         # print(prd)
#                         total_payment_amount = 0
#                         total_paid_amount =0
#                         #pending_payment_amount=0
#
#                         #Get period month instance
#                         periodmonthInstance = Period.objects.get(id=prd)
#                         studentfeedetailsrecord = StudentFeeDetail.objects.filter(period_month=periodmonthInstance.period_name)
#                         # print(studentfeedetailsrecord)
#
#                         for feedetailsId in stdfeedetailsIds:
#                             # print("data record")
#                             # Try to get the specific student fee detail matching feedetailsId
#                             matching_record = studentfeedetailsrecord.filter(id=feedetailsId).first()
#
#                             if matching_record:
#                                 # Add element_amount to payment if there's a match
#                                 total_payment_amount += matching_record.element_amount
#                                 total_paid_amount+= matching_record.paid_amount
#                                 # print(total_payment_amount)
#
#
#                             else:
#                                 # No match found, so continue to the next ID
#                                 continue
#
#                         pending_amount= total_payment_amount-total_paid_amount
#
#                         if discountfees > pending_amount:
#
#                             # Insert record in student fee details DB
#                             studentFeeDetailsInsertfeesInstance = StudentFeeDetail.objects.create(
#                                 student_id=RegistartionInstance,
#                                 fee_structure_id=None,
#                                 fee_structure_details_id=None,
#                                 element_name="DISCOUNT",
#                                 period_month=periodmonthInstance.period_name,
#                                 paid='Y',
#                                 academic_year_id=AcademicYearInstance,
#                                 organization=AcademicYearInstance.organization,
#                                 branch_id=AcademicYearInstance.branch_id,
#                                 multiplying_factor=1,
#                                 element_amount=-pending_amount,
#                                 total_element_period_amount=-pending_amount,
#                                 paid_amount=-pending_amount,
#                                 remarks="",
#                                 reverse_flag="",
#                                 created_by=loginId,
#                                 updated_by=loginId,
#
#                             )
#
#                             # Insert Record into StdFeeReceiptDetail
#
#                             stdfeereceiptInstance = StdFeeReceiptDetail.objects.create(
#                                 receipt_id=StdFeeReceiptHeaderInstance,
#                                 fee_detail_id=studentFeeDetailsInsertfeesInstance,
#                                 amount=-pending_amount,
#                                 discount_amount=-pending_amount,
#                                 created_by=loginId
#                             )
#                             stdfeereceiptInstance.save()
#
#                             discountfees-= pending_amount
#                             continue
#
#                         elif discountfees < pending_amount:
#
#                             # Insert record in student fee details DB
#                             studentFeeDetailsInsertfeesInstance = StudentFeeDetail.objects.create(
#                                 student_id=RegistartionInstance,
#                                 fee_structure_id=None,
#                                 fee_structure_details_id=None,
#                                 element_name="DISCOUNT",
#                                 period_month=periodmonthInstance.period_name,
#                                 paid='Y',
#                                 academic_year_id=AcademicYearInstance,
#                                 organization=AcademicYearInstance.organization,
#                                 branch_id=AcademicYearInstance.branch_id,
#                                 multiplying_factor=1,
#                                 element_amount=-discountfees,
#                                 total_element_period_amount=-discountfees,
#                                 paid_amount=-discountfees,
#                                 remarks="",
#                                 reverse_flag="",
#                                 created_by=loginId,
#                                 updated_by=loginId,
#
#                             )
#
#                             # Insert Record into StdFeeReceiptDetail
#                             stdfeereceiptInstance = StdFeeReceiptDetail.objects.create(
#                                 receipt_id=StdFeeReceiptHeaderInstance,
#                                 fee_detail_id=studentFeeDetailsInsertfeesInstance,
#                                 amount=-discountfees,
#                                 discount_amount=-discountfees,
#                                 created_by=loginId
#                             )
#                             stdfeereceiptInstance.save()
#                             discountfees -= discountfees
#                             break
#
#
#
#                 if latefees:
#                     if grand_Paid_Amount > latefees:
#
#                         # Insert New data into Student fee details
#                         studentFeeDetailsInsertlatefeesInstance = StudentFeeDetail.objects.create(
#                             student_id= RegistartionInstance,
#                             fee_structure_id = None,
#                             fee_structure_details_id = None,
#                             element_name = "LATE FEES",
#                             period_month = periodmonthInstance.period_name,
#                             paid = 'Y',
#                             academic_year_id = AcademicYearInstance,
#                             organization = AcademicYearInstance.organization,
#                             branch_id = AcademicYearInstance.branch_id,
#                             multiplying_factor = 1,
#                             element_amount= latefees,
#                             total_element_period_amount = latefees,
#                             paid_amount =latefees,
#                             remarks = "",
#                             reverse_flag = "",
#                             created_by = loginId,
#                             updated_by = loginId,
#
#                         )
#
#                         studentFeeDetailsInsertlatefeesInstance.save()
#                         grand_Paid_Amount=grand_Paid_Amount-latefees
#
#                         # Insert Record into StdFeeReceiptDetail
#                         stdfeereceiptInstance = StdFeeReceiptDetail.objects.create(
#                             receipt_id=StdFeeReceiptHeaderInstance,
#                             fee_detail_id=studentFeeDetailsInsertlatefeesInstance,
#                             amount=latefees,
#                             discount_amount=0,
#                             created_by=loginId
#                         )
#                         stdfeereceiptInstance.save()
#
#
#
#                     elif grand_Paid_Amount !=0 and grand_Paid_Amount < latefees:
#                         # Insert New data into Student fee details
#                         studentFeeDetailsInsertlatefeesInstance = StudentFeeDetail.objects.create(
#                             student_id=RegistartionInstance,
#                             fee_structure_id=None,
#                             fee_structure_details_id=None,
#                             element_name="LATE FEES",
#                             period_month=periodmonthInstance.period_name,
#                             paid='Y',
#                             academic_year_id=AcademicYearInstance,
#                             organization=AcademicYearInstance.organization,
#                             branch_id=AcademicYearInstance.branch_id,
#                             multiplying_factor=1,
#                             element_amount=latefees,
#                             total_element_period_amount=latefees,
#                             paid_amount=grand_Paid_Amount,
#                             remarks="",
#                             reverse_flag="",
#                             created_by=loginId,
#                             updated_by=loginId,
#
#                         )
#
#                         studentFeeDetailsInsertlatefeesInstance.save()
#                         grand_Paid_Amount = grand_Paid_Amount - grand_Paid_Amount
#
#                         # Insert Record into StdFeeReceiptDetail
#                         stdfeereceiptInstance = StdFeeReceiptDetail.objects.create(
#                             receipt_id=StdFeeReceiptHeaderInstance,
#                             fee_detail_id=studentFeeDetailsInsertlatefeesInstance,
#                             amount=grand_Paid_Amount,
#                             discount_amount=0,
#                             created_by=loginId
#                         )
#                         stdfeereceiptInstance.save()
#
#
#
#
#
#
#
#                 if checkbouncefees:
#                     if grand_Paid_Amount > checkbouncefees:
#                         studentFeeDetailsInsertcheckbouncefeesInstance = StudentFeeDetail.objects.create(
#                             student_id=RegistartionInstance,
#                             fee_structure_id=None,
#                             fee_structure_details_id=None,
#                             element_name="CHECK BOUNCE",
#                             period_month=periodmonthInstance.period_name,
#                             paid='Y',
#                             academic_year_id=AcademicYearInstance,
#                             organization=AcademicYearInstance.organization,
#                             branch_id=AcademicYearInstance.branch_id,
#                             multiplying_factor=1,
#                             element_amount=checkbouncefees,
#                             total_element_period_amount=checkbouncefees,
#                             paid_amount=checkbouncefees,
#                             remarks="",
#                             reverse_flag="",
#                             created_by=loginId,
#                             updated_by=loginId,
#
#                         )
#
#                         studentFeeDetailsInsertcheckbouncefeesInstance.save()
#                         grand_Paid_Amount= grand_Paid_Amount-checkbouncefees
#
#                         # Insert Record into StdFeeReceiptDetail
#                         stdfeereceiptInstance = StdFeeReceiptDetail.objects.create(
#                             receipt_id=StdFeeReceiptHeaderInstance,
#                             fee_detail_id=studentFeeDetailsInsertcheckbouncefeesInstance,
#                             amount=checkbouncefees,
#                             discount_amount=0,
#                             created_by=loginId
#                         )
#                         stdfeereceiptInstance.save()
#
#                     elif grand_Paid_Amount!=0 and grand_Paid_Amount < checkbouncefees:
#                         studentFeeDetailsInsertcheckbouncefeesInstance = StudentFeeDetail.objects.create(
#                             student_id=RegistartionInstance,
#                             fee_structure_id=None,
#                             fee_structure_details_id=None,
#                             element_name="CHECK BOUNCE",
#                             period_month=periodmonthInstance.period_name,
#                             paid='Y',
#                             academic_year_id=AcademicYearInstance,
#                             organization=AcademicYearInstance.organization,
#                             branch_id=AcademicYearInstance.branch_id,
#                             multiplying_factor=1,
#                             element_amount=checkbouncefees,
#                             total_element_period_amount=checkbouncefees,
#                             paid_amount=grand_Paid_Amount,
#                             remarks="",
#                             reverse_flag="",
#                             created_by=loginId,
#                             updated_by=loginId,
#
#                         )
#
#                         studentFeeDetailsInsertcheckbouncefeesInstance.save()
#                         grand_Paid_Amount= grand_Paid_Amount-grand_Paid_Amount
#
#                         # Insert Record into StdFeeReceiptDetail
#                         stdfeereceiptInstance = StdFeeReceiptDetail.objects.create(
#                             receipt_id=StdFeeReceiptHeaderInstance,
#                             fee_detail_id=studentFeeDetailsInsertcheckbouncefeesInstance,
#                             amount=checkbouncefees,
#                             discount_amount=0,
#                             created_by=loginId
#                         )
#                         stdfeereceiptInstance.save()
#
#
#                 if readmissionfees:
#                     if grand_Paid_Amount > readmissionfees:
#                         studentFeeDetailsInsertreadmissionfeesInstance = StudentFeeDetail.objects.create(
#                             student_id=RegistartionInstance,
#                             fee_structure_id=None,
#                             fee_structure_details_id=None,
#                             element_name="RE ADMISSION",
#                             period_month=periodmonthInstance.period_name,
#                             paid='Y',
#                             academic_year_id=AcademicYearInstance,
#                             organization=AcademicYearInstance.organization,
#                             branch_id=AcademicYearInstance.branch_id,
#                             multiplying_factor=1,
#                             element_amount=readmissionfees,
#                             total_element_period_amount=readmissionfees,
#                             paid_amount=readmissionfees,
#                             remarks="",
#                             reverse_flag="",
#                             created_by=loginId,
#                             updated_by=loginId,
#
#                         )
#
#                         studentFeeDetailsInsertreadmissionfeesInstance.save()
#                         grand_Paid_Amount = grand_Paid_Amount-readmissionfees
#
#                         # Insert Record into StdFeeReceiptDetail
#                         stdfeereceiptInstance = StdFeeReceiptDetail.objects.create(
#                             receipt_id=StdFeeReceiptHeaderInstance,
#                             fee_detail_id=studentFeeDetailsInsertreadmissionfeesInstance,
#                             amount=readmissionfees,
#                             discount_amount=0,
#                             created_by=loginId
#                         )
#                         stdfeereceiptInstance.save()
#
#                     elif grand_Paid_Amount!=0 and grand_Paid_Amount< readmissionfees:
#                         studentFeeDetailsInsertreadmissionfeesInstance = StudentFeeDetail.objects.create(
#                             student_id=RegistartionInstance,
#                             fee_structure_id=None,
#                             fee_structure_details_id=None,
#                             element_name="RE ADMISSION",
#                             period_month=periodmonthInstance.period_name,
#                             paid='N',
#                             academic_year_id=AcademicYearInstance,
#                             organization=AcademicYearInstance.organization,
#                             branch_id=AcademicYearInstance.branch_id,
#                             multiplying_factor=1,
#                             element_amount=readmissionfees,
#                             total_element_period_amount=readmissionfees,
#                             paid_amount=grand_Paid_Amount,
#                             remarks="",
#                             reverse_flag="",
#                             created_by=loginId,
#                             updated_by=loginId,
#
#                         )
#
#                         studentFeeDetailsInsertreadmissionfeesInstance.save()
#                         grand_Paid_Amount = grand_Paid_Amount - grand_Paid_Amount
#
#                         # Insert Record into StdFeeReceiptDetail
#                         stdfeereceiptInstance = StdFeeReceiptDetail.objects.create(
#                             receipt_id=StdFeeReceiptHeaderInstance,
#                             fee_detail_id=studentFeeDetailsInsertreadmissionfeesInstance,
#                             amount=grand_Paid_Amount,
#                             discount_amount=0,
#                             created_by=loginId
#                         )
#                         stdfeereceiptInstance.save()
#
#
#
#                 # print(grand_Paid_Amount)
#                 if grand_Paid_Amount !=0:
#                     for item in stdfeedetailsIds:
#                         # print(item)
#                         studentFeedetailsInstance = StudentFeeDetail.objects.get(id=item)
#                         paymentamount= studentFeedetailsInstance.element_amount - studentFeedetailsInstance.paid_amount
#
#                         if grand_Paid_Amount >= paymentamount:
#                             studentFeedetailsInstance.paid_amount = paymentamount + studentFeedetailsInstance.paid_amount
#                             # studentFeedetailsInstance.total_element_period_amount = studentFeedetailsInstance.element_amount
#                             studentFeedetailsInstance.paid = "Y"
#                             studentFeedetailsInstance.save()
#                             grand_Paid_Amount = grand_Paid_Amount - paymentamount
#
#                             # Insert Record into StdFeeReceiptDetail
#                             stdfeereceiptInstance = StdFeeReceiptDetail.objects.create(
#                                 receipt_id=StdFeeReceiptHeaderInstance,
#                                 fee_detail_id=studentFeedetailsInstance,
#                                 amount=paymentamount,
#                                 discount_amount=0,
#                                 created_by=loginId
#                             )
#                             stdfeereceiptInstance.save()
#
#                             continue
#
#                         if grand_Paid_Amount < paymentamount and grand_Paid_Amount != 0:
#                             studentFeedetailsInstance.paid_amount = studentFeedetailsInstance.paid_amount+ grand_Paid_Amount
#                             # studentFeedetailsInstance.total_element_period_amount = grand_Paid_Amount
#                             # studentFeelateDetailsInstance.paid = "N"
#                             studentFeedetailsInstance.save()
#                             # grand_Paid_Amount = grand_Paid_Amount - grand_Paid_Amount
#
#                             # Insert Record into StdFeeReceiptDetail
#                             stdfeereceiptInstance = StdFeeReceiptDetail.objects.create(
#                                 receipt_id=StdFeeReceiptHeaderInstance,
#                                 fee_detail_id=studentFeedetailsInstance,
#                                 amount=grand_Paid_Amount,
#                                 discount_amount=0,
#                                 created_by=loginId
#                             )
#                             stdfeereceiptInstance.save()
#
#                             break
#                 # make response
#
#                 studentId= StdFeeReceiptHeaderInstance.student_id.id
#
#                 # Get Student Basic Details Based on Student Id
#                 RegistrationInstance = StudentRegistration.objects.get(id=studentId)
#
#                 # Get student current Details in Student class DB
#
#                 StudentCourseInstance = StudentCourse.objects.get(student_id=studentId,is_active=True)
#
#                courseInstance = Course.objects.get(id=StudentCourseInstance.addmitted_class.id)
#
#                 sectionInstance = Section.objects.get(id=StudentCourseInstance.addmitted_section.id)
#
#                 # Recipt Details
#
#                 academicyearInstance = AcademicYear.objects.get(id=StdFeeReceiptHeaderInstance.academic_year_id.id)
#
#
#
#
#
#
#                 # Fee period Get
#
#                 # Get Payment Method & detials
#
#                 StdPaymentInstance = StdPayment.objects.get(receipt_id=StdFeeReceiptHeaderInstance.id)
#
#                 # payment Method Instance
#                 PaymentmethodInstance = GLPaymentMethod.objects.get(id=StdPaymentInstance.payment_method.id)
#
#
#                 # Get Student Fee Recipt Based On Receipt
#
#                 feereceiptsobjects= StdFeeReceiptDetail.objects.filter(receipt_id=StdFeeReceiptHeaderInstance.id)
#
#
#                 # Get fee payment By Student
#                 fee_periods=[]
#                 paid_element ={}
#
#                 for item in feereceiptsobjects:
#
#                     # Get Student Fee Details Instance
#
#                     studentfeedetailsInstance = StudentFeeDetail.objects.get(id=item.fee_detail_id.id)
#
#                     fee_periods.append(studentfeedetailsInstance.period_month)
#
#                     element_name =studentfeedetailsInstance.element_name
#                     paid_amount = studentfeedetailsInstance.paid_amount
#
#                     # Update paid_element dictionary
#                     if element_name in paid_element:
#                         # Add to existing amount if element_name already exists
#                         paid_element[element_name]["amount"] += paid_amount
#                     else:
#                         # Create a new entry if element_name does not exist
#                         paid_element[element_name] = {"element_name": element_name, "amount": paid_amount}
#
#
#                 Total_academic_year_fees_objects = StudentFeeDetail.objects.filter(academic_year_id=academicyearId,student_id=studentId)
#
#                 # Calculate total amount (sum of element_amount)
#                 total_amount = Total_academic_year_fees_objects.aggregate(total=Sum('element_amount'))['total'] or 0
#
#                 # Calculate total paid amount (sum of paid_amount)
#                 total_paid_amount = Total_academic_year_fees_objects.aggregate(total_paid=Sum('paid_amount'))['total_paid'] or 0
#
# # Calculate remaining amount
# remaining_amount = total_amount - total_paid_amount
#
#
#                 responsedata={
#                     'id': StdFeeReceiptHeaderInstance.id,
#                     'receipt_no': StdFeeReceiptHeaderInstance.receipt_no,
#                     'academicyear': academicyearInstance.sesion_code,
#                     'receipt_date':StdFeeReceiptHeaderInstance.receipt_date,
#                     'studentname': f'{RegistrationInstance.first_name} {RegistrationInstance.middle_name} {RegistrationInstance.last_name}',
#                     'admission_no': RegistrationInstance.admission_no,
#                     'classname':courseInstance.classname,
#                     'sectionname': sectionInstance.sectionname,
#                     'fathername': RegistrationInstance.father_name,
#                     'payment_method': PaymentmethodInstance.payment_method,
#                     'payment_reference': StdPaymentInstance.payment_reference,
#                     'amount': StdPaymentInstance.amount,
#                     'feeperiods': sorted(set(fee_periods)),
#                     'payment_element_list': paid_element,
#                     'total_academic_year_fees': total_amount,
#                     'total_paid': total_paid_amount,
#                     'remaining_amount': remaining_amount
#
#
#
#
#                 }
#
#
#                 #print(grand_Paid_Amount)
#
#                 return Response({'message':'Your Payment Received Successfully!!','receipt_data': responsedata},status=status.HTTP_200_OK)  # recipt no need to send
#
#
#         except ValidationError as e:
#
#             # Rollback the transaction on validation error
#
#             return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)
#
#
#         except DatabaseError as e:
#
#             # Rollback the transaction on database error
#
#             self.log_exception(request, str(e))
#
#             return Response({'error': 'A database error occurred: ' + str(e)},
#
#                             status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#
#         except Exception as e:
#
#             # Rollback the transaction on any other exception
#
#             self.log_exception(request, str(e))
#
#             return Response({'error': 'An unexpected error occurred: ' + str(e)},
#
#                             status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#     def log_exception(self, request, error_message):
#
#         ExceptionTrack.objects.create(
#
#             request=str(request),
#
#             process_name='feereciptscreate',
#
#             message=error_message,
#
#         )

class StudentFeeReceiptSearchBasedOnCondition(ListAPIView):
    serializer_class = StudentFeeReceiptSearchSerializer

    def list(self, request, *args, **kwargs):
        try:
            # Initialize filter dictionary
            # filter_criteria = {}

            # Fetch query parameters
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            batch_id = request.query_params.get('batch_id')
            course_id = request.query_params.get('course_id')
            department_id = request.query_params.get('department_id')
            academic_year_id = request.query_params.get('academic_year_id')
            semester_id = request.query_params.get('semester_id')
            section_id = request.query_params.get('section_id')
            student_id = request.query_params.get('student_id')
            receipt_from = request.query_params.get('receipt_from')
            receipt_to = request.query_params.get('receipt_to')
            receipt_no = request.query_params.get('receipt_no')
            view_receipt = request.query_params.get('view_receipt')
            view_cancel_receipt = request.query_params.get('view_cancel_receipt')
            fee_semester = request.query_params.get('fee_semester')
            date_from = request.query_params.get('date_from')
            date_to = request.query_params.get('date_to')
            # print(view_receipt,type(view_receipt))

            filterdata = StudentFeeReceiptHeader.objects.none()

            if organization_id and branch_id:
                try:
                    filterdata = StudentFeeReceiptHeader.objects.filter(organization=organization_id, branch=branch_id,
                                                                        is_active=True).order_by('-updated_at')
                except StudentFeeReceiptHeader.DoesNotExist:
                    return Response({"message": "student_fee_receipt_header record not found !!!"},
                                    status=status.HTTP_404_NOT_FOUND)
            else:
                return Response({"message": "organization_id and branch_id is required !!!"},
                                status=status.HTTP_404_NOT_FOUND)

            # print(filterdata)
            # Filter Based on Academic Year
            if filterdata:
                if student_id:
                    filterdata = filterdata.filter(student=student_id)
                if receipt_no:
                    filterdata = filterdata.filter(receipt_no=receipt_no)
                if view_receipt:
                    if view_receipt.lower() == "true":
                        filterdata = filterdata.filter(receipt_status='APPROVED')
                if view_cancel_receipt:
                    if view_cancel_receipt.lower() == "true":
                        filterdata = filterdata.filter(receipt_status='CANCEL')
                if batch_id:
                    filterdata = filterdata.filter(batch=batch_id)
                if course_id:
                    filterdata = filterdata.filter(course=course_id)
                if department_id:
                    filterdata = filterdata.filter(department=department_id)
                if academic_year_id:
                    filterdata = filterdata.filter(academic_year=academic_year_id)
                if semester_id:
                    filterdata = filterdata.filter(semester=semester_id)
                if section_id:
                    filterdata = filterdata.filter(section=section_id)
                if date_from and date_to:
                    filterdata = filterdata.filter(receipt_date__range=(date_from, date_to))
                # Removed default filter to today's date - students should see ALL receipts when no date filter is provided
                # if not date_from and not date_to:
                #     filterdata = filterdata.filter(receipt_date=date.today())
                if date_from and not date_to:
                    filterdata = filterdata.filter(receipt_date__range=(date_from, date.today()))
                if not date_from and date_to:
                    return Response({"message": "date_from is required !!!"}, status=status.HTTP_400_BAD_REQUEST)

            #
            # if batch_id:

            # if academicyearId:
            #     if view_receipt == "true":
            #         filterdata = StudentFeeReceiptHeader.objects.filter(
            #             academic_year_id=academicyearId,
            #             receipt_status='APPROVED',
            #         )
            #
            #
            #     elif view_cancel_receipt == "true":
            #         # Filter for canceled receipts or records where receipt_status is null
            #         filterdata = StudentFeeReceiptHeader.objects.filter(
            #             academic_year_id=academicyearId).filter(Q(receipt_status='CANCEL') | Q(receipt_status__isnull=True))
            #

            # if receipt_from and receipt_to:
            #     filterdata = filterdata.filter(receipt_date__range=(receipt_from, receipt_to))
            # elif receipt_from and not receipt_to:
            #     # Filter records where receipt_date is on or after receipt_from
            #     filterdata = filterdata.filter(receipt_date__gte=receipt_from)

            # elif receipt_to and not receipt_from:
            #     # Filter records where receipt_date is on or before receipt_to
            #     filterdata = filterdata.filter(receipt_date__lte=receipt_to)

            # elif feePeriod:
            #     filterdata = filterdata.filter(period_month=feePeriod)

            # print(filterdata)
            # elif studentId:
            #     filterdata = filterdata.filter(student=studentId)

            # elif receiptNo:
            #     filterdata = filterdata.filter(receipt_no=receiptNo)

            # Filter by course_id and section_id if provided
            # elif course_id:
            #     student_course_filter = StudentCourse.objects.filter(course=course_id, is_active=True)
            #
            #     if section_id:
            #         student_course_filter = student_course_filter.filter(section=section_id)
            #
            #     # Get all active student IDs in the specified course_id and section_id
            #     student_ids_in_class_section = student_course_filter.values_list('student', flat=True)
            #
            #     # Filter the main queryset based on these student IDs
            #     filterdata = filterdata.filter(student__in=student_ids_in_class_section)

            # print(filterdata)
            # for item in filterdata:
            #     studentId = item.student_id
            #     if studentId:
            #         filterdata = StudentRegistration.objects.prefetch_related('')
            # make Response record
            # Initialize totals

            responsedata = []
            if filterdata:

                for item in filterdata:
                    # student = item.student

                    # Reset totals for this specific receipt
                    total_amount = 0
                    total_discount = 0

                    # Get instance on Registration model
                    # try:
                    #     RegistrationInstance = StudentRegistration.objects.get(id=studentId.id)   #,academic_year_id=academicyearId
                    # except Exception as e:
                    #     return Response({'message': f'student does not exist in academic year {academicyearId}, registration' , 'data': responsedata}, status=status.HTTP_200_OK)
                    #     RegistrationInstance = []
                    try:
                        studentcourseInstance = StudentCourse.objects.get(student=item.student, is_active=True)
                    except Exception as e:
                        return Response(
                            {"message": f"student_course record not found of student_id is {item.student.id}"},
                            status=status.HTTP_404_NOT_FOUND)
                        # return Response({'message': f'student does not exist in academic year {academicyearId}, student class & {RegistrationInstance.first_name} & {RegistrationInstance.admission_no}' , 'data': responsedata}, status=status.HTTP_200_OK)
                    # try:
                    #     periodmonthInstance = Period.objects.get(id=item.period_month.id)
                    # except Exception as e:
                    #     return Response({'message': f'student does not exist in academic year {academicyearId}, period' , 'data': responsedata}, status=status.HTTP_200_OK)
                    # try:
                    #    courseInstance = Course.objects.get(id=studentcourseInstance.course.id)
                    # except Exception as e:
                    #     return Response({'message': f'student does not exist in academic year {academicyearId}, class' , 'data': responsedata}, status=status.HTTP_200_OK)
                    # try:
                    #     sectionInstance = Section.objects.get(id=studentcourseInstance.section.id)
                    # except Exception as e:
                    #     return Response({'message': f'student does not exist in academic year {academicyearId}, section' , 'data': responsedata}, status=status.HTTP_200_OK)
                    # try:
                    # RegistrationInstance = StudentRegistration.objects.get(id=studentcourseInstance.studentId.id,
                    #                                                          academic_year_id=academicyearId)
                    # payment Method Instance
                    # StdPaymentInstance = StdPayment.objects.filter(receipt_id=item.id)

                    # Get related receipt details
                    receiptdetailsrecords = StudentFeeReceiptDetail.objects.filter(receipt_id=item.id)
                    # print(receiptdetailsrecords)

                    # Calculate total amount and discount for the current receipt
                    if receiptdetailsrecords:
                        receipt_total_amount = sum(detail.amount for detail in receiptdetailsrecords)
                        receipt_total_discount = sum(detail.discount_amount or 0 for detail in receiptdetailsrecords)

                        # Add totals to the overall totals
                        total_amount += receipt_total_amount
                        total_discount += receipt_total_discount

                    student_name = filter(None, [
                        # item.student.title,
                        item.student.first_name,
                        item.student.middle_name,
                        item.student.last_name

                    ])
                    student_name = ' '.join(student_name)


                    # Extract payment method from payment_detail JSON if it exists
                    payment_method_value = None
                    if item.payment_detail:
                        if isinstance(item.payment_detail, dict):
                            payment_method_value = item.payment_detail.get('payment_type', None)
                        elif isinstance(item.payment_detail, str):
                            # If it's a string (JSON string), try to parse it
                            try:
                                import json
                                payment_detail_dict = json.loads(item.payment_detail)
                                payment_method_value = payment_detail_dict.get('payment_type', None)
                            except:
                                payment_method_value = item.payment_detail

                    # Get the actual semester for which fee was paid from receipt details
                    # Instead of student's current semester from StudentCourse
                    receipt_semester_id = None
                    receipt_semester_description = None
                    if receiptdetailsrecords:
                        # Get the first receipt detail's fee_detail to find the semester
                        first_detail = receiptdetailsrecords.first()
                        print(f"DEBUG: Processing receipt {item.id}, first_detail exists: {first_detail is not None}")
                        if first_detail and first_detail.fee_detail:
                            print(f"DEBUG: fee_detail ID: {first_detail.fee_detail.id}, element: {first_detail.fee_detail.element_name}")
                            print(f"DEBUG: fee_applied_from: {first_detail.fee_detail.fee_applied_from}")
                            print(f"DEBUG: semester: {first_detail.fee_detail.semester}")
                            # Use semester field FIRST (it has correct data)
                            # fee_applied_from is often incorrectly set to "1st Semester" for all records
                            if first_detail.fee_detail.semester:
                                receipt_semester_id = first_detail.fee_detail.semester.id
                                receipt_semester_description = first_detail.fee_detail.semester.semester_description
                                print(f"DEBUG: Using semester field: {receipt_semester_description}")
                            elif first_detail.fee_detail.fee_applied_from:
                                # Fallback to fee_applied_from if semester is not set
                                receipt_semester_id = first_detail.fee_detail.fee_applied_from.id
                                receipt_semester_description = first_detail.fee_detail.fee_applied_from.semester_description
                                print(f"DEBUG: Using fee_applied_from (fallback): {receipt_semester_description}")

                    # Fallback to student's current semester if receipt doesn't have semester info
                    if not receipt_semester_id:
                        receipt_semester_id = studentcourseInstance.semester.id
                        receipt_semester_description = studentcourseInstance.semester.semester_description
                        print(f"DEBUG: Using fallback (student current semester): {receipt_semester_description}")
                    else:
                        print(f"DEBUG: Final semester for receipt {item.id}: {receipt_semester_description}")

                    # Make response data
                    responsedata.append({
                        'receiptId': item.id,
                        'receipt_id': item.id,  # Frontend also checks for receipt_id
                        'id': item.id,  # Frontend also checks for id
                        'receipt_no': item.receipt_no,
                        'studentId': item.student.id,
                        # 'studentname': f'{RegistrationInstance.first_name}{RegistrationInstance.middle_name}{RegistrationInstance.last_name}',
                        'student_name': student_name,
                        'father_name': item.student.father_name,
                        'course_id': studentcourseInstance.course.id,
                        'course_name': studentcourseInstance.course.course_name,
                        'department_id': studentcourseInstance.department.id,
                        'department_description': studentcourseInstance.department.department_description,
                        'academic_year_id': studentcourseInstance.academic_year.id,
                        'academic_year_code': studentcourseInstance.academic_year.academic_year_code,
                        'semester_id': receipt_semester_id,  # Use semester from receipt, not student's current semester
                        'semester_description': receipt_semester_description,  # Use semester from receipt
                        'semester': receipt_semester_description,  # Frontend looks for 'semester' - use receipt semester
                        'section_id': studentcourseInstance.section.id,
                        'section_name': studentcourseInstance.section.section_name,
                        'barcode': item.student.barcode,
                        'college_admission_no': item.student.college_admission_no,
                        # 'payment_reference': item.payment_reference,

                        'cancellation_remarks': item.cancellation_remarks,
                        'receiptDate': item.receipt_date,
                        'receipt_date': item.receipt_date,  # Frontend looks for 'receipt_date' (lowercase)
                        'amount': total_amount,
                        'receipt_amount': total_amount,  # Frontend looks for 'receipt_amount'
                        'payment_amount': total_amount,  # Frontend also checks for 'payment_amount'
                        'discount_amount': total_discount,
                        'discount': total_discount,  # Frontend also checks for 'discount'
                        'payment_detail': item.payment_detail,
                        'payment_method': payment_method_value,  # Frontend looks for 'payment_method' (extracted from payment_detail)
                        'payment_method_name': payment_method_value  # Frontend also checks for 'payment_method_name'
                        # 'period_month': periodmonthInstance.period_name,

                    })
                return Response({'message': 'success', 'data': responsedata}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!!'}, status=status.HTTP_200_OK)

        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='filterfeereceipts',

            message=error_message,

        )


class GetFeeReceiptBasedOnReceiptNo(ListAPIView):
    serializer_class = StudentFeeReceiptSerializer

    def list(self, request, *args, **kwargs):
        try:
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            receipt_no = request.query_params.get('receipt_no')
            # academicyearId = self.kwargs.get('academic_year_Id')

            # print(receiptNo,academicyearId)

            # Get StdFeeReceipt Header Instance (get the latest if duplicates exist)
            StudentFeeReceiptHeaderInstance = StudentFeeReceiptHeader.objects.filter(
                organization=organization_id,
                branch=branch_id,
                receipt_no=receipt_no,
                is_active=True
            ).order_by('-created_at').first()

            if not StudentFeeReceiptHeaderInstance:
                return Response({'message': 'Receipt No  Not Found'}, status=status.HTTP_404_NOT_FOUND)
            # print(StdFeeReceiptHeaderInstance)
            studentId = StudentFeeReceiptHeaderInstance.student.id

            # Get Student Basic Details Based on Student Id
            RegistrationInstance = StudentRegistration.objects.get(id=studentId)
            # print(RegistrationInstance)

            # Get student current Details in Student class DB
            if studentId:
                try:
                    StudentCourseInstance = StudentCourse.objects.get(student_id=studentId, is_active=True)
                except StudentCourse.DoesNotExist:
                    return Response({"message": "Student course record not found "})
            # print(StudentCourseInstance)
            #  courseInstance = Course.objects.get(id=StudentCourseInstance.course.id)
            # print(courseInstance)
            # sectionInstance = Section.objects.get(id=StudentCourseInstance.section.id)
            # print(sectionInstance)
            # Recipt Details

            # academicyearInstance = AcademicYear.objects.get(
            #     id=StudentFeeReceiptHeaderInstance.academic_year_id.id)

            # Fee period Get

            # Get Payment Method & detials

            StudentPaymentInstance = StudentPayment.objects.get(receipt_id=StudentFeeReceiptHeaderInstance.id)

            # payment Method Instance
            PaymentmethodInstance = PaymentMethod.objects.get(id=StudentPaymentInstance.payment_method.id)

            # Get filter data Into  FeeReceiptDetail DB

            feereceiptsobjects = StudentFeeReceiptDetail.objects.filter(receipt_id=StudentFeeReceiptHeaderInstance.id)

            # Get fee payment By Student
            fee_semesters = []
            paid_element = {}

            for item in feereceiptsobjects:

                # Get Student Fee Details Instance

                studentfeedetailsInstance = StudentFeeDetail.objects.get(id=item.fee_detail.id)

                fee_semesters.append(studentfeedetailsInstance.semester.semester_description)

                element_name = studentfeedetailsInstance.element_name
                paid_amount = studentfeedetailsInstance.paid_amount

                # Update paid_element dictionary
                if element_name in paid_element:
                    # Add to existing amount if element_name already exists
                    paid_element[element_name]["amount"] += paid_amount
                else:
                    # Create a new entry if element_name does not exist
                    paid_element[element_name] = {"element_name": element_name, "amount": paid_amount}

            Total_fees_objects = StudentFeeDetail.objects.filter(student_id=studentId)

            # Calculate total amount (sum of element_amount)
            total_amount = Total_fees_objects.aggregate(total=Sum('element_amount'))['total'] or 0

            # Calculate total paid amount (sum of paid_amount)
            total_paid_amount = Total_fees_objects.aggregate(total_paid=Sum('paid_amount'))[
                                    'total_paid'] or 0

            # Calculate remaining amount
            remaining_amount = total_amount - total_paid_amount

            student_name = filter(None, [
                # Student.title,
                StudentCourseInstance.student.first_name,
                StudentCourseInstance.student.middle_name,
                StudentCourseInstance.student.last_name

            ])

            responsedata = {
                'receiptId': StudentFeeReceiptHeaderInstance.id,
                'receipt_no': StudentFeeReceiptHeaderInstance.receipt_no,
                # 'academicyear': StudentCourseInstance.academic_year.academic_year_code,
                'receipt_date': StudentFeeReceiptHeaderInstance.receipt_date,
                'student_name': student_name,
                'admission_no': RegistrationInstance.admission_no,
                'course_name': StudentCourseInstance.course.course_name,
                'department_name': StudentCourseInstance.department.department_description,
                'academic_year_code': StudentCourseInstance.academic_year.academic_year_code,
                'semester_name': StudentCourseInstance.semester.semester_description,
                'section_name': StudentCourseInstance.section.section_name,
                'father_name': RegistrationInstance.father_name,
                'payment_method': PaymentmethodInstance.payment_method,
                'payment_reference': StudentPaymentInstance.payment_reference,
                'amount': StudentPaymentInstance.amount,
                'fee_semesters': sorted(set(fee_semesters)),
                'payment_element_list': paid_element,
                'total_academic_year_fees': total_amount,
                'total_paid': total_paid_amount,
                'remaining_amount': remaining_amount

            }

            # print(grand_Paid_Amount)

            return Response({'message': 'Your Payment Received Successfully!!', 'receipt_data': responsedata},
                            status=status.HTTP_200_OK)  # recipt no need to send
        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='feereceipts',

            message=error_message,

        )


class GetMessageTypeListAPIView(ListAPIView):
    queryset = MessageType.objects.all()
    serializer_class = MessageTypeSerializer

    def list(self, request, *args, **kwargs):
        try:
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            # response = super().list(request, *args, **kwargs)
            if organization_id and branch_id:
                try:
                    resdata = MessageType.objects.filter(organization=organization_id, branch=branch_id, is_active=True)
                except MessageType.DoesNotExist:
                    return Response({"message": "message_type record not found !!!"},
                                    status=status.HTTP_204_NO_CONTENT)
            else:
                return Response({"message": "organization_id and branch_id is required !!!"},
                                status=status.HTTP_400_BAD_REQUEST)
            responsedata = []
            if resdata:

                for item in resdata:
                    # if item.get('is_active') == True:
                    # academicyearInstance = AcademicYear.objects.get(id=item.get('academic_year_id'))

                    # Prepare the custom response data
                    responsedata.append({
                        'organization_id': item.organization.id,
                        'organization': item.organization.organization_description,
                        'branch_id': item.branch.id,
                        'branch': item.branch.branch_name,
                        'id': item.id,
                        'message_type': item.message_type,
                        'message_type_description': item.message_type_description,
                        # 'message_default_text': item.message_default_text,

                        # 'academicyearId': academicyearInstance.id,
                        # 'academicYear': academicyearInstance.academic_year_code

                    })
                    # else:
                    #     continue

            if responsedata:
                return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='Message_Type_List',

            message=error_message,

        )


class MessageInitiatedListAPIView(ListAPIView):
    queryset = MessageInitiated.objects.all()
    serializer_class = MessageInitiatedSerializer

    def list(self, request, *args, **kwargs):
        try:
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            # response = super().list(request, *args, **kwargs)
            if organization_id and branch_id:
                try:
                    resdata = MessageInitiated.objects.filter(organization=organization_id, branch=branch_id,
                                                              is_active=True)
                except MessageType.DoesNotExist:
                    return Response({"message": "message_type record not found !!!"},
                                    status=status.HTTP_204_NO_CONTENT)
            else:
                return Response({"message": "organization_id and branch_id is required !!!"},
                                status=status.HTTP_400_BAD_REQUEST)
            # response = super().list(request, *args, **kwargs)
            # resdata = response.data
            responsedata = []
            if resdata:

                for item in resdata:
                    # if item.get('is_active') == True:
                    #     academicyearInstance = AcademicYear.objects.get(id=item.get('academic_year_id'))

                    # Prepare the custom response data
                    responsedata.append({
                        'organization_id': item.organization.id,
                        'organization': item.organization.organization_description,
                        'branch_id': item.branch.id,
                        'branch': item.branch.branch_name,
                        'id': item.id,
                        'initiated_by': item.initiated_by,
                        'initiated_by_description': item.initiated_by_description,
                        # 'academicyearId': academicyearInstance.id,
                        # 'academicYear': academicyearInstance.academic_year_code

                    })
                    # else:
                    #     continue

            if responsedata:
                return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='Message_InitiatedList',

            message=error_message,

        )


class StudentMessageSaveCreateAPIView(CreateAPIView):
    queryset = StudentMessagesHistory.objects.all()
    serializer_class = StudentMessageHistorySerializer

    @transaction.atomic
    def create(self, request, *args, **kwargs):
        try:
            # Start a new atomic transaction
            with transaction.atomic():
                # Validate and save data
                serializer = self.get_serializer(data=request.data)
                serializer.is_valid(raise_exception=True)
                # print(serializer)
                organization_id = serializer.validated_data.get('organization_id')
                branch_id = serializer.validated_data.get('branch_id')
                batch_id = serializer.validated_data.get('batch_id')
                course_id = serializer.validated_data.get('course_id')
                department_id = serializer.validated_data.get('department_id')
                academic_year_id = serializer.validated_data.get('academic_year_id')
                semester_id = serializer.validated_data.get('semester_id')
                section_id = serializer.validated_data.get('section_id')
                login_id = serializer.validated_data.get('login_id')
                message_list = serializer.validated_data.get('message_list')
                message_type = serializer.validated_data.get('message_type')
                message_date = serializer.validated_data.get('message_date')
                message_time = serializer.validated_data.get('message_time')
                message_sent_to = serializer.validated_data.get('message_sent_to')
                student_ids = serializer.validated_data.get('student_ids')
                initiated_by_ids = serializer.validated_data.get('initiated_by_ids')
                initiated_remark_list = serializer.validated_data.get('initiated_remark_list')

                # Process save message based on student

                # Academic Instance
                try:
                    academicyearInstance = AcademicYear.objects.get(id=academic_year_id, is_active=True)
                except AcademicYear.DoesNotExist:
                    return Response({"message": "Academic Year record not found"}, status=status.HTTP_400_BAD_REQUEST)

                # Message Type Instance
                try:
                    messagetypeInstance = MessageType.objects.get(id=message_type, is_active=True)
                except MessageType.DoesNotExist:
                    return Response({"message": "Message Type record not found"}, status=status.HTTP_400_BAD_REQUEST)

                place = 0
                for std in student_ids:
                    initiated_by = initiated_by_ids[place]
                    try:
                        initiatedInstance = MessageInitiated.objects.get(id=initiated_by)
                    except MessageInitiated.DoesNotExist:
                        return Response({"message": "Message Initiated record not found"},
                                        status=status.HTTP_400_BAD_REQUEST)

                    initiated_remark = initiated_remark_list[place]
                    message = message_list[place]

                    try:
                        RegistrationInstance = StudentRegistration.objects.get(id=std, is_active=True)
                    except StudentRegistration.DoesNotExist:
                        return Response({"message": "Student Registration record not found"},
                                        status=status.HTTP_400_BAD_REQUEST)

                    studentmessageInstance = StudentMessagesHistory.objects.create(
                        student=RegistrationInstance,
                        organization=Organization.objects.get(id=organization_id) if organization_id else Response(
                            {'error': "organization_id is required"}, status=status.HTTP_400_BAD_REQUEST),
                        branch=Branch.objects.get(id=branch_id) if branch_id else Response(
                            {'error': "branch_id is required"}, status=status.HTTP_400_BAD_REQUEST),
                        batch=Batch.objects.get(id=batch_id) if batch_id else Response(
                            {'error': "batch_id is required"}, status=status.HTTP_400_BAD_REQUEST),
                        course=Course.objects.get(id=course_id) if course_id else Response(
                            {'error': "course_id is required"}, status=status.HTTP_400_BAD_REQUEST),
                        department=Department.objects.get(id=department_id) if department_id else Response(
                            {'error': "department_id is required"}, status=status.HTTP_400_BAD_REQUEST),
                        academic_year=academicyearInstance,
                        semester=Semester.objects.get(id=semester_id) if semester_id else Response(
                            {'error': "semester_id is required"}, status=status.HTTP_400_BAD_REQUEST),
                        section=Section.objects.get(id=section_id) if section_id else Response(
                            {'error': "section_id is required"}, status=status.HTTP_400_BAD_REQUEST),
                        message_type=messagetypeInstance,
                        message_date=message_date,
                        initiated_by=initiatedInstance,
                        initiated_remarks=initiated_remark,
                        message_status='P',
                        message_sent_to=message_sent_to,
                        count=0,
                        message_time=message_time,
                        message=message,
                        created_by=login_id
                    )
                    place += 1

                return Response({'message': 'message send successfully!!'}, status=status.HTTP_200_OK)


        except ValidationError as e:

            # Rollback the transaction on validation error

            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)


        except DatabaseError as e:

            # Rollback the transaction on database error

            self.log_exception(request, str(e))

            return Response({'error': 'A database error occurred: ' + str(e)},

                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)


        except Exception as e:

            # Rollback the transaction on any other exception

            self.log_exception(request, str(e))

            return Response({'error': 'An unexpected error occurred: ' + str(e)},

                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='studentmessagecreate',

            message=error_message,

        )


class StudentMessageHistoryFilterListAPIView(ListAPIView):
    serializer_class = StudentMessageHistoryFilterSerializer

    def list(self, request, *args, **kwargs):
        try:
            serializer = self.get_serializer(data=request.query_params)
            serializer.is_valid(raise_exception=True)
            # Fetch query parameters
            organization_id = serializer.validated_data.get('organization_id')
            branch_id = serializer.validated_data.get('branch_id')
            batch_id = serializer.validated_data.get('batch_id')
            course_id = serializer.validated_data.get('course_id')
            department_id = serializer.validated_data.get('department_id')
            academic_year_id = serializer.validated_data.get('academic_year_id')
            semester_id = serializer.validated_data.get('semester_id')
            section_id = serializer.validated_data.get('section_id')
            message_type = serializer.validated_data.get('message_type')
            student_id = serializer.validated_data.get('student_id')
            initiated_by = serializer.validated_data.get('initiated_by')
            date_from = serializer.validated_data.get('date_from')
            date_to = serializer.validated_data.get('date_to')

            # filterdata = StudentMessagesHistory.objects.none()

            if organization_id and branch_id:
                try:
                    studentMessageList = StudentMessagesHistory.objects.filter(organization=organization_id,
                                                                               branch=branch_id,
                                                                               is_active=True).order_by('-updated_at')
                except StudentMessagesHistory.DoesNotExist:
                    return Response({"message": "student message record not found !!!"},
                                    status=status.HTTP_404_NOT_FOUND)
            else:
                return Response({"message": "organization_id and branch_id is required !!!"},
                                status=status.HTTP_404_NOT_FOUND)
            #
            # if organization_id and branch_id:
            #     filterdata = StudentMessagesHistory.objects.filter(organization=organization_id, branch=branch_id, is_active=True)
            # else:
            #     return Response({'message': 'organization_id and branch_id is required !!!'}, status=status.HTTP_400_BAD_REQUEST)

            if batch_id:
                studentMessageList = studentMessageList.filter(batch=batch_id)

            if course_id:
                studentMessageList = studentMessageList.filter(course=course_id)

            if department_id:
                studentMessageList = studentMessageList.filter(department=department_id)

            if academic_year_id:
                studentMessageList = studentMessageList.filter(academic_year=academic_year_id)

            if semester_id:
                studentMessageList = studentMessageList.filter(semester=semester_id)

            if section_id:
                studentMessageList = studentMessageList.filter(section=section_id)

            # if

            # if fromdate:
            #     filterdata = filterdata.filter(message_date= fromdate)
            #
            # if fromto:
            #     filterdata = filterdata.filter(message_date=fromto)

            if date_from:
                # Convert fromdate to datetime object
                date_from = datetime.strptime(date_from, "%Y-%m-%d")
                studentMessageList = studentMessageList.filter(message_date__gte=date_from)

                # If fromto is not provided, set it to current date
            if date_to:
                date_to = datetime.strptime(date_to, "%Y-%m-%d")
                studentMessageList = studentMessageList.filter(message_date__lte=date_to)
            else:
                # If fromto is not provided, use the current date as fromto
                date_to = datetime.now()
                studentMessageList = studentMessageList.filter(message_date__lte=date_to)

            if message_type:
                studentMessageList = studentMessageList.filter(message_type=message_type)

            if student_id:
                studentMessageList = studentMessageList.filter(student=student_id)

            if initiated_by:
                studentMessageList = studentMessageList.filter(initiated_by=initiated_by)

            # if course_id:
            #     # Get All StudentCourse Active member
            #     student_course_filter = StudentCourse.objects.filter(academic_year__id=academicyearId)
            #
            #     student_course_filter= student_course_filter.filter(course=course_id)
            #
            #     if section_id:
            #         student_course_filter = student_course_filter.filter(section=section_id)
            #
            #     student_ids_in_class_section = student_course_filter.values_list('student_id', flat=True)
            #
            #     # student_ids_in_class_section = student_course_filter.values_list('id',flat=True)
            #     filterdata = filterdata.filter(student_id__in=student_ids_in_class_section)

            responsedata = []
            if studentMessageList:

                for item in studentMessageList:

                    studentId = item.student.id

                    # Registration Instance
                    try:
                        RegistrationInstance = StudentRegistration.objects.get(id=studentId, is_active=True)
                    except StudentRegistration.DoesNotExist:
                        return Response({"message": "StudentRegistration record not found !!!"},
                                        status=status.HTTP_400_BAD_REQUEST)

                    # student class Instance
                    try:
                        studentCourseInstance = StudentCourse.objects.get(student=studentId,
                                                                          is_active=True)  # ,is_active=True
                        # if not studentcourseInstance:
                        #     return Response({"message": f"StudentCourse record not found student_registration_id-{studentId},student_name-{RegistrationInstance.first_name} !!!"},
                        #                     status=status.HTTP_400_BAD_REQUEST)
                    except Exception as e:
                        return Response({
                                            "error": f"{e}, student_registration_id-{studentId},student_name-{RegistrationInstance.first_name}"},
                                        status=status.HTTP_400_BAD_REQUEST)
                    # except:
                    #     pass

                    # courseInstance = Course.objects.get(id=studentcourseInstance.course.id)

                    # sectionInstance = Section.objects.get(id=studentcourseInstance.section.id)

                    studentmessagehistoryInstance = StudentMessagesHistory.objects.get(id=item.id)

                    messagetypeInstance = MessageType.objects.get(id=studentmessagehistoryInstance.message_type.id)

                    InitiatedByInstance = MessageInitiated.objects.get(id=studentmessagehistoryInstance.initiated_by.id)

                    responsedata.append({
                        'studentId': RegistrationInstance.id,
                        'course_id': studentCourseInstance.course.id,
                        'course_name': studentCourseInstance.course.course_name,
                        'department_id': studentCourseInstance.department.id,
                        'department_description': studentCourseInstance.department.department_description,
                        'academic_year_id': studentCourseInstance.academic_year.id,
                        'academic_year_code': studentCourseInstance.academic_year.academic_year_code,
                        'semester_id': studentCourseInstance.semester.id,
                        'semester_description': studentCourseInstance.semester.semester_description,
                        'section_id': studentCourseInstance.section.id,
                        'section_name': studentCourseInstance.section.section_name,
                        'enrollment_no': studentCourseInstance.enrollment_no,
                        'studentName': f'{RegistrationInstance.first_name}{RegistrationInstance.middle_name}{RegistrationInstance.last_name}',
                        'college_admission_no': RegistrationInstance.college_admission_no,
                        'registration_no': RegistrationInstance.registration_no,
                        'barcode': RegistrationInstance.barcode,
                        'fatherName': RegistrationInstance.father_name,
                        'messageTypeId': messagetypeInstance.id,
                        'messageType': messagetypeInstance.message_type,
                        'InitiatedById': InitiatedByInstance.id,
                        'InitiatedBy': InitiatedByInstance.initiated_by,
                        'message_date': studentmessagehistoryInstance.message_date,
                        'initiated_remarks': studentmessagehistoryInstance.initiated_remarks,
                        'message': studentmessagehistoryInstance.message,
                        'message_status': studentmessagehistoryInstance.message_status
                    })

                return Response({'message': 'success', 'data': responsedata}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!!'}, status=status.HTTP_200_OK)


        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='StudentMessageHistoryFilter',

            message=error_message,

        )


class StudentFeeReceiptCancelCreateAPIView(CreateAPIView):
    queryset = StudentFeeReceiptHeader.objects.all()
    serializer_class = StudentFeeReceiptCancelSerializer

    @transaction.atomic
    def create(self, request, *args, **kwargs):
        try:
            # Start a new atomic transaction
            with transaction.atomic():
                # Validate and save data
                serializer = self.get_serializer(data=request.data)
                serializer.is_valid(raise_exception=True)

                organization_id = serializer.validated_data.get('organization_id')
                branch_id = serializer.validated_data.get('branch_id')
                receipt_id = serializer.validated_data.get('receipt_id')
                cancel_remark = serializer.validated_data.get('cancel_remark')

                # Process the StdFeeReceiptHeader and cancel the status
                StudentFeeReceiptHeaderInstance = StudentFeeReceiptHeader.objects.get(organization=organization_id,
                                                                                      branch=branch_id, id=receipt_id)
                StudentFeeReceiptHeaderInstance.receipt_status = 'CANCEL'
                StudentFeeReceiptHeaderInstance.cancellation_remarks = cancel_remark
                StudentFeeReceiptHeaderInstance.save()

                # Process the StdPayment and make is_active=False
                StudentPaymentInstance = StudentPayment.objects.get(receipt_id=receipt_id)

                StudentPaymentInstance.is_active = False
                StudentPaymentInstance.save()

                # Filter data based on receipt  Into StdFeeReceiptDetail Instance

                StudentFeeReceiptDetail_records = StudentFeeReceiptDetail.objects.filter(receipt_id=receipt_id)

                for record in StudentFeeReceiptDetail_records:
                    # std fee receipts Instance
                    StudentFeeReceiptDetailInstance = StudentFeeReceiptDetail.objects.get(id=record.id)

                    # student fee details instance
                    studentfeedetailsInstance = StudentFeeDetail.objects.get(id=record.fee_detail.id)

                    studentfeedetailsInstance.paid_amount = studentfeedetailsInstance.paid_amount - StudentFeeReceiptDetailInstance.amount
                    studentfeedetailsInstance.paid = 'N'

                    if studentfeedetailsInstance.element_name in (
                            'DISCOUNT', 'LATE FEES', 'CHECK BOUNCE', 'RE ADMISSION'):
                        studentfeedetailsInstance.is_active = False

                    studentfeedetailsInstance.save()

                return Response({'message': 'Fees Cancel sucessfully!!'}, status=status.HTTP_200_OK)


        except ValidationError as e:

            # Rollback the transaction on validation error

            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)


        except DatabaseError as e:

            # Rollback the transaction on database error

            self.log_exception(request, str(e))

            return Response({'error': 'A database error occurred: ' + str(e)},

                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)


        except Exception as e:

            # Rollback the transaction on any other exception

            self.log_exception(request, str(e))

            return Response({'error': 'An unexpected error occurred: ' + str(e)},

                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='feereceiptscancel',

            message=error_message,

        )


class GetListOfProfessorListAPIView(ListAPIView):
    # queryset =EmployeeMaster.objects.all()
    serializer_class = EmployeeMasterSerializer

    def list(self, request, *args, **kwargs):
        try:
            academicyearId = self.kwargs.get('academic_year_id')
            date = self.kwargs.get('date')

            # Parse the date string into a datetime object
            parsed_date = datetime.strptime(date, '%Y-%m-%d')
            day_of_week = parsed_date.strftime('%A').upper()  # Get the day of the week

            TimeTablerecords = TimeTable.objects.filter(academic_year_id=academicyearId, schedule_day=day_of_week,
                                                        is_active=True)

            teacher_list = []
            for record in TimeTablerecords:
                if record.professor.id not in teacher_list:
                    teacher_list.append(record.professor.id)
            # print(teacher_list)

            responsedata = []
            for item in teacher_list:
                try:
                    EmployeeMasterInstance = EmployeeMaster.objects.get(id=item, is_active=True)
                    name_part = filter(None, [
                        EmployeeMasterInstance.title,
                        EmployeeMasterInstance.first_name,
                        EmployeeMasterInstance.middle_name,
                        EmployeeMasterInstance.last_name

                    ])
                    data = {
                        'teacherId': EmployeeMasterInstance.id,
                        'TeacherName': ' '.join(name_part)
                    }
                    responsedata.append(data)

                except EmployeeMaster.DoesNotExist:
                    continue
            if responsedata:

                return Response({'message': 'success!!', 'data': responsedata}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No record found'}, status=status.HTTP_200_OK)


        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='Teacher_list_byDay',

            message=error_message,

        )


class GetListOfCourseBasedOnProfessorOndate(ListAPIView):
    serializer_class = EmployeeMasterSerializer

    def list(self, request, *args, **kwargs):
        try:
            academicyearId = self.kwargs.get('academic_year_id')
            date = self.kwargs.get('date')
            professorId = self.kwargs.get('professorId')

            # Parse the date string into a datetime object
            parsed_date = datetime.strptime(date, '%Y-%m-%d')
            day_of_week = parsed_date.strftime('%A').upper()  # Get the day of the week

            TimeTablerecords = TimeTable.objects.filter(academic_year_id=academicyearId, schedule_day=day_of_week,
                                                        professor=professorId, is_active=True)

            class_list = []
            for record in TimeTablerecords:
                if record.course.id not in class_list:
                    class_list.append(record.course.id)
            # print(teacher_list)

            responsedata = []
            for item in class_list:
                try:
                    CourseInstance = Course.objects.get(id=item, is_active=True)

                    data = {
                        'course_id': CourseInstance.id,
                        'course_name': CourseInstance.course_name
                    }
                    responsedata.append(data)

                except EmployeeMaster.DoesNotExist:
                    continue
            if responsedata:

                return Response({'message': 'success!!', 'data': responsedata}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No record found'}, status=status.HTTP_200_OK)





        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='classListByTeacher',

            message=error_message,

        )


class GetListOfSubjectBasedOnProfessorOndate(ListAPIView):
    serializer_class = EmployeeMasterSerializer

    def list(self, request, *args, **kwargs):
        try:
            academicyearId = self.kwargs.get('academic_year_id')
            date = self.kwargs.get('date')
            professorId = self.kwargs.get('professorId')
            course_id = self.kwargs.get('course_id')
            section_id = self.kwargs.get('section_id')

            # Parse the date string into a datetime object
            parsed_date = datetime.strptime(date, '%Y-%m-%d')
            day_of_week = parsed_date.strftime('%A').upper()  # Get the day of the week

            TimeTablerecords = TimeTable.objects.filter(academic_year_id=academicyearId, schedule_day=day_of_week,
                                                        professor=professorId, course_id=course_id,
                                                        section_id=section_id, is_active=True)

            subject_list = []
            for record in TimeTablerecords:
                if record.subject.id not in subject_list:
                    subject_list.append(record.subject.id)
            # print(teacher_list)

            responsedata = []
            for item in subject_list:
                try:
                    CourseDepartmentSubjectInstance = CourseDepartmentSubject.objects.get(id=item, is_active=True)

                    data = {
                        'subject_id': CourseDepartmentSubjectInstance.id,
                        'subject_name': CourseDepartmentSubjectInstance.subject_code
                    }
                    responsedata.append(data)

                except EmployeeMaster.DoesNotExist:
                    continue
            if responsedata:

                return Response({'message': 'success!!', 'data': responsedata}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No record found'}, status=status.HTTP_200_OK)

        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='subjectListByTeacher',

            message=error_message,

        )


class GetListOfCourseLectureBasedOnProfessorOndate(ListAPIView):
    serializer_class = EmployeeMasterSerializer

    def list(self, request, *args, **kwargs):
        try:
            # organi
            academicyearId = self.kwargs.get('academic_year_id')
            date = self.kwargs.get('date')
            professor_id = self.kwargs.get('professor_id')
            course_id = self.kwargs.get('course_id')
            section_id = self.kwargs.get('section_id')
            subjectId = self.kwargs.get('subjectId')

            # Parse the date string into a datetime object
            parsed_date = datetime.strptime(date, '%Y-%m-%d')
            day_of_week = parsed_date.strftime('%A').upper()  # Get the day of the week

            TimeTablerecords = TimeTable.objects.filter(academic_year_id=academicyearId, schedule_day=day_of_week,
                                                        professor=professor_id, course_id=course_id,
                                                        section_id=section_id, subject_id=subjectId, is_active=True)

            course_lecture_list = []
            for record in TimeTablerecords:
                if record.lecture.id not in course_lecture_list:
                    course_lecture_list.append(record.lecture.id)
            # print(teacher_list)

            responsedata = []
            for item in course_lecture_list:
                try:
                    LectureInstance = Lecture.objects.get(id=item, is_active=True)

                    data = {
                        'lecture_id': LectureInstance.id,
                        'lecture_name': LectureInstance.lecture_name
                    }
                    responsedata.append(data)

                except EmployeeMaster.DoesNotExist:
                    continue
            if responsedata:

                return Response({'message': 'success!!', 'data': responsedata}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No record found'}, status=status.HTTP_200_OK)

        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='periodListByTeacher',

            message=error_message,

        )


class GetProfessorBasedOnSubject(ListAPIView):
    serializer_class = EmployeeMasterSerializer

    def list(self, request, *args, **kwargs):
        try:
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            batch_id = request.query_params.get('batch_id')
            course_id = request.query_params.get('course_id')
            department_id = request.query_params.get('department_id')
            academic_year_id = request.query_params.get('academic_year_id')
            semester_id = request.query_params.get('semester_id')
            section_id = request.query_params.get('section_id')
            lecture_id = request.query_params.get('lecture_id')
            date = request.query_params.get('date')
            # professor_id = request.query_params.get('professor_id')
            subject_id = request.query_params.get('subject_id')

            if date:
                try:
                    date_obj = datetime.strptime(date, '%Y-%m-%d')
                    day_of_week = date_obj.strftime('%A')  # Converts to full weekday name, e.g., "Monday"
                except ValueError:
                    return Response({"error": "Invalid date format. Use 'YYYY-MM-DD'."},
                                    status=status.HTTP_400_BAD_REQUEST)

            TimeTablerecords = TimeTable.objects.filter(organization=organization_id, branch=branch_id, batch=batch_id,
                                                        course=course_id, department=department_id,
                                                        academic_year=academic_year_id, semester=semester_id,
                                                        section=section_id, subject_id=subject_id, lecture_period=lecture_id,
                                                        schedule_day=day_of_week.lower(), is_active=True)

            # course_lecture_list=[]
            # for record in TimeTablerecords:
            #     if record.lecture.id not in course_lecture_list:
            #         course_lecture_list.append(record.lecture.id)
            # print(teacher_list)

            responsedata = []
            for item in TimeTablerecords:
                try:
                    professor_instance = EmployeeMaster.objects.get(id=item.professor.id, is_active=True)

                    name_part = filter(None, [
                        professor_instance.title,
                        professor_instance.first_name,
                        professor_instance.middle_name,
                        professor_instance.last_name

                    ])
                    professor_name = " ".join(name_part)

                    data = {
                        'professor_id': professor_instance.id,
                        'professor_name': professor_name
                    }
                    responsedata.append(data)

                except EmployeeMaster.DoesNotExist:
                    continue
            if responsedata:

                return Response({'message': 'success!!', 'data': responsedata}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No record found'}, status=status.HTTP_200_OK)

        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='periodListByTeacher',

            message=error_message,

        )


# class GetListOfAssignmentListAPIView(ListAPIView):
#     queryset = StudentAssignment.objects.all()
#     serializer_class = StudentAssignmentSerializer
#
#     def list(self, request, *args, **kwargs):
#         try:
#             organization = self.kwargs.get('organization')
#             branchId = self.kwargs.get('branchId')
#             academicyearId = self.kwargs.get('academic_year_id')
#
#             resdata = StudentAssignment.objects.filter(organization=organization, branch_id=branchId, academic_year_id=academicyearId)
#
#             if resdata:
#                 responsedata = []
#                 for item in resdata:
#                     if item.is_active:
#
#                         academicyearInstance = AcademicYear.objects.get(id=item.academic_year_id.id)
#                         organizationInstance = Organization.objects.get(id=item.organization.id)
#                         branchInstance = Branches.objects.get(id=item.branch_id.id)
#                         courseInstance = Course.objects.get(id=item.class_id.id)
#                         sectionInstance = Section.objects.get(id=item.section_id.id)
#                         lectureInstance = Course_Period.objects.get(id=item.class_period_id.id)
#                         subjectInstance = SubjectMaster.objects.get(id=item.subject_id.id)
#                         EmployeeMasterInstance = EmployeeMaster.objects.get(id=item.teacher_id.id)
#
#                         name_part = filter(None, [
#                             EmployeeMasterInstance.title,
#                             EmployeeMasterInstance.first_name,
#                             EmployeeMasterInstance.middle_name,
#                             EmployeeMasterInstance.last_name
#                         ])
#                         teacher_name = " ".join(name_part)
#
#                         # Construct full URL for the assignment file
#                         assignment_file_url = None
#                         if item.assignment_file:
#                             assignment_file_url = urljoin(settings.MEDIA_URL, item.assignment_file)
#
#                         # Read file as binary if the assignment_file string path exists
#                         assignment_file_binary = None
#                         if item.assignment_file:
#                             file_path = os.path.join(settings.MEDIA_ROOT, item.assignment_file)  # Combine base and relative path
#                             if os.path.exists(file_path):
#                                 with open(file_path, 'rb') as f:
#                                     assignment_file_binary = f.read()
#                             else:
#                                 assignment_file_binary = None
#
#                         # Prepare the custom response data
#                         responsedata.append({
#                             'id': item.id,
#                             'academicyearId': academicyearInstance.id,
#                             'academicyearName': academicyearInstance.sesion_code,
#                             'organization': organizationInstance.id,
#                             'organization_code': organizationInstance.organization_code,
#                             'branchId': branchInstance.id,
#                             'branchname': branchInstance.branch_name,
#                             'course_id': courseInstance.id,
#                             'classname': courseInstance.classname,
#                             'section_id': sectionInstance.id,
#                             'sectionname': sectionInstance.sectionname,
#                             'lecture_id': lectureInstance.id,
#                             'classperiodName': lectureInstance.period_name,
#                             'subjectId': subjectInstance.id,
#                             'subjectName': subjectInstance.subject_code,
#                             'teacherId': EmployeeMasterInstance.id,
#                             'teacherName': teacher_name,
#                             'assignment_date': item.assignment_date,
#                             'assignment_file': assignment_file_url,
#                             'assignment_file_binary_data': assignment_file_binary,  # Binary data here
#                             'assignment_details': item.assignment_details,
#                             'send_sms': item.send_sms,
#                             'sms_sent_to': item.sms_sent_to
#                         })
#
#                     else:
#                         continue
#
#                 if responsedata:
#                     return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
#                 else:
#                     return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
#
#             else:
#                 return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)
#
#         except Exception as e:
#             # Log the exception
#             error_message = str(e)
#             self.log_exception(request, error_message)
#             return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#     def log_exception(self, request, error_message):
#         ExceptionTrack.objects.create(
#             request=str(request),
#             process_name='Assignmentlist',
#             message=error_message,
#         )

class GetListOfAssignmentListAPIView(ListAPIView):
    queryset = StudentAssignment.objects.all()
    serializer_class = StudentAssignmentSearchSerializer

    def list(self, request, *args, **kwargs):
        try:
            serializers = self.get_serializer(data=request.query_params)
            serializers.is_valid(raise_exception=True)

            organization_id = serializers.validated_data.get('organization_id')
            branch_id = serializers.validated_data.get('branch_id')
            batch_id = serializers.validated_data.get('batch_id')
            course_id = serializers.validated_data.get('course_id')
            department_id = serializers.validated_data.get('department_id')
            academic_year_id = serializers.validated_data.get('academic_year_id')
            semester_id = serializers.validated_data.get('semester_id')
            section_id = serializers.validated_data.get('section_id')
            lecture_period_id = serializers.validated_data.get('lecture_id')
            subject_id = serializers.validated_data.get('subject_id')
            professor_id = serializers.validated_data.get('professor_id')
            assignment_date = serializers.validated_data.get('assignment_date')

            if organization_id and branch_id:
                try:
                    studentAssignmentList = StudentAssignment.objects.filter(organization=organization_id,
                                                                             branch=branch_id,
                                                                             is_active=True).order_by('-updated_at')
                except StudentAssignment.DoesNotExist:
                    return Response({"message": "student assignment record not found !!!"},
                                    status=status.HTTP_404_NOT_FOUND)
            else:
                return Response({"message": "organization_id and branch_id is required !!!"},
                                status=status.HTTP_404_NOT_FOUND)

            if batch_id:
                studentAssignmentList = studentAssignmentList.filter(batch=batch_id)

            if course_id:
                studentAssignmentList = studentAssignmentList.filter(course=course_id)

            if department_id:
                studentAssignmentList = studentAssignmentList.filter(department=department_id)

            if academic_year_id:
                studentAssignmentList = studentAssignmentList.filter(academic_year=academic_year_id)

            if semester_id:
                studentAssignmentList = studentAssignmentList.filter(semester=semester_id)

            if section_id:
                studentAssignmentList = studentAssignmentList.filter(section=section_id)

            if lecture_period_id:
                studentAssignmentList = studentAssignmentList.filter(lecture_period=lecture_period_id)

            if subject_id:
                studentAssignmentList = studentAssignmentList.filter(subject=subject_id)

            if professor_id:
                studentAssignmentList = studentAssignmentList.filter(professor=professor_id)

            if assignment_date:
                studentAssignmentList = studentAssignmentList.filter(assignment_date=assignment_date)

            # organization_id = request.query_params.get('organization_id')
            #     branch_id = request.query_params.get('branch_id')
            #     batch_id=request.query_params.get('batch_id')
            #     course_id = request.query_params.get('course_id')
            #     department_id = request.query_params.get('department_id')
            #     academic_year_id = request.query_params.get('academic_year_id')
            #     semester_id = request.query_params.get('semester_id')
            #     section_id = request.query_params.get('section_id')
            #     assignment_date = request.query_params.get('assignment_date')
            #     professor_id = request.query_params.get('professor_id')
            #     subject_id = request.query_params.get('subject_id')
            #     lecture_id = request.query_params.get('lecture_id')
            #     assignment_detail = request.query_params.get('assignment_detail')
            #
            #     if organization_id and branch_id:
            #         filterdata= StudentAssignment.objects.filter(organization=organization_id,branch=branch_id)
            #     else:
            #         return Response({'message': 'Please provide mandatory data (organization_id and branch_id )!'}, status=status.HTTP_400_BAD_REQUEST)
            #
            #     if filterdata:
            #         if batch_id :
            #             filterdata = filterdata.filter(batch=batch_id)
            #
            #         if course_id:
            #             filterdata = filterdata.filter(course=course_id)
            #
            #         if department_id:
            #             filterdata = filterdata.filter(department=department_id)
            #
            #         if academic_year_id:
            #             filterdata = filterdata.filter(academic_year=academic_year_id)
            #
            #         if semester_id:
            #             filterdata = filterdata.filter(semester=semester_id)
            #
            #         if section_id:
            #             filterdata = filterdata.filter(section=section_id)
            #
            #         if assignment_date:
            #             filterdata = filterdata.filter(assignment_date=assignment_date)
            #
            #         if professor_id:
            #             filterdata = filterdata.filter(professor=professor_id)
            #
            #
            #         if subject_id:
            #             filterdata = filterdata.filter(subject=subject_id)
            #
            #         if lecture_id:
            #             filterdata = filterdata.filter(lecture=lecture_id)
            #
            #         if assignment_detail:
            #             filterdata = filterdata.filter(assignment_details=assignment_detail)
            #     else:
            #         return Response({'message': 'No record found!'},
            #                         status=status.HTTP_204_NO_CONTENT)

            if studentAssignmentList:
                responsedata = []
                for item in studentAssignmentList:
                    # if item.get('is_active') == True:
                    # if item.is_active == True:

                    # organizationInstance = Organization.objects.get(id=item.organization.id)
                    # branchInstance = Branch.objects.get(id=item.branch.id)
                    # batchInstance = Batch.objects.get(id=item.batch.id)
                    # courseInstance = Course.objects.get(id=item.course.id)
                    # departmentInstance = Department.objects.get(id=item.department.id)
                    # academicyearInstance = AcademicYear.objects.get(id=item.academic_year.id)
                    # semesterInstance = Semester.objects.get(id=item.semester.id)
                    # sectionInstance = Section.objects.get(id=item.section.id)
                    # lectureInstance = Lecture.objects.get(id=item.lecture.id)
                    #
                    # subjectInstance = CourseDepartmentSubject.objects.get(id=item.subject.id)
                    # EmployeeMasterInstance = EmployeeMaster.objects.get(id=item.professor.id)

                    name_part = filter(None, [
                        item.professor.title,
                        item.professor.first_name,
                        item.professor.middle_name,
                        item.professor.last_name

                    ])
                    professor_name = " ".join(name_part)

                    # Construct full URL for the assignment file
                    # assignment_file_url = None
                    # assignment_file_binary = None
                    #
                    # if item.assignment_file:
                    #     assignment_file_url = urljoin(settings.MEDIA_URL, item.assignment_file)
                    #
                    #     # Read file as binary if the assignment_file string path exists
                    #     file_path = os.path.join(settings.MEDIA_ROOT, item.assignment_file)
                    #
                    #     file_type, _ = mimetypes.guess_type(file_path)
                    #    # print(file_path,type(file_path))
                    #     if os.path.exists(file_path):
                    #         with open(file_path, 'rb') as f:
                    #             # print(file_path)
                    #             # print(datetime.now())
                    #             binary_data = f.read()
                    #             # print(datetime.now())
                    #
                    #             assignment_file_binary =base64.b64encode(binary_data).decode('utf-8')
                    #
                    #     else:
                    #         assignment_file_binary = None

                    # Prepare the custom response data
                    # responsedata.append({
                    #     'id': item.id,
                    #     'organization': organizationInstance.id,
                    #     'organization_code': organizationInstance.organization_code,
                    #     'branch_id': branchInstance.id,
                    #     'branch_name': branchInstance.branch_name,
                    #     'batch_id': batchInstance.id,
                    #     'batch_code': batchInstance.batch_code,
                    #     'course_id': courseInstance.id,
                    #     'course_name': courseInstance.course_name,
                    #     'department_id':departmentInstance.id,
                    #     'department_code':departmentInstance.department_code,
                    #     'academic_year_id': academicyearInstance.id,
                    #     'academic_year_': academicyearInstance.academic_year_code,
                    #     'semester_id': semesterInstance.id,
                    #     'semester_code': semesterInstance.semester_code,
                    #     'section_id': sectionInstance.id,
                    #     'section_name': sectionInstance.section_name,
                    #     'lecture_id': lectureInstance.id,
                    #     'lecture_name': lectureInstance.lecture_name,
                    #     'subjectId': subjectInstance.id,
                    #     'subjectName': subjectInstance.subject_code,
                    #     'professor_id': EmployeeMasterInstance.id,
                    #     'professor_name': professor_name,
                    #     'assignment_date':item.assignment_date,
                    #     'assignment_file': item.assignment_file_url,    #item.assignment_file,  #.url if item.assignment_file else None,
                    #     # 'assignment_file_binary_data':assignment_file_binary,
                    #     # 'file_type':file_type,
                    #     'assignment_details':item.assignment_details,
                    #     'send_sms':item.send_sms,
                    #     'sms_sent_to': item.sms_sent_to
                    # })
                    responsedata.append({
                        'id': item.id,
                        'organization': item.organization.id,
                        'organization_code': item.organization.organization_code,
                        'branch_id': item.branch.id,
                        'branch_name': item.branch.branch_name,
                        'batch_id': item.batch.id,
                        'batch_code': item.batch.batch_code,
                        'course_id': item.course.id,
                        'course_name': item.course.course_name,
                        'department_id': item.department.id,
                        'department_code': item.department.department_code,
                        'academic_year_id': item.academic_year.id,
                        'academic_year_': item.academic_year.academic_year_code,
                        'semester_id': item.semester.id,
                        'semester_code': item.semester.semester_code,
                        'section_id': item.section.id,
                        'section_name': item.section.section_name,
                        'lecture_id': item.lecture_period.id,
                        'lecture_name': item.lecture_period.lecture_period_name,
                        'subjectId': item.subject.id,
                        'subjectName': item.subject.subject_code,
                        'professor_id': item.professor.id,
                        'professor_name': professor_name,
                        'assignment_date': item.assignment_date,
                        'assignment_file': item.assignment_file_url,
                        # item.assignment_file,  #.url if item.assignment_file else None,
                        # 'assignment_file_binary_data':assignment_file_binary,
                        # 'file_type':file_type,
                        'assignment_details': item.assignment_details,
                        'send_sms': item.send_sms,
                        'sms_sent_to': item.sms_sent_to
                    })
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='Assignmentlist',
            message=error_message,
        )


class AssignmentCreateAPIView(CreateAPIView):
    queryset = StudentAssignment.objects.all()
    serializer_class = StudentAssignmentSerializer
    parser_classes = [MultiPartParser, FormParser]

    @transaction.atomic
    def create(self, request, *args, **kwargs):
        try:
            # Start a new atomic transaction
            with transaction.atomic():
                # Validate and save data
                serializer = self.get_serializer(data=request.data)
                serializer.is_valid(raise_exception=True)

                # {academic_year_id,organization_id,branch_id,batch_id,course_id,department_id,academic_year_id,semester_id,section_id,
                # subject_id,assignment_date,assignment_file,assignment_details,lecture_id,professor_id,send_sms,sms_sent_to,created_by}

                organization_id = serializer.validated_data.get('organization_id')
                branch_id = serializer.validated_data.get('branch_id')
                batch_id = serializer.validated_data.get('batch_id')
                course_id = serializer.validated_data.get('course_id')
                department_id = serializer.validated_data.get('department_id')
                academic_year_id = serializer.validated_data.get('academic_year_id')
                semester_id = serializer.validated_data.get('semester_id')
                section_id = serializer.validated_data.get('section_id')
                subject_id = serializer.validated_data.get('subject_id')
                assignment_date = serializer.validated_data.get('assignment_date')
                # assignment_file_data = request.FILES.get('assignment_file')
                assignment_file_data = serializer.validated_data.get('assignment_file')
                assignment_details = serializer.validated_data.get('assignment_details')

                lecture_period_id = serializer.validated_data.get('lecture_id')
                professor_id = serializer.validated_data.get('professor_id')
                send_sms = serializer.validated_data.get('send_sms')
                sms_sent_to = serializer.validated_data.get('sms_sent_to')
                created_by = serializer.validated_data.get('created_by')

                # if 'assignment_file' in request.FILES:
                #     assignment_file_data = request.FILES['assignment_file']
                #
                # assignment_doc_instance = StudentAssignment.objects.create(
                #     assignment_file = StudentAssignment['assignment_file']
                # )
                #
                # if assignment_file_data:
                #     assignment_file.save(assignment_file.name, assignment_file)

                # print(assignment_file_data,type(assignment_file_data))
                # Generate a Unique UUID string for upload file & image uniqueness

                # Generate a unique 8-character string using UUID
                # unique_string = str(uuid.uuid4())[:8]

                # Generate a dynamic folder and file path
                # folder_name = "assignment"
                # timestamp = now().strftime("%Y%m%d_%H%M%S")

                # assignment_file_instance = StudentAssignment.objects.create(
                #
                # )
                # try:
                #     file_name = f"{os.path.splitext(assignment_file_data.name)[0]}_{unique_string}{os.path.splitext(assignment_file_data.name)[1]}"
                #     file_path = os.path.join(folder_name, file_name)  # This is the relative file path
                #
                #     # Get the full path relative to the media directory
                #
                #     full_file_path = os.path.join(settings.MEDIA_ROOT, file_path)  # Full path including MEDIA_ROOT
                #
                #     # print(full_file_path)
                #     # Ensure the directory exists
                #     if not os.path.exists(os.path.dirname(full_file_path)):
                #         os.makedirs(os.path.dirname(full_file_path))
                #
                #     # Save the file
                #     with default_storage.open(full_file_path, 'wb+') as destination:
                #         for chunk in assignment_file_data.chunks():
                #             destination.write(chunk)
                # except:
                #     full_file_path = ""

                # Check if an assignment already exists
                existing_assignment = StudentAssignment.objects.filter(
                    organization=organization_id,
                    branch=branch_id,
                    batch=batch_id,
                    course=course_id,
                    department=department_id,
                    academic_year=academic_year_id,
                    semester=semester_id,
                    section=section_id,
                    subject=subject_id,
                    assignment_date=assignment_date,
                    lecture_period=lecture_period_id,
                    professor=professor_id,
                    is_active=True  # Optional: Check if the assignment is active
                ).first()

                # if existing_assignment:
                #     return Response(
                #         {'message': 'Assignment already exists for the specified criteria!'},
                #         status=status.HTTP_400_BAD_REQUEST
                #     )

                # Process save message based on student

                organizationInstance = Organization.objects.get(id=organization_id)
                branchInstance = Branch.objects.get(id=branch_id)
                batchInstance = Batch.objects.get(id=batch_id)
                courseInstance = Course.objects.get(id=course_id)
                departmentInstance = Department.objects.get(id=department_id)
                academicyearInstance = AcademicYear.objects.get(id=academic_year_id)
                semesterInstance = Semester.objects.get(id=semester_id)
                sectionInstance = Section.objects.get(id=section_id)
                lecturePeriodInstance = LecturePeriod.objects.get(id=lecture_period_id)

                subjectInstance = CourseDepartmentSubject.objects.get(id=subject_id)
                EmployeeMasterInstance = EmployeeMaster.objects.get(id=professor_id)

                studentmessageInstance = StudentAssignment.objects.create(
                    organization=organizationInstance,
                    branch=branchInstance,
                    batch=batchInstance,
                    course=courseInstance,
                    department=departmentInstance,
                    academic_year=academicyearInstance,
                    semester_id=semester_id,
                    section=sectionInstance,
                    subject=subjectInstance,
                    assignment_date=assignment_date,
                    assignment_file=assignment_file_data,
                    assignment_file_url="",
                    assignment_details=assignment_details,

                    lecture_period=lecturePeriodInstance,
                    professor=EmployeeMasterInstance,
                    send_sms=send_sms,
                    sms_sent_to=sms_sent_to,
                    created_by=created_by,
                    updated_by=created_by

                )

                response_data = serializer.data

                if studentmessageInstance.assignment_file:
                    studentmessageInstance.assignment_file_url = request.build_absolute_uri(
                        studentmessageInstance.assignment_file.url)
                    studentmessageInstance.save()
                else:
                    studentmessageInstance.assignment_file_url = ""  # or handle accordingly

                return Response({'message': 'Assignment Added sucessfully!!'}, status=status.HTTP_200_OK)


        except ValidationError as e:

            # Rollback the transaction on validation error

            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)


        except DatabaseError as e:

            # Rollback the transaction on database error

            self.log_exception(request, str(e))

            return Response({'error': 'A database error occurred: ' + str(e)},

                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)


        except Exception as e:

            # Rollback the transaction on any other exception

            self.log_exception(request, str(e))

            return Response({'error': 'An unexpected error occurred: ' + str(e)},

                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='assignmentcreate',

            message=error_message,

        )


class AssignmentUpdateAPIView(UpdateAPIView):
    queryset = StudentAssignment.objects.all()
    serializer_class = StudentAssignmentUpdateSerializer

    def update(self, request, *args, **kwargs):
        try:
            # partial = kwargs.pop('partial', False)
            # instance = self.get_object()
            assignment_id = request.query_params.get('assignment_id')
            instance = StudentAssignment.objects.get(id=assignment_id, is_active=True)

            # Validate input data
            serializer = self.get_serializer(instance, data=request.data)
            serializer.is_valid(raise_exception=True)

            # Get validate Data
            organization = serializer.validated_data.get('organization')
            branch = serializer.validated_data.get('branch')
            batch = serializer.validated_data.get('batch')
            course = serializer.validated_data.get('course')
            department = serializer.validated_data.get('department')
            academic_year = serializer.validated_data.get('academic_year')
            semester = serializer.validated_data.get('semester')
            section = serializer.validated_data.get('section')
            subject = serializer.validated_data.get('subject')
            assignment_date = serializer.validated_data.get('assignment_date')
            assignment_file = serializer.validated_data.get('assignment_file')
            assignment_details = serializer.validated_data.get('assignment_details')

            lecture_period = serializer.validated_data.get('lecture_period')
            professor = serializer.validated_data.get('professor')
            send_sms = serializer.validated_data.get('send_sms')
            sms_sent_to = serializer.validated_data.get('sms_sent_to')
            updated_by = serializer.validated_data.get('updated_by')

            #
            # Check if a similar record already exists
            if not StudentAssignment.objects.exclude(pk=instance.pk).filter(
                    # if StudentAssignment.objects.filter(
                    organization=organization,
                    branch=branch,
                    batch=batch,
                    course=course,
                    department=department,
                    academic_year=academic_year,
                    semester=semester,
                    section=section,
                    subject=subject,
                    assignment_date=assignment_date,

                    lecture_period=lecture_period,
                    professor=professor,
                    send_sms=send_sms,
                    assignment_details=assignment_details,
                    is_active=True
            ).exists():

                # Update instance with new data
                instance.organization = Organization.objects.get(id=organization.id) if organization else Response(
                    {'message': 'organization_id is required!!!'}, status=status.HTTP_400_BAD_REQUEST)
                instance.branch = Branch.objects.get(id=branch.id) if branch else Response(
                    {'message': 'branch_id is required!!!'}, status=status.HTTP_400_BAD_REQUEST)
                instance.batch = Batch.objects.get(id=batch.id) if batch else Response(
                    {'message': 'batch_id is required!!!'}, status=status.HTTP_400_BAD_REQUEST)
                instance.course = Course.objects.get(id=course.id) if course else Response(
                    {'message': 'course_id is required!!!'}, status=status.HTTP_400_BAD_REQUEST)
                instance.department = Department.objects.get(id=department.id) if department else Response(
                    {'message': 'department_id is required!!!'}, status=status.HTTP_400_BAD_REQUEST)
                instance.academic_year = AcademicYear.objects.get(id=academic_year.id) if academic_year else Response(
                    {'message': 'academic_year_id is required!!!'}, status=status.HTTP_400_BAD_REQUEST)
                instance.semester = Semester.objects.get(id=semester.id) if semester else Response(
                    {'message': 'semester_id is required!!!'}, status=status.HTTP_400_BAD_REQUEST)
                instance.section = Section.objects.get(id=section.id) if section else Response(
                    {'message': 'section_id is required!!!'}, status=status.HTTP_400_BAD_REQUEST)
                instance.subject = CourseDepartmentSubject.objects.get(id=subject.id) if subject else Response(
                    {'message': 'subject_id is required!!!'}, status=status.HTTP_400_BAD_REQUEST)
                instance.assignment_date = assignment_date
                instance.assignment_file = assignment_file
                instance.assignment_file_url = ""
                instance.assignment_details = assignment_details

                instance.lecture_period = LecturePeriod.objects.get(id=lecture_period.id) if lecture_period else Response(
                    {'message': 'lecture_period is required!!!'}, status=status.HTTP_400_BAD_REQUEST)
                instance.professor = EmployeeMaster.objects.get(id=professor.id) if professor else Response(
                    {'message': 'professor_id is required!!!'}, status=status.HTTP_400_BAD_REQUEST)
                instance.send_sms = send_sms
                instance.sms_sent_to = sms_sent_to
                instance.updated_by = updated_by
                instance.is_active = True

                instance.assignment_file_url = request.build_absolute_uri(
                    instance.assignment_file.url) if instance.assignment_file else ''

                instance.save()

            else:
                return Response({'message': 'Assignment not found!!!'}, status=status.HTTP_400_BAD_REQUEST)

            return Response({'message': 'Assignment updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='AssignmentUpdate',
            message=error_message,
        )


class AssignmentDeleteAPIView(DestroyAPIView):
    queryset = StudentAssignment.objects.all()
    serializer_class = StudentAssignmentSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            assignment_id = request.query_params.get('assignment_id')
            instance = StudentAssignment.objects.get(id=assignment_id)
            if instance.is_active:
                instance.is_active = False
                instance.save()

                return Response({'message': 'Assignment Deleted Successfully'}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'record already Deactivated.'}, status=status.HTTP_400_BAD_REQUEST)

        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)


class StudentCircularCreateAPIView(CreateAPIView):
    queryset = StudentCircular.objects.all()
    serializer_class = StudentCircularSerializer

    @transaction.atomic
    def create(self, request, *args, **kwargs):
        try:
            # Start a new atomic transaction
            with transaction.atomic():
                if request.content_type.startswith('multipart/form-data'):
                    data = request.POST.dict()  # Convert QueryDict to a mutable dictionary
                    data['organization_id'] = data['organization_id']
                    data['branch_id'] = data['branch_id']
                    if data.get('batch_ids'):
                        try:
                            data['batch_ids'] = json.loads(data.get('batch_ids'))
                        except:
                            pass
                    data['batch_id'] = data.get('batch_id')
                    data['course_ids'] = json.loads(data.get('course_ids'))  # Convert string to list
                    data['department_ids'] = json.loads(data.get('department_ids'))
                    data['academic_year_ids'] = json.loads(data.get('academic_year_ids'))
                    data['semester_ids'] = json.loads(data.get('semester_ids'))
                    data['section_ids'] = json.loads(data.get('section_ids'))  # Convert string to list
                    data['circular_date'] = data['circular_date']
                    data['circular_detail'] = data['circular_detail']
                    data['initiated_by'] = data['initiated_by']

                    # data['branchId'] =  data['branchId']
                    data['circular_status'] = data['circular_status']
                    data['send_sms'] = data['send_sms']
                    data['message_status'] = data['message_status']
                    data['circular_sent_to'] = data['circular_sent_to']
                    data['circular_time'] = data['circular_time']
                    data['created_by'] = data['created_by']
                    data['circular_file'] = request.FILES['circular_file']
                # {academic_year_id,course_id,section_id,circularDate,circularDetails,initiatedBy,organization,circularStatus,send_sms,message_status,circular_sent_to,circular_time,created_by,circularFile}

                # Convert string to list

                # Validate and save data
                serializer = self.get_serializer(data=data)
                serializer.is_valid(raise_exception=True)

                organization_id = serializer.validated_data.get('organization_id')
                branch_id = serializer.validated_data.get('branch_id')
                batch_id = serializer.validated_data.get('batch_id')
                batch_ids = serializer.validated_data.get('batch_ids')
                
                if not batch_ids and batch_id:
                    batch_ids = [batch_id]
                
                course_ids = serializer.validated_data.get('course_ids')
                department_ids = serializer.validated_data.get('department_ids')
                academic_year_ids = serializer.validated_data.get('academic_year_ids')
                semester_ids = serializer.validated_data.get('semester_ids')
                section_ids = serializer.validated_data.get('section_ids')
                circular_date = serializer.validated_data.get('circular_date')
                circular_file = serializer.validated_data.get('circular_file')
                circular_detail = serializer.validated_data.get('circular_detail')
                initiated_by = serializer.validated_data.get('initiated_by')

                circular_status = serializer.validated_data.get('circular_status')
                send_sms = serializer.validated_data.get('send_sms')
                message_status = serializer.validated_data.get('message_status')
                circular_sent_to = serializer.validated_data.get('circular_sent_to')
                circular_time = serializer.validated_data.get('circular_time')
                created_by = serializer.validated_data.get('created_by')

                # if not (course_ids and department_ids and academic_year_id and semester_ids and section_ids):
                #     return Response({'message': 'course_ids, department_ids, semester_ids and section_ids are required !!!'}, status=status.HTTP_400_BAD_REQUEST)

                # Make Instance

                #
                organizationInstance = Organization.objects.get(id=organization_id, is_active=True)
                branchInstance = Branch.objects.get(id=branch_id, is_active=True)
                # batchInstance = Batch.objects.get(id=batch_id, is_active=True)
                # courseInstance = Course.objects.get(id__in=course_ids, is_active=True)
                # departmentInstance = Department.objects.get(id__in=department_ids, is_active=True)
                # academicyearInstance = AcademicYear.objects.get(id__in=academic_year_ids, is_active=True)
                # semesterInstance = Semester.objects.filter(id__in=semester_ids, is_active=True)
                # sectionInstance = Section.objects.filter(id__in=section_ids, is_active=True)
                messageInitiatedByInstance = MessageInitiated.objects.get(id=initiated_by, is_active=True)

                # if course_ids and not (department_ids and academic_year_id and semester_ids and sectionInstance):
                #     # courseInstanceList = []
                #     # for course_id in course_ids:_
                #     courseInstance = Course.objects.filter(organization=organization_id,branch=branch_id,batch=batch_id,id__in=course_ids,is_active=True)
                #     departmentInstance = Department.objects.filter(organization=organization_id,branch=branch_id,batch=batch_id,course__in=course_ids, is_active=True)
                #     academic_year_instance = AcademicYear.objects.filter(organization=organization_id,branch=branch_id,batch=batch_id,course__in=course_ids,is_active=True)
                #     semester_instance = Semester.objects.filter(organization=organization_id,branch=branch_id,batch=batch_id,course__in=course_ids, is_active=True)
                #     section_instance = Section.objects.filter(organization=organization_id,branch=branch_id,batch=batch_id,course__in=course_ids, is_active=True)
                #         # courseInstanceList.append(courseInstance)
                #
                #     # departmentIds = departmentFilter.values_list('id', flat=True)
                #     # # academic_year_instance = academic_year_instance.values_list('id', flat=True)
                #     # semesterIds = semester_instance.values_list('id', flat=True)
                #     # sectionIds = section_instance.values_list('id', flat=True)
                #
                #     objects = [
                #         StudentCircular(
                #             organization=organizationInstance,
                #             branch=branchInstance,
                #             batch=batchInstance,
                #             academic_year=semester.academic_year,
                #             course=course,
                #             department=department,
                #             semester=semester,
                #             section=section,
                #             circular_date=circular_date,
                #             circular_file=circular_file,
                #             circular_details=circular_detail,
                #             initiated_by=messageInitiatedByInstance,
                #             circular_status=circular_status,
                #             send_sms=send_sms,
                #             message_status=message_status,
                #             circular_sent_to=circular_sent_to,
                #             circular_time=circular_time,
                #             created_by=created_by,
                #             updated_by=created_by
                #         )
                #         for course, department, semester, section in product(courseInstance, departmentInstance,semester_instance, section_instance)
                #     ]
                #     StudentCircular.objects.bulk_create(objects)
                if batch_ids and course_ids and department_ids and academic_year_ids and semester_ids and section_ids:
                    
                    batch_instances = Batch.objects.filter(organization=organization_id, branch=branch_id,
                                                           id__in=batch_ids, is_active=True)
                    
                    objects = []
                    # Optimize: Instead of blind Cartesian product, respect the hierarchy
                    for batch in batch_instances:
                        # 1. Get courses that belong to this batch AND are in the selected list
                        valid_courses = Course.objects.filter(
                            organization=organization_id, branch=branch_id,
                            batch=batch, id__in=course_ids, is_active=True
                        )

                        for course in valid_courses:
                            # 2. Get departments belonging to this course AND selected list
                            valid_departments = Department.objects.filter(
                                organization=organization_id, branch=branch_id,
                                course=course, id__in=department_ids, is_active=True
                            )
                            
                            for department in valid_departments:
                                # 3. Get academic years for this department (or course/batch context if Dept not directly linked to AY)
                                # Typically AY is linked to Course/Branch, but let's check your specific model structure.
                                # Assuming standard hierarchy: Org -> Branch -> Batch -> Course -> Dept -> ...
                                # The previous code gathered ALL selected AYs. We should ideally filter.
                                # If AY is independent of Dept in your schema, we might iterate all selected AYs.
                                # But usually, Semesters belong to an AY.
                                
                                valid_academic_years = AcademicYear.objects.filter(
                                   organization=organization_id, branch=branch_id,
                                   id__in=academic_year_ids, is_active=True
                                )

                                for academic_year in valid_academic_years:
                                    # 4. Semesters for this AY AND selected list
                                    valid_semesters = Semester.objects.filter(
                                        organization=organization_id, branch=branch_id,
                                        academic_year=academic_year, id__in=semester_ids, is_active=True
                                    )

                                    for semester in valid_semesters:
                                        # 5. Sections for this Semester AND selected list
                                        valid_sections = Section.objects.filter(
                                            organization=organization_id, branch=branch_id,
                                            semester=semester, id__in=section_ids, is_active=True
                                        )

                                        for section in valid_sections:
                                            # Create the object for this valid single path
                                            objects.append(
                                                StudentCircular(
                                                    organization=organizationInstance,
                                                    branch=branchInstance,
                                                    batch=batch,
                                                    academic_year=academic_year,
                                                    course=course,
                                                    department=department,
                                                    semester=semester,
                                                    section=section,
                                                    circular_date=circular_date,
                                                    circular_file=circular_file,
                                                    circular_details=circular_detail,
                                                    initiated_by=messageInitiatedByInstance,
                                                    circular_status=circular_status,
                                                    send_sms=send_sms,
                                                    message_status=message_status,
                                                    circular_sent_to=circular_sent_to,
                                                    circular_time=circular_time,
                                                    created_by=created_by,
                                                    updated_by=created_by
                                                )
                                            )
                    
                    if objects:
                        StudentCircular.objects.bulk_create(objects)

                    # for course in courseInstance:
                    #     for department in departmentInstance:
                    #         for academic_year in academic_year_instance:
                    #             for semester in semesterInstance:
                    #                 for section in sectionInstance:
                    #                     StudentCircularmessageInstance = StudentCircular.objects.create(
                    #                         organization=organizationInstance,
                    #                         branch=branchInstance,
                    #                         batch=batchInstance,
                    #                         academic_year=academicyearInstance,
                    #                         course=course,
                    #                         department=department,
                    #                         semester=semester,
                    #                         section=section,
                    #                         circular_date=circular_date,
                    #                         circular_file=circular_file,
                    #                         circular_details=circular_detail,
                    #                         initiated_by=messageInitiatedByInstance,
                    #                         circular_status=circular_status,
                    #                         send_sms=send_sms,
                    #                         message_status=message_status,
                    #                         circular_sent_to=circular_sent_to,
                    #                         circular_time=circular_time,
                    #                         created_by=created_by,
                    #                         updated_by=created_by
                    #                     )

                # if not section_ids:
                #     for ids in semester_ids:
                #
                #         section_records = Section.objects.filter(course=ids)
                #
                #
                #         for item in section_records:
                #
                #             StudentCircularmessageInstance = StudentCircular.objects.create(
                #                 organization=organizationInstance,
                #                 branch=branchInstance,
                #                 batch=batchInstance,
                #                 academic_year=academicyearInstance,
                #                 course= item.course,
                #                 section= item.section,
                #                 circular_date =circular_date,
                #                 circular_file=circular_file,
                #                 circular_details= circular_detail,
                #                 initiated_by=messageInitiatedByInstance,
                #                 circular_status=circular_status,
                #                 send_sms=send_sms,
                #                 message_status=message_status,
                #                 circular_sent_to=circular_sent_to,
                #                 circular_time=circular_time,
                #                 created_by=created_by,
                #                 updated_by=created_by
                #             )
                #
                # # elif section_ids:
                # #     # for id_ in course_ids:
                #     for course_id, section_id in zip(course_ids, section_ids):
                #         # for id_ in class_id:
                #         for id in section_id:
                #             CourseSemesterSectionBindInstance = CourseSemesterSectionBind.objects.get(course_name_id=course_id,section_name_id=id,is_active=True)
                #             if course_id == CourseSemesterSectionBindInstance.course.id:
                #                 StudentCircularmessageInstance = StudentCircular.objects.create(
                #                     academic_year_id=academicyearInstance,
                #                     course=CourseSemesterSectionBindInstance.course,
                #                     section=CourseSemesterSectionBindInstance.section,
                #                     circular_date=circular_date,
                #                     circular_file=circular_file,
                #                     circular_detail=circular_detail,
                #                     initiated_by=messageInitiatedByInstance,
                #                     organization=organizationInstance,
                #                     branch_id=branchInstance,
                #                     circular_status=circular_status,
                #                     send_sms=send_sms,
                #                     message_status=message_status,
                #                     circular_sent_to=circular_sent_to,
                #                     circular_time=circular_time,
                #                     created_by=created_by,
                #                     updated_by=created_by
                #                 )
                return Response({'message': 'Circular Message Saved Successfully'}, status=status.HTTP_200_OK)

        except ValidationError as e:

            # Rollback the transaction on validation error

            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)


        except DatabaseError as e:

            # Rollback the transaction on database error

            self.log_exception(request, str(e))

            return Response({'error': 'A database error occurred: ' + str(e)},

                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)


        except Exception as e:

            # Rollback the transaction on any other exception

            self.log_exception(request, str(e))

            return Response({'error': 'An unexpected error occurred: ' + str(e)},

                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='circularmessagecreate',

            message=error_message,

        )

from django.utils import timezone
class StudentCircularListAPIView(ListAPIView):
    queryset = StudentCircular.objects.all()
    serializer_class = CircularMessageFilterSerializer

    # serializer_class = CircularMessageSerializer

    def list(self, request, *args, **kwargs):
        try:
            # response = super().list(request, *args, **kwargs)
            # resdata = response.data
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            batch_id = request.query_params.get('batch_id')
            batch_ids = request.query_params.get('batch_ids')
            course_ids = request.query_params.get('course_ids')
            department_ids = request.query_params.get('department_ids')
            academic_year_ids = request.query_params.get('academic_year_ids')
            semester_ids = request.query_params.get('semester_ids')
            section_ids = request.query_params.get('section_ids')
            # club_group_id = request.query_params.get('club_group_id')
            # club_id = request.query_params.get('club_id')
            student_id = request.query_params.get('student_id')
            circular_date = request.query_params.get('circular_date')
            initiatedBy = request.query_params.get('initiatedBy')

            if organization_id and branch_id:
                try:
                    student_circular_instance = StudentCircular.objects.filter(organization=organization_id,
                                                                               branch=branch_id,circular_time__lte=datetime.now(),
                                                                               is_active=True).order_by('-updated_at')
                except StudentCircular.DoesNotExist:
                    return Response({"message": "student circular record not found !!!"},
                                    status=status.HTTP_404_NOT_FOUND)
            else:
                return Response({"message": "organization_id and branch_id is required !!!"},
                                status=status.HTTP_404_NOT_FOUND)

            # resdata = StudentCircular.objects.filter(organization=organization_id,branch=branch_id,is_active=True)

            if batch_ids:
                try:
                    batch_ids = json.loads(batch_ids)
                    student_circular_instance = student_circular_instance.filter(batch__in=batch_ids)
                except json.JSONDecodeError:
                    pass
            elif batch_id:
                student_circular_instance = student_circular_instance.filter(batch=batch_id)

            if course_ids:
                course_ids = json.loads(course_ids)
                student_circular_instance = student_circular_instance.filter(course__in=course_ids)

            if department_ids:
                department_ids = json.loads(department_ids)
                student_circular_instance = student_circular_instance.filter(department__in=department_ids)

            if academic_year_ids:
                academic_year_ids = json.loads(academic_year_ids)
                student_circular_instance = student_circular_instance.filter(academic_year__in=academic_year_ids)

            if semester_ids:
                semester_ids = json.loads(semester_ids)
                student_circular_instance = student_circular_instance.filter(semester__in=semester_ids)

            if section_ids:
                section_ids = json.loads(section_ids)
                student_circular_instance = student_circular_instance.filter(section__in=section_ids)

            if circular_date:
                student_circular_instance = student_circular_instance.filter(circular_date=circular_date)

            if initiatedBy:
                student_circular_instance = student_circular_instance.filter(initiated_by=initiatedBy)

            if student_circular_instance:
                responsedata = []
                for item in student_circular_instance:
                    # if item.is_active==True:
                    organization_id = item.organization.id
                    branch_id = item.branch.id
                    batch_id = item.batch.id
                    course_id = item.course.id
                    department_id = item.department.id
                    academic_year_id = item.academic_year.id
                    semester_id = item.semester.id
                    section_id = item.section.id
                    initiated_by_data = item.initiated_by.id

                    organizationInstance = Organization.objects.get(id=organization_id)
                    branchInstance = Branch.objects.get(id=branch_id)
                    batchInstance = Batch.objects.get(id=batch_id)
                    courseInstance = Course.objects.get(id=course_id)
                    departmentInstance = Department.objects.get(id=department_id)
                    academicyearInstance = AcademicYear.objects.get(id=academic_year_id)
                    semesterInstance = Semester.objects.get(id=semester_id)
                    sectionInstance = Section.objects.get(id=section_id)
                    InitiatedByInstance = MessageInitiated.objects.get(id=initiated_by_data)

                    responsedata.append({
                        'circular_id': item.id,  # get('id'),

                        'organization': organizationInstance.id,
                        'organization_code': organizationInstance.organization_code,
                        'branchId': branchInstance.id,
                        'branch_name': branchInstance.branch_name,
                        'batchId': batchInstance.id,
                        'batch_code': batchInstance.batch_code,
                        'course_id': courseInstance.id,
                        'course_name': courseInstance.course_name,
                        'department_id': departmentInstance.id,
                        'department_description': departmentInstance.department_description,
                        'academic_year_id': academicyearInstance.id,
                        'academic_year_code': academicyearInstance.academic_year_code,
                        'semester_id': semesterInstance.id,
                        'semester_name': semesterInstance.semester_code,
                        'section_id': sectionInstance.id,
                        'section_name': sectionInstance.section_name,
                        'InitiatedById': InitiatedByInstance.id,
                        'InitiatedBy': InitiatedByInstance.initiated_by,
                        'circular_date': item.circular_date,
                        'circular_file': request.build_absolute_uri(
                            item.circular_file.url) if item.circular_file else None,
                        'circular_details': item.circular_details,
                        'circular_status': item.circular_status,
                        'is_cancelled': item.is_cancelled,
                        'message_status': item.message_status,
                        'send_sms': item.send_sms,
                        'sms_sent_to': item.circular_sent_to,
                        'circular_time': item.circular_time,
                    })
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found !!!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='studentcircularListAPIView',
            message=error_message,
        )


class StudentCircularUpdateAPIView(UpdateAPIView):
    queryset = StudentCircular.objects.all()
    serializer_class = CircularMessageSerializer

    def update(self, request, *args, **kwargs):
        try:
            # partial = kwargs.pop('partial', False)
            # instance = self.get_object()
            circular_id = request.query_params.get('circular_id')
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            instance = StudentCircular.objects.get(id=circular_id, organization=organization_id, branch=branch_id,
                                                   is_active=True)
            # data = request.data.copy()
            # data['circular_file'] = data.pop('circularFile')
            # Validate input data
            serializer = self.get_serializer(instance, data=request.data)
            serializer.is_valid(raise_exception=True)

            # Get validate Data
            organization = serializer.validated_data.get('organization')
            branch = serializer.validated_data.get('branch')
            batch = serializer.validated_data.get('batch')
            course = serializer.validated_data.get('course')
            department = serializer.validated_data.get('department')
            academic_year = serializer.validated_data.get('academic_year')
            semester = serializer.validated_data.get('semester')
            section = serializer.validated_data.get('section')
            circular_date = serializer.validated_data.get('circular_date')
            circular_file = serializer.validated_data.get('circular_file')
            circular_details = serializer.validated_data.get('circular_details')
            initiated_by = serializer.validated_data.get('initiated_by')

            circular_status = serializer.validated_data.get('circular_status')
            send_sms = serializer.validated_data.get('send_sms')
            circular_sent_to = serializer.validated_data.get('circular_sent_to')
            circular_time = serializer.validated_data.get('circular_time')
            message_status = serializer.validated_data.get('message_status')
            updated_by = serializer.validated_data.get('updated_by')

            if (instance.circular_status).upper() == 'A':
                return Response({'message': "You can not update because it already approved!!"},
                                status=status.HTTP_400_BAD_REQUEST)

            # Update instance with new data
            instance.organization = organization
            instance.branch = branch
            instance.batch = batch
            instance.course = course
            instance.department = department
            instance.academic_year = academic_year
            instance.semester = semester
            instance.section = section
            instance.circular_date = circular_date

            instance.circular_details = circular_details
            instance.initiated_by = initiated_by

            instance.circular_status = circular_status
            instance.send_sms = send_sms
            instance.circular_sent_to = circular_sent_to
            instance.circular_time = circular_time
            instance.updated_by = updated_by

            if circular_file:
                instance.circular_file = circular_file
                instance.circular_file_url = request.build_absolute_uri(instance.circular_file.url)

            instance.save()

            return Response({'message': 'Circular Message updated successfully.'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='CircularMessageUpdate',
            message=error_message,
        )


class StudentCircularDeleteAPIView(DestroyAPIView):
    queryset = StudentCircular.objects.all()
    serializer_class = CircularMessageSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            circular_id = request.query_params.get("circular_id")
            instance = StudentCircular.objects.get(id=circular_id, organization=organization_id, branch=branch_id,
                                                   is_active=True)

            # make sure message status not approved
            if (instance.circular_status).upper() == 'A':
                return Response({'message': 'You can not Delete message because  it already approved!!'},
                                status=status.HTTP_400_BAD_REQUEST)

            else:
                instance.is_active = False
                instance.save()

                return Response({'message': 'Circular message Deleted Successfully'}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)


class StudentCircularCancelAPIView(DestroyAPIView):
    queryset = StudentCircular.objects.all()
    serializer_class = CircularMessageSerializer

    def destroy(self, request, *args, **kwargs):
        try:
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            circular_id = request.query_params.get("circular_id")

            try:
                instance = StudentCircular.objects.get(id=circular_id, organization=organization_id, branch=branch_id,
                                                       is_active=True)
            except StudentCircular.DoesNotExist:
                return Response({"message": "record not found"}, status=status.HTTP_404_NOT_FOUND)

            # make sure message status not approved
            # if (instance.circular_status).upper() != 'A' and (instance.circular_status).upper() != 'P':  #circular status
            #     return Response({'message': 'This circular id is not approved, you cannot delete it!!'}, status=status.HTTP_200_OK)
            # else:
            instance.message_status = 'C'
            instance.is_cancelled = True
            instance.save()
            return Response({'message': 'Circular message Cancel Successfully'}, status=status.HTTP_200_OK)
        except Http404:
            return Response({'message': 'record not found'}, status=status.HTTP_404_NOT_FOUND)


class GetAssignmentBasedOnId(RetrieveAPIView):
    queryset = StudentAssignment.objects.all()
    serializer_class = StudentAssignmentSerializer

    def retrieve(self, request, *args, **kwargs):
        try:
            assignment_id = request.query_params.get('assignment_id')
            instance = StudentAssignment.objects.get(id=assignment_id)
            if instance:
                # academicyearInstance = AcademicYear.objects.get(id=instance.academic_year_id.id)
                # organizationInstance = Organization.objects.get(id=instance.organization.id)
                # # branchInstance = Branches.objects.get(id=instance.branch_id.id)
                # courseInstance = Course.objects.get(id=instance.course_id.id)
                # sectionInstance = Section.objects.get(id=instance.section_id.id)
                # lectureInstance = Lecture.objects.get(id=instance.class_period_id.id)
                # subjectInstance = CourseDepartmentSubject.objects.get(id=instance.subject.id)
                # EmployeeMasterInstance = EmployeeMaster.objects.get(id=instance.teacher_id.id)

                name_part = filter(None, [
                    instance.professor.title,
                    instance.professor.first_name,
                    instance.professor.middle_name,
                    instance.professor.last_name

                ])
                professor_name = " ".join(name_part)
                data = {
                    'id': instance.id,

                    'organization_id': instance.organization.id,
                    'organization_code': instance.organization.organization_code,
                    'branch_id': instance.branch.id,
                    'branch_name': instance.branch.branch_name,
                    'batch_id': instance.batch.id,
                    'batch_code': instance.batch.batch_code,
                    'course_id': instance.course.id,
                    'course_name': instance.course.course_name,
                    'department_id': instance.department.id,
                    'department_name': instance.department.department_description,
                    'academic_year_id': instance.academic_year.id,
                    'academic_year': instance.academic_year.academic_year_code,
                    'semester_id': instance.semester.id,
                    'semester_code': instance.semester.semester_code,
                    'section_id': instance.section.id,
                    'section_name': instance.section.section_name,
                    'lecture_id': instance.lecture_period.id,
                    'lecture_name': instance.lecture_period.lecture_period_name,
                    'subject_id': instance.subject.id,
                    'subject_name': instance.subject.subject_code,
                    'professor_id': instance.professor.id,
                    'professor_name': professor_name,
                    'assignment_date': instance.assignment_date,
                    'assignment_file_url': instance.assignment_file_url if instance.assignment_file else None,
                    'assignment_file': "",
                    'assignment_details': instance.assignment_details,
                    'send_sms': instance.send_sms,
                    'sms_sent_to': instance.sms_sent_to
                }

                return Response({'message': 'Success', 'data': data}, status=status.HTTP_200_OK)



        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='AssignmentBasedOnId',

            message=error_message,

        )


class CircularMessageFilterAPIView(ListAPIView):
    serializer_class = CircularMessageFilterSerializer

    def list(self, request, *args, **kwargs):
        try:
            # course_ids = json.loads(request.query_params['course_ids'])
            # section_ids = json.loads(request.query_params['section_ids'])
            # data = {'course_ids':course_ids, 'section_ids':section_ids, 'organization':request.query_params['organization'],'branch_id':request.query_params['branch_id'],'academic_year_id':request.query_params['academic_year_id']}
            serializer = self.get_serializer(data=request.query_params)
            serializer.is_valid(raise_exception=True)

            # organization_id = serializer.validated_data.get('organization_id')
            # branch_id = serializer.validated_data.get('branch_id')

            # if organization_id and branch_id:
            #     try:
            #         studentCircularList = StudentCircular.objects.filter(organization=organization_id, branch=branch_id,is_active=True).order_by('-updated_at')
            #     except StudentCircular.DoesNotExist:
            #         return Response({"message":"student circular record not found !!!"}, status=status.HTTP_404_NOT_FOUND)
            # else:
            #     return Response({"message":"organization_id and branch_id is required !!!"}, status=status.HTTP_404_NOT_FOUND)

            try:
                filterdata = StudentCircular.objects.filter(
                    organization=serializer.validated_data.get('organization'),
                    branch_id=serializer.validated_data.get('branch_id'),
                    academic_year_id=serializer.validated_data.get('academic_year_id'),
                    is_active=True
                )

            except:
                filterdata = []

            if filterdata:

                if serializer.validated_data.get('circular_date'):
                    formatdate = datetime.strptime(str(serializer.validated_data.get('circular_date')), "%Y-%m-%d")
                    filterdata = filterdata.filter(circular_date=formatdate)

                if serializer.validated_data.get('course_ids'):
                    course_idslist = json.loads(request.query_params['course_ids'])  # Already a list
                    filterdata = filterdata.filter(course_id__in=course_idslist)

                if serializer.validated_data.get('section_ids'):
                    section_idslist = json.loads(request.query_params['section_ids'])  # Already a list
                    filterdata = filterdata.filter(section_id__in=section_idslist)
                    # Fetch class and section pairs from CourseSectionBind
                    # CourseSectionBind
                    # classSectionrecords = Section.objects.filter(pk__in=section_idslist)
                    # data = {}
                    # for item in classSectionrecords:
                    #     data.append(filterdata.filter(section_id=item.id))
                    # filterdata = data
                    # combined_filter = Q()
                    # for item in classSectionrecords:
                    #     combined_filter |= Q(class_id=item.classname.id, section_id=item.sectionname.id)
                    #
                    # filterdata = filterdata.filter(combined_filter)

                if filterdata:

                    responsedata = []
                    for item in filterdata:
                        circular_file_url = ''
                        if item.circular_file:
                            circular_file_url = request.build_absolute_uri(item.circular_file.url)
                        else:
                            circular_file_url = ''

                        responsedata.append({
                            'id': item.id,
                            'academicyearId': item.academic_year_id.id,
                            'academicyearName': item.academic_year_id.academic_year_code,
                            'organization': item.organization.id,
                            'organization_code': item.organization.organization_code,
                            'branchId': item.branch_id.id,
                            'branchname': item.branch_id.branch_name,
                            'course_id': item.course_id.id,
                            'course_name': item.course_id.course_name,
                            'section_id': item.section_id.id,
                            'section_name': item.section_id.section_name,
                            'InitiatedById': item.initiated_by.id,
                            'InitiatedBy': item.initiated_by.InitiatedBy_desc,
                            'circular_date': item.circular_date,
                            'circular_file': circular_file_url,
                            'circular_details': item.circular_details,
                            'circular_status': item.circular_status,
                            'message_status': item.message_status,
                            'is_cancelled': item.is_cancelled,
                            'send_sms': item.send_sms,
                            'sms_sent_to': item.circular_sent_to,
                            'circular_time': item.circular_time,
                        })

                    if responsedata:
                        return Response({'message': 'success!!', 'data': responsedata}, status=status.HTTP_200_OK)
                    else:
                        return Response({'message': 'No Record Found!!'}, status=status.HTTP_200_OK)

                else:
                    return Response({'message': 'No Record Found!!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No record found'}, status=status.HTTP_204_NO_CONTENT)


        except ValidationError as e:

            return Response({'message': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='CIRCULARMESSAGEFilter',

            message=error_message,

        )


# class CircularMessageFilterAPIView(ListAPIView):
#     queryset = StudentCircular.objects.all()
#     serializer_class = StudentCircularSerializer
#
#     def list(self, request, *args, **kwargs):
#         try:
#             # Fetch query parameters
#
#             organization = request.query_params.get('organization')
#             branchId = request.query_params.get('branchId')
#             academicyearId = request.query_params.get('academic_year_id')
#             course_ids = request.query_params.get('course_ids')
#             section_ids = request.query_params.get('section_ids')
#             date = request.query_params.get('date')
#             initiatedBy = request.query_params.get('initiatedby')
#
#
#
#             filterdata = StudentCircular.objects.none()
#
#             if organization and branchId and academicyearId:
#                 filterdata = StudentCircular.objects.filter(
#                     organization=organization,
#                     branch_id=branchId,
#                     academic_year_id=academicyearId,
#                     is_active=True
#                 )
#
# if date:
#     formatdate= datetime.strptime(date, "%Y-%m-%d")
#     filterdata = filterdata.filter(circular_date=formatdate)
#
#                 if initiatedBy:
#                     filterdata = filterdata.filter(initiated_by=initiatedBy)
#
# if course_ids:
#     # Convert course_ids string to a Python list
#     course_idslist = ast.literal_eval(course_ids)
#
#     filterdata = filterdata.filter(class_id__in=course_idslist)
#
#
#
#                 if section_ids:
#                     section_idslist = ast.literal_eval(section_ids)
#
# # Fetch class and section pairs from CourseSectionBind
# classSectionrecords = CourseSectionBind.objects.filter(
#     pk__in=section_idslist,
#     is_active=True
# )
#
# final_data= StudentCircular.objects.none()
#
# for item in classSectionrecords:
#
#     records= filterdata.filter(class_id=item.classname.id,section_id=item.sectionname.id)
#
#     final_data = final_data.union(records)
#
#
#                     filterdata = final_data
#
#
#
# if filterdata:
#     responsedata = []
#     for item in filterdata:
#         academicyearInstance = AcademicYear.objects.get(id=item.academic_year_id.id)
#         organizationInstance = Organization.objects.get(id=item.organization.id)
#         branchInstance = Branches.objects.get(id=item.branch_id.id)
#         courseInstance = Course.objects.get(id=item.class_id.id)
#         sectionInstance = Section.objects.get(id=item.section_id.id)
#         InitiatedByInstance = _Message_Initiated.objects.get(id=item.initiated_by.id)
#
#         responsedata.append({
#             'id': item.id,
#             'academicyearId': academicyearInstance.id,
#             'academicyearName': academicyearInstance.sesion_code,
#             'organization': organizationInstance.id,
#             'organization_code': organizationInstance.organization_code,
#             'branchId': branchInstance.id,
#             'branchname': branchInstance.branch_name,
#             'course_id': courseInstance.id,
#             'classname': courseInstance.classname,
#             'section_id': sectionInstance.id,
#             'sectionname': sectionInstance.sectionname,
#             'InitiatedById': InitiatedByInstance.id,
#             'InitiatedBy': InitiatedByInstance.InitiatedBy,
#             'circular_date': item.circular_date,
#             'circular_file': item.circular_file.url if item.circular_file else None,
#             'circular_details': item.circular_details,
#             'circular_status': item.circular_status,
#             'message_status': item.message_status,
#             'send_sms': item.send_sms,
#             'sms_sent_to': item.circular_sent_to,
#             'circular_time': item.circular_time,
#         })
#
#     if responsedata:
#         return Response({'message':'success!!','data':responsedata},status=status.HTTP_200_OK)
#     else:
#         return Response({'message': 'No Record Found!!'}, status=status.HTTP_200_OK)
#
# else:
#     return Response({'message':'No Record Found!!'},status=status.HTTP_200_OK)
#
#
#             else:
#                 raise ValidationError(
#                     {'message': 'Please pass organization, BranchId, and AcademicYearId'},
#                     code=status.HTTP_400_BAD_REQUEST
#                 )
#
#
#         except Http404:
#
#             return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)
#
#
#         except Exception as e:
#
#             # Log the exception
#
#             error_message = str(e)
#
#             self.log_exception(request, error_message)
#
#             return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#     def log_exception(self, request, error_message):
#
#         ExceptionTrack.objects.create(
#
#             request=str(request),
#
#             process_name='CIRCULARMESSAGEFilter',
#
#             message=error_message,
#
#         )


# --- Student Course Record List --- #
class SearchStudentCourseListAPIView(ListAPIView):
    # permission_classes = [IsAuthenticated]
    queryset = StudentCourse.objects.all()
    serializer_class = SearchStudentListSerializer

    def list(self, request, *args, **kwargs):

        try:
            # Fetch query parameters
            serializer = self.get_serializer(data=request.query_params)
            serializer.is_valid(raise_exception=True)

            organization_id = serializer.validated_data.get('organization_id')
            branch_id = serializer.validated_data.get('branch_id')
            batch_id = serializer.validated_data.get('batch_id')
            course_id = serializer.validated_data.get('course_id')
            department_id = serializer.validated_data.get('department_id')
            academic_year_id = serializer.validated_data.get('academic_year_id')
            semester_id = serializer.validated_data.get('semester_id')
            section_id = serializer.validated_data.get('section_id')
            student_id = serializer.validated_data.get('student_id')
            student_name = serializer.validated_data.get('student_name')
            registration_no = serializer.validated_data.get('registration_no')
            admission_no = serializer.validated_data.get('admission_no')
            barcode = serializer.validated_data.get('barcode')
            father_name = serializer.validated_data.get('father_name')
            mother_name = serializer.validated_data.get('mother_name')
            # <<<<<<< HEAD
            college_admission_no = serializer.validated_data.get('college_admission_no')
            hostel_availed = serializer.validated_data.get('hostel_availed')
            # =======
            #             college_admission_no = serializer.validated_data.get('college_admission_no')
            mentor_id = serializer.validated_data.get('mentor_id')
            teacher_id = serializer.validated_data.get('teacher_id')
            search_query = serializer.validated_data.get('search_query')
            # >>>>>>> 98d3432918ff50c89ad218833c4ac8870395291d

            # filterdata = StudentCourse.objects.none()

            if organization_id and branch_id:
                try:
                    studentCourseList = StudentCourse.objects.filter(organization=organization_id,
                                                                     branch=branch_id,
                                                                     is_active=True).order_by('-updated_at')
                except StudentCourse.DoesNotExist:
                    return Response({"message": "student course record not found !!!"},
                                    status=status.HTTP_404_NOT_FOUND)
            else:
                return Response({"message": "organization_id and branch_id is required !!!"},
                                status=status.HTTP_404_NOT_FOUND)

            if batch_id:
                studentCourseList = studentCourseList.filter(batch=batch_id)

            if student_id:
                studentCourseList = studentCourseList.filter(student=student_id)

            if course_id:
                studentCourseList = studentCourseList.filter(course=course_id)

            if department_id:
                studentCourseList = studentCourseList.filter(department=department_id)

            if academic_year_id:
                studentCourseList = studentCourseList.filter(academic_year=academic_year_id)

            if semester_id:
                studentCourseList = studentCourseList.filter(semester=semester_id)

            if section_id:
                studentCourseList = studentCourseList.filter(section=section_id)

            # Filter by mentor_id or teacher_id (mentor assignment)
            if mentor_id or teacher_id:
                from MENTOR.models import Mentor, StudentMentorAssignment

                # If teacher_id provided, get the mentor
                if teacher_id:
                    try:
                        from Acadix.models import EmployeeMaster
                        employee = EmployeeMaster.objects.get(id=teacher_id, is_active=True)
                        mentor = Mentor.objects.filter(employee=employee, is_active=True).first()
                        if mentor:
                            mentor_id = mentor.id
                        else:
                            # If no mentor profile exists, return empty result
                            return Response({'message': 'success!!', 'data': []}, status=status.HTTP_200_OK)
                    except EmployeeMaster.DoesNotExist:
                        return Response({'message': 'success!!', 'data': []}, status=status.HTTP_200_OK)

                # Filter students who have active assignments with this mentor
                if mentor_id:
                    assigned_student_ids = StudentMentorAssignment.objects.filter(
                        mentor_id=mentor_id,
                        is_active=True,
                        status='ACTIVE'
                    ).values_list('student_id', flat=True)

                    # If academic_year_id is provided, also filter by academic year
                    if academic_year_id:
                        assigned_student_ids = StudentMentorAssignment.objects.filter(
                            mentor_id=mentor_id,
                            academic_year_id=academic_year_id,
                            is_active=True,
                            status='ACTIVE'
                        ).values_list('student_id', flat=True)

                    studentCourseList = studentCourseList.filter(student_id__in=assigned_student_ids)

            # General search query - searches across multiple fields
            if search_query:
                search_query = search_query.strip()
                if search_query:
                    # Search across name, admission_no, barcode, college_admission_no, email
                    studentCourseList = studentCourseList.filter(
                        Q(student__first_name__icontains=search_query) |
                        Q(student__middle_name__icontains=search_query) |
                        Q(student__last_name__icontains=search_query) |
                        Q(student__admission_no__icontains=search_query) |
                        Q(student__college_admission_no__icontains=search_query) |
                        Q(student__barcode__icontains=search_query) |
                        Q(student__email__icontains=search_query) |
                        Q(student__father_name__icontains=search_query) |
                        Q(student__mother_name__icontains=search_query),
                        student__is_active=True
                    )

            # Specific field filters (only if search_query is not provided, or as additional filters)
            if student_name and not search_query:
                print(f"DEBUG: student_name received: '{student_name}'")
                name_parts = student_name.strip().split()
                print(f"DEBUG: name_parts: {name_parts}, length: {len(name_parts)}")
                print(f"DEBUG: studentCourseList count before name filter: {studentCourseList.count()}")
                
                if len(name_parts) == 1:
                    first = name_parts[0].strip()
                    studentCourseList = studentCourseList.filter(
                        Q(student__first_name__icontains=first) |
                        Q(student__middle_name__icontains=first) |
                        Q(student__last_name__icontains=first),
                        student__is_active=True
                    )
                elif len(name_parts) == 2:  # First + Last
                    first, last = name_parts
                    # Debug: Check what students have "sonali" in their name
                    debug_students = studentCourseList.filter(
                        Q(student__first_name__icontains=first) |
                        Q(student__middle_name__icontains=first) |
                        Q(student__last_name__icontains=first),
                        student__is_active=True
                    )[:5]
                    for s in debug_students:
                        print(f"DEBUG: Student found with '{first}': first_name='{s.student.first_name}', middle_name='{s.student.middle_name}', last_name='{s.student.last_name}'")
                    
                    # More flexible search: first word OR second word can be in ANY name field
                    studentCourseList = studentCourseList.filter(
                        # Both terms somewhere in the name (more flexible)
                        (Q(student__first_name__icontains=first) | Q(student__middle_name__icontains=first) | Q(student__last_name__icontains=first)) &
                        (Q(student__first_name__icontains=last) | Q(student__middle_name__icontains=last) | Q(student__last_name__icontains=last)),
                        student__is_active=True
                    )
                    print(f"DEBUG: After 2-word filter, count: {studentCourseList.count()}")
                elif len(name_parts) == 3:  # First + Middle + Last
                    first, middle, last = name_parts
                    studentCourseList = studentCourseList.filter(
                        student__first_name__icontains=first,
                        student__middle_name__icontains=middle,
                        student__last_name__icontains=last,
                        student__is_active=True
                    )

            if college_admission_no and not search_query:
                studentCourseList = studentCourseList.filter(
                    student__college_admission_no__icontains=college_admission_no)

            if admission_no and not search_query:
                studentCourseList = studentCourseList.filter(student__admission_no__icontains=admission_no)

            if registration_no and not search_query:
                studentCourseList = studentCourseList.filter(student__registration_no=registration_no)

            if barcode and not search_query:
                studentCourseList = studentCourseList.filter(student__barcode__icontains=barcode)

            if father_name and not search_query:
                studentCourseList = studentCourseList.filter(student__father_name__icontains=father_name)

            if mother_name and not search_query:
                studentCourseList = studentCourseList.filter(student__mother_name__icontains=mother_name)

            if hostel_availed:
                studentCourseList = studentCourseList.filter(hostel_availed=hostel_availed.capitalize())

            if studentCourseList:
                responsedata = []

                for item in studentCourseList:

                    courseInstance = Course.objects.get(id=item.course.id)

                    sectionInstance = Section.objects.get(id=item.section.id)

                    RegistrationInstance = StudentRegistration.objects.get(id=item.student.id)

                    # print(item.fee_group,type(item.fee_group))

                    if item.fee_group:
                        try:
                            feestructureInstance = FeeStructureMaster.objects.get(id=item.fee_group.id,
                                                                                  is_active=True)
                            fee_structure_data = {
                                'fee_structure_id': feestructureInstance.id,
                                'fee_structure_code': feestructureInstance.fee_structure_code,
                            }
                        except FeeStructureMaster.DoesNotExist:
                            fee_structure_data = {
                                'fee_structure_id': None,
                                'fee_structure_code': None,
                            }
                    else:
                        fee_structure_data = {
                            'fee_structure_id': None,
                            'fee_structure_code': None,
                        }

                    if item.fee_applied_from:
                        # print(item.feeappfrom)
                        try:
                            semesterInstance = Semester.objects.get(id=item.fee_applied_from.id,
                                                                    is_active=True)
                            # print(periodsInstance)
                            semester_data = {
                                'semester_id': semesterInstance.id,
                                'semester_description': semesterInstance.semester_description,
                            }
                            # print(period_data)
                        except Semester.DoesNotExist:
                            semester_data = {
                                'semester_id': None,
                                'semester_description': None,
                            }
                    else:
                        semester_data = {
                            'semester_id': None,
                            'semester_description': None,
                        }

                    if item.transport_availed:

                        try:
                            routedetailsInstance = RouteDetail.objects.get(id=item.route_id,
                                                                           is_active=True)
                            routemasterInstance = RouteMaster.objects.get(id=routedetailsInstance.route_master.id)

                            pickuppointInstance = PickupPoint.objects.get(id=routedetailsInstance.pickup_point.id)

                            route_data = {
                                'route_id': routemasterInstance.id,
                                'transport_name': routemasterInstance.transport_name,
                                'route_detail_id': routedetailsInstance.id,
                                'pickup_point_id': pickuppointInstance.id,
                                'pickup_point_name': pickuppointInstance.pickup_point_name
                            }
                        except RouteMaster.DoesNotExist:
                            route_data = {
                                'route_id': None,
                                'transport_name': None,
                                'route_detail_id': None,
                                'pickup_point_id': None,
                                'pickup_point_name': None
                            }
                    else:
                        route_data = {
                            'route_id': None,
                            'transport_name': None,
                            'route_detail_id': None,
                            'pickup_point_id': None,
                            'pickup_point_name': None
                        }

                    # if item.hostel_availed:
                    #     try:

                    name_part = filter(None, [
                        RegistrationInstance.first_name,
                        RegistrationInstance.middle_name,
                        RegistrationInstance.last_name

                    ])
                    student_name = " ".join(name_part)

                    data = {
                        'id': item.id,
                        'student_id': item.student.id,
                        'organization_id': item.organization.id,
                        'organization_code': item.organization.organization_code,
                        'branch_id': item.branch.id,
                        'branch_name': item.branch.branch_name,
                        'batch_id': item.batch.id,
                        'batch_code': item.batch.batch_code,
                        'course_id': item.course.id,
                        'course_name': item.course.course_name,
                        'department_id': item.department.id,
                        'department_code': item.department.department_code,
                        'academic_year_id': item.semester.academic_year.id,
                        'academic_year_code': item.semester.academic_year.academic_year_code,
                        'semester_id': item.semester.id,
                        'semester_name': item.semester.semester_description,
                        'section': sectionInstance.id,
                        'section_name': sectionInstance.section_name,
                        'enrollment_no': item.enrollment_no,
                        'student_name': student_name,
                        'college_admission_no': RegistrationInstance.college_admission_no,
                        'registration_no': RegistrationInstance.registration_no,
                        'barcode': RegistrationInstance.barcode,
                        'father_name': RegistrationInstance.father_name,
                        'mother_name': RegistrationInstance.mother_name,
                        'fee_structure_id': fee_structure_data['fee_structure_id'],
                        'fee_structure_code': fee_structure_data['fee_structure_code'],
                        'fee_applied_from_id': semester_data['semester_id'],
                        'fee_applied_from_name': semester_data['semester_description'],
                        'choice_semester': item.choice_semester,
                        'house_id': item.house.id if item.house else None,
                        'house': item.house.house_name if item.house else '',
                        'hostel_availed': item.hostel_availed,
                        'hostel_choice_semester': item.hostel_choice_semester,
                        'transport_availed': item.transport_availed,
                        'route_id': route_data['route_id'],
                        'transport_name': route_data['transport_name'],
                        'route_detail_id': route_data['route_detail_id'],
                        'pickup_point_id': route_data['pickup_point_id'],
                        'pickup_point_name': route_data['pickup_point_name'],
                        'student_status': item.student_status,

                    }

                    responsedata.append(data)

                return Response({'message': 'success!!', 'data': responsedata}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!!'}, status=status.HTTP_200_OK)

            # else:
            #     raise ValidationError(
            #         {'message': 'organization_id and branch_id is required !!!'},
            #         code=status.HTTP_400_BAD_REQUEST
            #     )

        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='Student-Course-Record-Filter',

            message=error_message,

        )


# --- Student Course Record Update --- #
class StudentCourseUpdateAPIView(UpdateAPIView):
    # permission_classes = [IsAuthenticated]
    queryset = StudentCourse.objects.all()
    serializer_class = StudentCourseUpdateSerializer

    def update(self, request, *args, **kwargs):

        try:
            # partial = kwargs.pop('partial', False)
            promote_flag = bool(request.query_params.get('is_promoted'))
            student_id = request.query_params.get('student_id')
            # instance = self.get_object()

            if student_id:
                student = StudentRegistration.objects.get(id=student_id)
            else:
                return Response({"message": "student_id is required !!!"}, status=status.HTTP_400_BAD_REQUEST)

            if promote_flag:
                try:
                    instance = StudentCourse.objects.get(student=student_id,student_status__iexact='PROMOTED', is_active=False, is_promoted=True)
                except StudentCourse.DoesNotExist:
                    return Response({"message": "Student Course record not found !!!"},
                                    status=status.HTTP_400_BAD_REQUEST)
            else:
                instance = StudentCourse.objects.get(student=student_id, is_active=True)

            # Validate input data
            serializer = self.get_serializer(instance, data=request.data)
            serializer.is_valid(raise_exception=True)

            # Get validate Data
            # studentId = serializer.validated_data.get('studentId')

            login_id = serializer.validated_data.get('login_id')
            organization_id = serializer.validated_data.get('organization_id')
            branch_id = serializer.validated_data.get('branch_id')
            batch_id = serializer.validated_data.get('batch_id')
            course_id = serializer.validated_data.get('course_id')
            department_id = serializer.validated_data.get('department_id')
            academic_year_id = serializer.validated_data.get('academic_year_id')
            semester_id = serializer.validated_data.get('semester_id')
            section_id = serializer.validated_data.get('section_id')
            # registration_no = serializer.validated_data.get('registration_no')
            # barcode = serializer.validated_data.get('barcode')
            # enrollment_no = serializer.validated_data.get('enrollment_no')
            house_id = serializer.validated_data.get('house_id')
            fee_group_id = serializer.validated_data.get('fee_group_id')
            fee_applied_from_id = serializer.validated_data.get('fee_applied_from_id')
            transport_availed = serializer.validated_data.get('transport_availed')
            choice_semester = serializer.validated_data.get('choice_semester')
            route_id = serializer.validated_data.get('route_id')
            amount = serializer.validated_data.get('amount')
            previous_year_balance = serializer.validated_data.get('previous_year_balance')
            update_or_confirm = serializer.validated_data.get('update_or_confirm')
            carry_or_delete = serializer.validated_data.get('carry_or_delete')

            # Organization Instance
            organizationInstance = Organization.objects.get(id=organization_id, is_active=True)

            # Branch Instance
            branchInstance = Branch.objects.get(id=branch_id, is_active=True)

            # Batch Instance
            batchInstance = Batch.objects.get(id=batch_id, is_active=True)

            # course instance
            courseInstance = Course.objects.get(id=course_id, is_active=True)

            # department instance
            departmentInstance = Department.objects.get(id=department_id, is_active=True)

            # Academic year instance
            academicyearInstance = AcademicYear.objects.get(id=academic_year_id, is_active=True)

            # semester instance
            semesterInstance = Semester.objects.get(id=semester_id, is_active=True)

            # Section Instance
            sectionInstance = Section.objects.get(id=section_id, is_active=True)

            # Check unpaid fees for the student
            # unpaid_fee_exists = StudentFeeDetail.objects.filter(
            #     student=instance.student,
            #     # academic_year=instance.academic_year,
            #     fee_group=instance.fee_group,
            #     paid_amount=Decimal('0.00'),
            #     is_active=True
            # ).exists()

            # Prevent fee group update if no unpaid fees exist
            # if not unpaid_fee_exists and instance.fee_group != fee_group_id and instance.course.id != course_id and instance.fee_applied_from != fee_applied_from_id:
            #     return Response(
            #         {
            #             "message": "Fee group & class & fee_applied_from cannot be updated because all fees are already paid."},
            #         status=status.HTTP_400_BAD_REQUEST
            #     )

            # Process If Feestructure Change

            # if unpaid_fee_exists and instance.fee_group != fee_group_id:
            #     studentfeedetailsrecordNotpaid = StudentFeeDetail.objects.filter(
            #         # academic_year=instance.academic_year,
            #         student=instance.student,
            #         fee_group=instance.fee_group,
            #         paid_amount=Decimal('0.00'),
            #         is_active=True
            #     ).exclude(
            #         Exists(
            #             StudentFeeDetail.objects.filter(
            #                 fee_applied_from=OuterRef('fee_applied_from'),
            #                 paid_amount=Decimal('0.00'),
            #                 # academic_year=instance.academic_year,
            #                 is_active=True
            #             )
            #         )
            #     )
                # print(studentfeedetailsrecordNotpaid)

                # Inactive the record which is not paid

                # for record in studentfeedetailsrecordNotpaid:
                #     record.is_active = False
                #     record.save()

                # now check the fee structure which i want to applied

                # Get the record fee structure details data

                # feestructuredata = FeeStructureDetail.objects.filter(fee_structure_master=fee_group_id, is_active=True)

                # print(feestructuredata)

                # Iterate the new filter fee details record
                # if promote_flag:
                #     if instance.choice_semester == [1,2,3,]
                # for item in feestructuredata:
                #
                #     if item.semester_1 == None and item.semester_2 == None and item.semester_3 == None and item.semester_4 == None and item.semester_5 == None and item.semester_6 == None or (
                #             item.semester_7 and item.semester_8):
                #
                #         # Get period Instance List
                #         semesterrecords = Semester.objects.all()
                #
                #         for semester in semesterrecords:
                #
                #             # Check periodId and feeappfromId greater
                #
                #             if semester.id >= fee_applied_from_id:
                #
                #                 # Insert Record on student fee details
                #
                #                 studentfeedetailsInstance = StudentFeeDetail.objects.create(
                #                     student=instance.student,
                #                     student_course=instance,
                #                     branch=branchInstance,
                #                     fee_group=item.fee_structure_master,
                #                     fee_structure_details=item,
                #                     element_name=item.element_type.element_name,
                #                     fee_applied_from=semester,
                #                     paid='N',
                #                     academic_year=academicyearInstance,
                #                     organization=organizationInstance,
                #                     department=departmentInstance,
                #                     multiplying_factor=1,
                #                     element_amount=item.amount,
                #                     total_element_period_amount=item.amount,
                #                     paid_amount=0.00,
                #                     remarks="",
                #                     reverse_flag="",
                #                     created_by=login_id,
                #                     updated_by=login_id
                #                 )
                #             else:
                #                 continue
                #
                #     else:
                #
                #         # List of period attributes to iterate through
                #         semesters = [
                #             'semester_1', 'semester_2', 'semester_3',
                #             'semester_4', 'semester_5', 'semester_6',
                #             'semester_7', 'semester_8'
                #         ]
                #         # try:
                #         #     fee_structure_instance = FeeStructureMaster.objects.get(id=fee_group_id,is_active=True)
                #         # except FeeStructureMaster.DoesNotExist:
                #         #     return Response({"message":"fee_structure_master record not found !!!"}, status=status.HTTP_204_NO_CONTENT)
                #
                #         for semester in semesters:
                #             semester_value = getattr(item, semester)  # Dynamically get the value of the current period
                #             if semester_value is not None and semester_value >= fee_applied_from_id:
                #                 try:
                #                     semester_instance = Semester.objects.get(id=semester_value, is_active=True)
                #                 except Semester.DoesNotExist:
                #                     return Response(
                #                         {"message": f"Semester record not found with id : {semester_value}"},
                #                         status=status.HTTP_204_NO_CONTENT)
                #                 # semester_instance = Semester.objects.get(id=semester_value, is_active = True)
                #                 StudentFeeDetail.objects.create(
                #                     student=instance.student,
                #                     student_course=instance,
                #                     branch=branchInstance,
                #                     fee_group=item.fee_structure_master,
                #                     fee_structure_details=item,
                #                     element_name=item.element_type.element_name,
                #                     fee_applied_from=semester_instance,
                #                     paid='N',
                #                     academic_year=academicyearInstance,
                #                     organization=organizationInstance,
                #                     department=departmentInstance,
                #                     multiplying_factor=1,
                #                     element_amount=item.amount,
                #                     total_element_period_amount=item.amount,
                #                     paid_amount=0.00,
                #                     remarks="",
                #                     reverse_flag="",
                #                     created_by=login_id,
                #                     updated_by=login_id
                #                 )

            #  If Transport Availed Choose Or Not

            if transport_availed:
                # Get RouteDetails Record
                routedetailsInstance = RouteDetail.objects.get(id=route_id, is_active=True)

                # Filter Student_Fee_Details where element_name matches a transport_name in Route_master

                # for item in choice_semester:

                try:
                    studentfeedetails_record = StudentFeeDetail.objects.filter(
                        student=instance.student,
                        element_name="Transport Fees",
                        # academic_year= studentcourseInstance.academic_year,
                        organization=instance.student.organization,
                        branch=instance.student.branch,
                        paid_amount= Decimal('0.00'),
                        is_active=True
                    ).filter(Q(paid_amount=0) | Q(paid_amount__isnull=True))

                    # Check if records exist
                    if studentfeedetails_record.exists():
                        studentfeedetails_record.update(is_active=False)

                except StudentFeeDetail.DoesNotExist:
                    studentfeedetails_record = None

                # StudentFeeDetail.objects.filter(
                #         organization=instance.organization,
                #         branch=instance.branch,
                #         student=instance.student,
                #         paid_amount=Decimal('0.00'),
                #         is_active=True,
                #         element_name='Transport Fees'
                #     ).update(is_active=False)


                # studenttransportdetailsrecordNotpaid = StudentFeeDetail.objects.filter(
                #     # academic_year=instance.academic_year,
                #     organization=instance.organization,
                #     branch=instance.branch,
                #     # batch=instance.batch,
                #     student=instance.student,
                #     paid_amount=Decimal('0.00'),
                #     is_active=True,
                #     element_name='Transport Fees'
                # ).exclude(
                #     Exists(
                #         StudentFeeDetail.objects.filter(
                #             organization=instance.organization,
                #             branch=instance.branch,
                #             # batch=instance.batch,
                #             # fee_applied_from=OuterRef('fee_applied_from'),
                #             semester=OuterRef('semester'),
                #             paid_amount=Decimal('0.00'),
                #             # academic_year=instance.academic_year,
                #             is_active=True
                #         )
                #     )
                # )

                # print(studenttransportdetailsrecordNotpaid)

                # Delete the transport record which not paid

                # for item in studenttransportdetailsrecordNotpaid:
                #     item.is_active = False
                #     item.save()

                # Split the first element by comma
                # lst = choice_month[0].split(',')

                # Convert each element to int
                # choice_month_list = [int(x) for x in lst]

                # choice_month_list = ast.literal_eval(choice_month)

                # if not instance.choice_semester:
                #     # instance_choice_semester = []
                #     # instance_hostel_choice_semester = []
                #     temp_choice_semesters = choice_semester
                #
                # else:
                #     temp_choice_semesters = ast.literal_eval(instance.choice_semester)
                #     if choice_semester:
                #         for item in choice_semester:
                #             temp_choice_semesters.append(item)
                #     intitial_semester_id = temp_choice_semesters[0]
                    #     pass
                    # else:

                # initial_choice_semester = Semester.objects.get(id=choice_semester[0],is_active=True)
                for item in choice_semester:
                    # Use the incoming amount if provided and greater than 0, otherwise fallback to pickup point amount
                    # final_amount = amount if amount and amount > 0 else routedetailsInstance.pickup_point_id.amount

                    try:
                        final_amount = Decimal(amount) if amount and Decimal(
                            amount) > 0 else routedetailsInstance.pickup_point.amount
                    except (InvalidOperation, TypeError, ValueError):
                        final_amount = routedetailsInstance.pickup_point.amount
                    StudentFeeDetail.objects.create(
                        student=instance.student,
                        student_course=instance,
                        organization=organizationInstance,
                        branch=branchInstance,
                        # batch=batchInstance,
                        fee_group=None,
                        fee_structure_details=None,
                        element_name='Transport Fees',  # routedetailsInstance.route_master_id.transport_name,
                        fee_applied_from=Semester.objects.get(id=choice_semester[0]) if Semester.objects.exists() else None,
                        semester =Semester.objects.get(id=item) if Semester.objects.exists() else None,
                        paid='N',
                        academic_year=academicyearInstance,
                        department=departmentInstance,
                        multiplying_factor=1,
                        element_amount=final_amount,
                        total_element_period_amount=final_amount,
                        paid_amount=0.00,
                        remarks="",
                        reverse_flag="",
                        created_by=login_id,
                        updated_by=login_id
                    )
            else:

                try:
                    studentfeedetails_record = StudentFeeDetail.objects.filter(
                        student=instance.student,
                        element_name="Transport Fees",
                        # academic_year= studentcourseInstance.academic_year,
                        organization=instance.student.organization,
                        paid_amount=Decimal('0.00'),
                        branch=instance.student.branch,
                        is_active=True
                    ).filter(Q(paid_amount=0) | Q(paid_amount__isnull=True))

                    # Check if records exist
                    if studentfeedetails_record.exists():
                        studentfeedetails_record.update(is_active=False)

                except StudentFeeDetail.DoesNotExist:
                    studentfeedetails_record = None
                # Filter Student_Fee_Details where element_name matches a transport_name in Route_master
                # studenttransportdetailsrecordNotpaid = StudentFeeDetail.objects.filter(
                #     # academic_year_id=instance.academic_year,
                #     student_id=instance.student,
                #     paid_amount=Decimal('0.00'),
                #     is_active=True,
                #     element_name='Transport Fees'
                # ).exclude(
                #     Exists(
                #         StudentFeeDetail.objects.filter(
                #             # fee_applied_from=OuterRef('fee_applied_from'),
                #             semester=OuterRef('semester'),
                #             paid_amount=Decimal('0.00'),
                #             # academic_year=instance.academic_year,
                #             is_active=True
                #         )
                #     )
                # )




                # print(studenttransportdetailsrecordNotpaid)

                # Delete the transport record which not paid

                # for item in studenttransportdetailsrecordNotpaid:
                #     item.is_active = False
                #     item.save()

            # IF STUDENT CONFIRM
            if update_or_confirm.upper() == 'C':

                # IF PREVIOUS AMOUNT WE CARRY ON NEXT YEAR
                if carry_or_delete.upper() == 'Y':
                    pass
                    # INSERT PREVIOUS YEAR BALLANCE CARRY FORWORD
                    # StudentFeeDetail.objects.create(
                    #     student=instance.student,
                    #     student_course=instance,
                    #     organization=organizationInstance,
                    #     branch=branchInstance,
                    #     # batch=batchInstance,
                    #     fee_group=None,
                    #     fee_structure_details=None,
                    #     element_name='PREVIOUS YEAR FEES',  # routedetailsInstance.route_master_id.transport_name,
                    #     fee_applied_from=Semester.objects.get(
                    #         id=fee_applied_from_id) if Semester.objects.exists() else None,
                    #     # fee_applied_from=Period.objects.order_by('sorting_order').first().id if Period.objects.exists() else None,
                    #     paid='N',
                    #     academic_year=academicyearInstance,
                    #
                    #     department=departmentInstance,
                    #     multiplying_factor=1,
                    #     element_amount=previous_year_balance,
                    #     total_element_period_amount=previous_year_balance,
                    #     paid_amount=0.00,
                    #     remarks="",
                    #     reverse_flag="",
                    #     created_by=login_id,
                    #     updated_by=login_id
                    # )

                if carry_or_delete.upper() == 'N': pass

            if update_or_confirm.upper() == 'U':
                pass
                # IF PREVIOUS AMOUNT WE CARRY ON NEXT YEAR
                # if carry_or_delete.upper() == 'Y':

                # INSERT PREVIOUS YEAR BALLANCE CARRY FORWORD
                # StudentFeeDetail.objects.create(
                #     student=instance.student,
                #     student_course=instance,
                #     organization=organizationInstance,
                #     branch=branchInstance,
                #     # batch=batchInstance,
                #     fee_group=None,
                #     fee_structure_details=None,
                #     element_name='PREVIOUS YEAR FEES',  # routedetailsInstance.route_master_id.transport_name,
                #     fee_applied_from=Semester.objects.get(id=fee_applied_from_id) if Semester.objects.exists() else None,
                #     # fee_applied_from=Period.objects.order_by('sorting_order').first().id if Period.objects.exists() else None,
                #     paid='N',
                #     academic_year=academicyearInstance,
                #
                #     department=departmentInstance,
                #     multiplying_factor=1,
                #     # element_amount=previous_year_balance,
                #     # total_element_period_amount=previous_year_balance,
                #     paid_amount=0.00,
                #     remarks="",
                #     reverse_flag="",
                #     created_by=login_id,
                #     updated_by=login_id
                # )

                if carry_or_delete.upper() == 'N': pass

            # house_name = ''
            if house_id:
                house_instance = House.objects.get(id=house_id)
                # house_name = house_instance.house_name

            if fee_group_id:
                FeeStructureInstance = FeeStructureMaster.objects.get(id=fee_group_id)

            # update student record
            # temp_choice_semesters = []

            transport_paid_sems = StudentFeeDetail.objects.filter(organization_id=organization_id,branch_id=branch_id,student_id=instance.student_id,paid__iexact='Y',element_name__iexact='Transport Fees',is_active=True).values('semester')
            updated_choice_semester= []
            if transport_paid_sems:
                for item in transport_paid_sems:
                    updated_choice_semester.append(item.get('semester'))
                if choice_semester:
                    for item in choice_semester:
                        updated_choice_semester.append(item)



            fee_applied_from_instance = Semester.objects.get(id=fee_applied_from_id)
            instance.academic_year = academicyearInstance
            # instance.academic_year= instance.academic_year_id
            instance.course = courseInstance
            instance.semester = semesterInstance
            instance.section = sectionInstance
            instance.choice_semester = updated_choice_semester
            instance.fee_group = FeeStructureInstance
            instance.fee_applied_from = fee_applied_from_instance
            # instance.enrollment_no = enrollment_no

            instance.transport_availed = transport_availed
            # instance.choice_semester = choice_semester
            instance.route_id = route_id
            instance.updated_by = login_id
            instance.student_status = 'ACTIVE'
            instance.is_active = True
            if house_id:
                instance.house = house_instance
            instance.save()

            student.is_active = True
            student.academic_year = academicyearInstance
            student.semester = semesterInstance
            student.section = sectionInstance
            student.save()

            if promote_flag:
                if not instance.hostel_availed:
                    instance_hostel_availed = False
                    instance_hostel_choice_semester = []
                else:
                    instance_hostel_availed = instance.hostel_availed
                    instance_hostel_choice_semester = instance.hostel_choice_semester
                    StudentHostelDetailInstance = StudentHostelDetail.objects.get(student=instance.student)
                    StudentHostelDetailInstance.student_course = instance
                    StudentHostelDetailInstance.save()


                    # if promote_flag:
            #
            #     try:
            #         student_hostel_detail_instance = StudentHostelDetail.objects.get(student=student)
            #         if instance.semester.id in ast.literal_eval(student_hostel_detail_instance.choice_semester):
            #             student_hostel_detail_instance.student_course = instance
            #         else:
            #             pass
            #     except StudentHostelDetail.DoesNotExist:
            #         pass




            # # Return Response
            return Response({'message': "Student Update Successfully!!"}, status=status.HTTP_200_OK)


        except Http404:
            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred.' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='Student-Course-Record-Update',
            message=error_message,
        )

# --- Student Course Record Update --- #
# class StudentCourseUpdateAPIView(UpdateAPIView):
#     # permission_classes = [IsAuthenticated]
#     queryset = StudentCourse.objects.all()
#     serializer_class = StudentCourseUpdateSerializer
#
#     def update(self, request, *args, **kwargs):
#
#         try:
#             # partial = kwargs.pop('partial', False)
#             promote_flag = bool(request.query_params.get('is_promoted'))
#             student_id = request.query_params.get('student_id')
#             # instance = self.get_object()
#
#             if student_id:
#                 student = StudentRegistration.objects.get(id=student_id)
#             else:
#                 return Response({"message": "student_id is required !!!"}, status=status.HTTP_400_BAD_REQUEST)
#
#             if promote_flag:
#                 try:
#                     instance = StudentCourse.objects.get(student=student_id,student_status__iexact='PROMOTED', is_active=False, is_promoted=True)
#                 except StudentCourse.DoesNotExist:
#                     return Response({"message": "Student Course record not found !!!"},
#                                     status=status.HTTP_400_BAD_REQUEST)
#             else:
#                 instance = StudentCourse.objects.get(student=student_id, is_active=True)
#
#             # Validate input data
#             serializer = self.get_serializer(instance, data=request.data)
#             serializer.is_valid(raise_exception=True)
#
#             # Get validate Data
#             # studentId = serializer.validated_data.get('studentId')
#
#             login_id = serializer.validated_data.get('login_id')
#             organization_id = serializer.validated_data.get('organization_id')
#             branch_id = serializer.validated_data.get('branch_id')
#             batch_id = serializer.validated_data.get('batch_id')
#             course_id = serializer.validated_data.get('course_id')
#             department_id = serializer.validated_data.get('department_id')
#             academic_year_id = serializer.validated_data.get('academic_year_id')
#             semester_id = serializer.validated_data.get('semester_id')
#             section_id = serializer.validated_data.get('section_id')
#             enrollment_no = serializer.validated_data.get('enrollment_no')
#             house_id = serializer.validated_data.get('house_id')
#             fee_group_id = serializer.validated_data.get('fee_group_id')
#             fee_applied_from_id = serializer.validated_data.get('fee_applied_from_id')
#             transport_availed = serializer.validated_data.get('transport_availed')
#             choice_semester = serializer.validated_data.get('choice_semester')
#             route_id = serializer.validated_data.get('route_id')
#             amount = serializer.validated_data.get('amount')
#             previous_year_balance = serializer.validated_data.get('previous_year_balance')
#             update_or_confirm = serializer.validated_data.get('update_or_confirm')
#             carry_or_delete = serializer.validated_data.get('carry_or_delete')
#
#             # Organization Instance
#             organizationInstance = Organization.objects.get(id=organization_id, is_active=True)
#
#             # Branch Instance
#             branchInstance = Branch.objects.get(id=branch_id, is_active=True)
#
#             # Batch Instance
#             batchInstance = Batch.objects.get(id=batch_id, is_active=True)
#
#             # course instance
#             courseInstance = Course.objects.get(id=course_id, is_active=True)
#
#             # department instance
#             departmentInstance = Department.objects.get(id=department_id, is_active=True)
#
#             # Academic year instance
#             academicyearInstance = AcademicYear.objects.get(id=academic_year_id, is_active=True)
#
#             # semester instance
#             semesterInstance = Semester.objects.get(id=semester_id, is_active=True)
#
#             # Section Instance
#             sectionInstance = Section.objects.get(id=section_id, is_active=True)
#
#             # Check unpaid fees for the student
#             unpaid_fee_exists = StudentFeeDetail.objects.filter(
#                 student=instance.student,
#                 academic_year=instance.academic_year,
#                 fee_group=instance.fee_group,
#                 paid_amount=Decimal('0.00'),
#                 is_active=True
#             ).exists()
#
#             # Prevent fee group update if no unpaid fees exist
#             if not unpaid_fee_exists and instance.fee_group != fee_group_id and instance.course.id != course_id and instance.fee_applied_from != fee_applied_from_id:
#                 return Response(
#                     {
#                         "message": "Fee group & class & fee_applied_from cannot be updated because all fees are already paid."},
#                     status=status.HTTP_400_BAD_REQUEST
#                 )
#
#             # Process If Feestructure Change
#
#             if unpaid_fee_exists and instance.fee_group != fee_group_id:
#                 studentfeedetailsrecordNotpaid = StudentFeeDetail.objects.filter(
#                     academic_year=instance.academic_year,
#                     student=instance.student,
#                     fee_group=instance.fee_group,
#                     paid_amount=Decimal('0.00'),
#                     is_active=True
#                 ).exclude(
#                     Exists(
#                         StudentFeeDetail.objects.filter(
#                             fee_applied_from=OuterRef('fee_applied_from'),
#                             paid_amount=Decimal('0.00'),
#                             academic_year=instance.academic_year,
#                             is_active=True
#                         )
#                     )
#                 )
#                 # print(studentfeedetailsrecordNotpaid)
#
#                 # Inactive the record which is not paid
#
#                 for record in studentfeedetailsrecordNotpaid:
#                     record.is_active = False
#                     record.save()
#
#                 # now check the fee structure which i want to applied
#
#                 # Get the record fee structure details data
#
#                 feestructuredata = FeeStructureDetail.objects.filter(fee_structure_master=fee_group_id, is_active=True)
#
#                 # print(feestructuredata)
#
#                 # Iterate the new filter fee details record
#                 # if promote_flag:
#                 #     if instance.choice_semester == [1,2,3,]
#                 for item in feestructuredata:
#
#                     if item.semester_1 == None and item.semester_2 == None and item.semester_3 == None and item.semester_4 == None and item.semester_5 == None and item.semester_6 == None or (
#                             item.semester_7 and item.semester_8):
#
#                         # Get period Instance List
#                         semesterrecords = Semester.objects.all()
#
#                         for semester in semesterrecords:
#
#                             # Check periodId and feeappfromId greater
#
#                             if semester.id >= fee_applied_from_id:
#
#                                 # Insert Record on student fee details
#
#                                 studentfeedetailsInstance = StudentFeeDetail.objects.create(
#                                     student=instance.student,
#                                     student_course=instance,
#                                     branch=branchInstance,
#                                     fee_group=item.fee_structure_master,
#                                     fee_structure_details=item,
#                                     element_name=item.element_type.element_name,
#                                     fee_applied_from=semester,
#                                     paid='N',
#                                     academic_year=academicyearInstance,
#                                     organization=organizationInstance,
#                                     department=departmentInstance,
#                                     multiplying_factor=1,
#                                     element_amount=item.amount,
#                                     total_element_period_amount=item.amount,
#                                     paid_amount=0.00,
#                                     remarks="",
#                                     reverse_flag="",
#                                     created_by=login_id,
#                                     updated_by=login_id
#                                 )
#                             else:
#                                 continue
#
#                     else:
#
#                         # List of period attributes to iterate through
#                         semesters = [
#                             'semester_1', 'semester_2', 'semester_3',
#                             'semester_4', 'semester_5', 'semester_6',
#                             'semester_7', 'semester_8'
#                         ]
#                         # try:
#                         #     fee_structure_instance = FeeStructureMaster.objects.get(id=fee_group_id,is_active=True)
#                         # except FeeStructureMaster.DoesNotExist:
#                         #     return Response({"message":"fee_structure_master record not found !!!"}, status=status.HTTP_204_NO_CONTENT)
#
#                         for semester in semesters:
#                             semester_value = getattr(item, semester)  # Dynamically get the value of the current period
#                             if semester_value is not None and semester_value >= fee_applied_from_id:
#                                 try:
#                                     semester_instance = Semester.objects.get(id=semester_value, is_active=True)
#                                 except Semester.DoesNotExist:
#                                     return Response(
#                                         {"message": f"Semester record not found with id : {semester_value}"},
#                                         status=status.HTTP_204_NO_CONTENT)
#                                 # semester_instance = Semester.objects.get(id=semester_value, is_active = True)
#                                 StudentFeeDetail.objects.create(
#                                     student=instance.student,
#                                     student_course=instance,
#                                     branch=branchInstance,
#                                     fee_group=item.fee_structure_master,
#                                     fee_structure_details=item,
#                                     element_name=item.element_type.element_name,
#                                     fee_applied_from=semester_instance,
#                                     paid='N',
#                                     academic_year=academicyearInstance,
#                                     organization=organizationInstance,
#                                     department=departmentInstance,
#                                     multiplying_factor=1,
#                                     element_amount=item.amount,
#                                     total_element_period_amount=item.amount,
#                                     paid_amount=0.00,
#                                     remarks="",
#                                     reverse_flag="",
#                                     created_by=login_id,
#                                     updated_by=login_id
#                                 )
#
#             #  If Transport Availed Choose Or Not
#
#             if transport_availed:
#                 # Get RouteDetails Record
#                 routedetailsInstance = RouteDetail.objects.get(id=route_id, is_active=True)
#
#                 # Filter Student_Fee_Details where element_name matches a transport_name in Route_master
#                 studenttransportdetailsrecordNotpaid = StudentFeeDetail.objects.filter(
#                     academic_year=instance.academic_year,
#                     student=instance.student,
#                     paid_amount=Decimal('0.00'),
#                     is_active=True,
#                     element_name='Transport Fees'
#                 ).exclude(
#                     Exists(
#                         StudentFeeDetail.objects.filter(
#                             fee_applied_from=OuterRef('fee_applied_from'),
#                             paid_amount=Decimal('0.00'),
#                             academic_year=instance.academic_year,
#                             is_active=True
#                         )
#                     )
#                 )
#
#                 # print(studenttransportdetailsrecordNotpaid)
#
#                 # Delete the transport record which not paid
#
#                 for item in studenttransportdetailsrecordNotpaid:
#                     item.is_active = False
#                     item.save()
#
#                 # Split the first element by comma
#                 # lst = choice_month[0].split(',')
#
#                 # Convert each element to int
#                 # choice_month_list = [int(x) for x in lst]
#
#                 # choice_month_list = ast.literal_eval(choice_month)
#                 for item in choice_semester:
#                     # Use the incoming amount if provided and greater than 0, otherwise fallback to pickup point amount
#                     # final_amount = amount if amount and amount > 0 else routedetailsInstance.pickup_point_id.amount
#
#                     try:
#                         final_amount = Decimal(amount) if amount and Decimal(
#                             amount) > 0 else routedetailsInstance.pickup_point.amount
#                     except (InvalidOperation, TypeError, ValueError):
#                         final_amount = routedetailsInstance.pickup_point.amount
#                     StudentFeeDetail.objects.create(
#                         student=instance.student,
#                         student_course=instance,
#                         organization=organizationInstance,
#                         branch=branchInstance,
#                         # batch=batchInstance,
#                         fee_group=None,
#                         fee_structure_details=None,
#                         element_name='Transport Fees',  # routedetailsInstance.route_master_id.transport_name,
#                         fee_applied_from=Semester.objects.get(id=item) if Semester.objects.exists() else None,
#                         paid='N',
#                         academic_year=academicyearInstance,
#
#                         department=departmentInstance,
#                         multiplying_factor=1,
#                         element_amount=final_amount,
#                         total_element_period_amount=final_amount,
#                         paid_amount=0.00,
#                         remarks="",
#                         reverse_flag="",
#                         created_by=login_id,
#                         updated_by=login_id
#                     )
#             else:
#
#                 # Filter Student_Fee_Details where element_name matches a transport_name in Route_master
#                 studenttransportdetailsrecordNotpaid = StudentFeeDetail.objects.filter(
#                     academic_year_id=instance.academic_year,
#                     student_id=instance.student,
#                     paid_amount=Decimal('0.00'),
#                     is_active=True,
#                     element_name='Transport Fees'
#                 ).exclude(
#                     Exists(
#                         StudentFeeDetail.objects.filter(
#                             fee_applied_from=OuterRef('fee_applied_from'),
#                             paid_amount=Decimal('0.00'),
#                             academic_year=instance.academic_year,
#                             is_active=True
#                         )
#                     )
#                 )
#
#                 # print(studenttransportdetailsrecordNotpaid)
#
#                 # Delete the transport record which not paid
#
#                 for item in studenttransportdetailsrecordNotpaid:
#                     item.is_active = False
#                     item.save()
#
#             # IF STUDENT CONFIRM
#             if update_or_confirm.upper() == 'C':
#
#                 # IF PREVIOUS AMOUNT WE CARRY ON NEXT YEAR
#                 if carry_or_delete.upper() == 'Y':
#                     pass
#                     # INSERT PREVIOUS YEAR BALLANCE CARRY FORWORD
#                     # StudentFeeDetail.objects.create(
#                     #     student=instance.student,
#                     #     student_course=instance,
#                     #     organization=organizationInstance,
#                     #     branch=branchInstance,
#                     #     # batch=batchInstance,
#                     #     fee_group=None,
#                     #     fee_structure_details=None,
#                     #     element_name='PREVIOUS YEAR FEES',  # routedetailsInstance.route_master_id.transport_name,
#                     #     fee_applied_from=Semester.objects.get(
#                     #         id=fee_applied_from_id) if Semester.objects.exists() else None,
#                     #     # fee_applied_from=Period.objects.order_by('sorting_order').first().id if Period.objects.exists() else None,
#                     #     paid='N',
#                     #     academic_year=academicyearInstance,
#                     #
#                     #     department=departmentInstance,
#                     #     multiplying_factor=1,
#                     #     element_amount=previous_year_balance,
#                     #     total_element_period_amount=previous_year_balance,
#                     #     paid_amount=0.00,
#                     #     remarks="",
#                     #     reverse_flag="",
#                     #     created_by=login_id,
#                     #     updated_by=login_id
#                     # )
#
#                 if carry_or_delete.upper() == 'N': pass
#
#             if update_or_confirm.upper() == 'U':
#                 pass
#                 # IF PREVIOUS AMOUNT WE CARRY ON NEXT YEAR
#                 # if carry_or_delete.upper() == 'Y':
#
#                 # INSERT PREVIOUS YEAR BALLANCE CARRY FORWORD
#                 StudentFeeDetail.objects.create(
#                     student=instance.student,
#                     student_course=instance,
#                     organization=organizationInstance,
#                     branch=branchInstance,
#                     # batch=batchInstance,
#                     fee_group=None,
#                     fee_structure_details=None,
#                     element_name='PREVIOUS YEAR FEES',  # routedetailsInstance.route_master_id.transport_name,
#                     fee_applied_from=Semester.objects.get(id=fee_applied_from_id) if Semester.objects.exists() else None,
#                     # fee_applied_from=Period.objects.order_by('sorting_order').first().id if Period.objects.exists() else None,
#                     paid='N',
#                     academic_year=academicyearInstance,
#
#                     department=departmentInstance,
#                     multiplying_factor=1,
#                     # element_amount=previous_year_balance,
#                     # total_element_period_amount=previous_year_balance,
#                     paid_amount=0.00,
#                     remarks="",
#                     reverse_flag="",
#                     created_by=login_id,
#                     updated_by=login_id
#                 )
#
#                 if carry_or_delete.upper() == 'N': pass
#
#             # house_name = ''
#             if house_id:
#                 house_instance = House.objects.get(id=house_id)
#                 # house_name = house_instance.house_name
#
#             if fee_group_id:
#                 FeeStructureInstance = FeeStructureMaster.objects.get(id=fee_group_id)
#
#             # update student record
#             fee_applied_from_instance = Semester.objects.get(id=fee_applied_from_id)
#             instance.academic_year = academicyearInstance
#             # instance.academic_year= instance.academic_year_id
#             instance.course = courseInstance
#             instance.semester = semesterInstance
#             instance.section = sectionInstance
#             instance.fee_group = FeeStructureInstance
#             instance.fee_applied_from = fee_applied_from_instance
#             instance.enrollment_no = enrollment_no
#
#             instance.transport_availed = transport_availed
#             instance.choice_semester = choice_semester
#             instance.route_id = route_id
#             instance.updated_by = login_id
#             instance.student_status = 'ACTIVE'
#             instance.is_active = True
#             if house_id:
#                 instance.house = house_instance
#             instance.save()
#
#             student.is_active = True
#             student.academic_year = academicyearInstance
#             student.semester = semesterInstance
#             student.section = sectionInstance
#             student.save()
#
#             # if promote_flag:
#             #
#             #     try:
#             #         student_hostel_detail_instance = StudentHostelDetail.objects.get(student=student)
#             #         if instance.semester.id in ast.literal_eval(student_hostel_detail_instance.choice_semester):
#             #             student_hostel_detail_instance.student_course = instance
#             #         else:
#             #             pass
#             #     except StudentHostelDetail.DoesNotExist:
#             #         pass
#
#
#
#
#             # # Return Response
#             return Response({'message': "Student Update Successfully!!"}, status=status.HTTP_200_OK)
#
#
#         except Http404:
#             return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)
#
#         except ValidationError as e:
#             return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)
#
#         except DatabaseError as e:
#             self.log_exception(request, str(e))
#             return Response({'error': 'A database error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#         except Exception as e:
#             self.log_exception(request, str(e))
#             return Response({'error': 'An unexpected error occurred.' + str(e)},
#                             status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#     def log_exception(self, request, error_message):
#         ExceptionTrack.objects.create(
#             request=str(request),
#             process_name='Student-Course-Record-Update',
#             message=error_message,
#         )
#




class CircularMessageRetriveAPIView(RetrieveAPIView):
    queryset = StudentCircular.objects.all()
    serializer_class = StudentCircularSerializer

    def retrieve(self, request, *args, **kwargs):
        try:
            circular_id = request.query_params.get('circular_id')
            try:
                instance = StudentCircular.objects.get(id=circular_id, is_active=True)
            except StudentCircular.DoesNotExist:
                return Response({"message": "Student Circular record not found !!!"}, )

            if instance:
                instance.circular_file_url = request.build_absolute_uri(
                    instance.circular_file.url) if instance.circular_file else ""

                # academicyearInstance = AcademicYear.objects.get(id=instance.academic_year_id.id)
                # organizationInstance = Organization.objects.get(id=instance.organization.id)
                # branchInstance = Branch.objects.get(id=instance.branch.id)
                # batchInstance = Batch.objects.get(id=instance.batch.id)
                # courseInstance = Course.objects.get(id=instance.course.id)
                # departmentInstance = Department.objects.get(id=instance.department.id)
                # semesterInstance = Semester.objects.get(id=instance.semester.id)
                # sectionInstance = Section.objects.get(id=instance.section.id)
                # classbindsectionInstance = CourseSemesterSectionBind.objects.get(course_name=instance.course_id.id,section_name=instance.section_id.id,is_active=True)

                initiatedByInstance = MessageInitiated.objects.get(id=instance.initiated_by.id, is_active=True)

                data = {
                    'id': instance.id,
                    'organization': instance.organization.id,
                    'organization_code': instance.organization.organization_code,
                    'branchId': instance.branch.id,
                    'branchname': instance.branch.branch_name,
                    'batch_id': instance.batch.id,
                    'batch_code': instance.batch.batch_code,
                    "course_id": instance.course.id,
                    "course_name": instance.course.course_name,
                    "department_id": instance.department.id,
                    "department_description": instance.department.department_description,
                    'academicyearId': instance.academic_year.id,
                    'academicyearName': instance.academic_year.academic_year_code,
                    'semester_id': instance.semester.id,
                    'semester_description': instance.semester.semester_description,
                    'section_id': instance.section.id,
                    'section_name': instance.section.section_name,
                    'InitiatedById': initiatedByInstance.id,
                    'InitiatedBy': initiatedByInstance.initiated_by,
                    'circular_date': instance.circular_date,
                    # 'circular_file': instance.circular_file,
                    'circular_file_url': instance.circular_file_url,
                    'circular_details': instance.circular_details,
                    'circular_status': instance.circular_status,
                    'message_status': instance.message_status,
                    'send_sms': instance.send_sms,
                    'sms_sent_to': instance.circular_sent_to,
                    'circular_time': instance.circular_time

                }

                return Response({'message': 'Success', 'data': data}, status=status.HTTP_200_OK)



        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='CircularMessageBasedOnId',

            message=error_message,

        )


class GetUnpaidPeriodListAPIView(ListAPIView):
    queryset = Period.objects.all()
    serializer_class = PeriodSerializer

    def list(self, request, *args, **kwargs):
        try:
            # Fetch query parameters

            organization = self.kwargs.get('organization')
            branchId = self.kwargs.get('branchId')
            academicyearId = self.kwargs.get('academic_year_id')
            studentId = self.kwargs.get('studentId')
            # print(organization,branchId,academicyearId,studentId)

            # Step 1: Filter StudentFeeDetail for given parameters
            paid_fee_applied_from_ids = StudentFeeDetail.objects.filter(
                organization=organization,
                branch_id=branchId,
                academic_year_id=academicyearId,
                student_id=studentId,
                paid_amount__gt=Decimal('0.00'),  # Filter where paid_amount > 0
                is_active=True
            ).values_list('fee_applied_from', flat=True)  # Get only 'feeappfrom' IDs

            # print(paid_feeappfrom_ids)

            # Step 2: Filter Period table excluding these feeappfrom IDs
            unpaid_periods = Period.objects.exclude(id__in=paid_fee_applied_from_ids, is_active=True)

            # print(unpaid_periods)

            # Step 3: Make the remaining Period as a response

            if unpaid_periods:
                responsedata = []
                for item in unpaid_periods:
                    data = {
                        'id': item.id,
                        'period_name': item.period_name,
                        'period_description': item.period_description,
                        'sorting_order': item.sorting_order,
                        'period_start_date': item.period_start_date,
                        'period_end_date': item.period_end_date
                    }
                    responsedata.append(data)

                return Response({'message': 'Success!!', 'data': responsedata}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!!'}, status=status.HTTP_200_OK)

        except Exception as e:
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='UnpaidPeriodList',
            message=error_message,
        )


class GetReceiptDetailsListAPIView(ListAPIView):
    queryset = StudentFeeReceiptHeader.objects.all()
    serializer_class = StudentFeeReceiptSerializer

    def list(self, request, *args, **kwargs):
        try:
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            receipt_id = request.query_params.get('receipt_id')

            # Get StdFeeReceiptHeader Instance
            try:
                StudentFeeReceiptHeaderInstance = StudentFeeReceiptHeader.objects.get(organization=organization_id,
                                                                                      branch=branch_id, id=receipt_id,
                                                                                      is_active=True)
            except ObjectDoesNotExist:
                return Response({'message': f"No active receipt found for ID {receipt_id}"},
                                status=status.HTTP_404_NOT_FOUND)

            # Get StdPayment Instance (make it optional - don't fail if not found)
            StudentPaymentInstance = None
            try:
                StudentPaymentInstance = StudentPayment.objects.get(receipt_id=receipt_id, is_active=True)
            except ObjectDoesNotExist:
                pass  # Continue without payment details

            # Get bank Instance (handle None case)
            BANKInstance = None
            if StudentPaymentInstance and StudentPaymentInstance.bank_id:
                try:
                    BANKInstance = Bank.objects.get(id=StudentPaymentInstance.bank_id, is_active=True)
                except ObjectDoesNotExist:
                    BANKInstance = None  # Explicitly set to None if not found

            # Get Account Details (handle None case)
            AccountDetailsInstance = None
            if StudentPaymentInstance and StudentPaymentInstance.bank_account_id:
                try:
                    AccountDetailsInstance = BankAccountDetail.objects.get(
                        id=StudentPaymentInstance.bank_account_id, is_active=True
                    )
                except ObjectDoesNotExist:
                    AccountDetailsInstance = None  # Explicitly set to None if not found

            # Get student name
            student_name_parts = filter(None, [
                StudentFeeReceiptHeaderInstance.student.first_name,
                StudentFeeReceiptHeaderInstance.student.middle_name,
                StudentFeeReceiptHeaderInstance.student.last_name
            ])
            student_name = ' '.join(student_name_parts)

            # Calculate discount from receipt details
            total_discount = 0
            try:
                receipt_details = StudentFeeReceiptDetail.objects.filter(
                    receipt_id=StudentFeeReceiptHeaderInstance.id
                )
                total_discount = sum(detail.discount_amount or 0 for detail in receipt_details)
            except:
                total_discount = 0

            # Prepare response data
            responsedata = {
                'receiptId': StudentFeeReceiptHeaderInstance.id,
                'receipt_id': StudentFeeReceiptHeaderInstance.id,
                'id': StudentFeeReceiptHeaderInstance.id,
                'receipt_no': StudentFeeReceiptHeaderInstance.receipt_no,
                'receipt_date': StudentFeeReceiptHeaderInstance.receipt_date,
                'student_name': student_name,
                'payment_methodId': StudentFeeReceiptHeaderInstance.payment_method.id if StudentFeeReceiptHeaderInstance.payment_method else None,
                'payment_method': StudentFeeReceiptHeaderInstance.payment_method.payment_method if StudentFeeReceiptHeaderInstance.payment_method else None,
                'bankId': BANKInstance.id if BANKInstance else None,
                'bankName': BANKInstance.bank_name if BANKInstance else None,
                'bank_name': BANKInstance.bank_name if BANKInstance else None,
                'bankdetailsId': AccountDetailsInstance.id if AccountDetailsInstance else None,
                'bank_account': AccountDetailsInstance.bank_account if AccountDetailsInstance else None,
                'amount': StudentPaymentInstance.amount if StudentPaymentInstance else 0,
                'receipt_amount': StudentPaymentInstance.amount if StudentPaymentInstance else 0,
                'payment_amount': StudentPaymentInstance.amount if StudentPaymentInstance else 0,
                'discount': total_discount,
                'discount_amount': total_discount,
                'payment_reference': StudentPaymentInstance.payment_reference if StudentPaymentInstance else None,
                'reference_date': StudentPaymentInstance.reference_date if StudentPaymentInstance else None,
            }

            return Response({'message': 'success!!', 'data': responsedata}, status=status.HTTP_200_OK)


        except Exception as e:
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='GetFeeDetailsBasedOnId',
            message=error_message,
        )


class UpdateStudentFeeRecordBasedOnReceiptId(UpdateAPIView):
    queryset = StudentFeeReceiptHeader.objects.all()
    serializer_class = FeeReceiptUpdateSerializer

    def update(self, request, *args, **kwargs):
        organization_id = request.query_params.get('organization_id')
        branch_id = request.query_params.get('branch_id')
        receipt_id = request.query_params.get('receipt_id')  # Fetch receipt_id from the URL
        # Fetch the StdFeeReceiptHeader instance
        try:
            ReceiptheaderInstance = StudentFeeReceiptHeader.objects.get(organization=organization_id, branch=branch_id,
                                                                        id=receipt_id, is_active=True)
        except StudentFeeReceiptHeader.DoesNotExist:
            return Response({'message': f"Receipt with ID {receipt_id} not found or is inactive."},
                            status=status.HTTP_404_NOT_FOUND)
        try:
            StudentPaymentInstance = StudentPayment.objects.get(receipt=ReceiptheaderInstance, is_active=True)
        except StudentPayment.DoesNotExist:
            return Response(
                {'message': f"Receipt with ID {receipt_id} not found in StudentPayment table or is inactive."},
                status=status.HTTP_404_NOT_FOUND)

        try:
            # Validate incoming data using FeeReciptUpdate serializer
            serializer = FeeReceiptUpdateSerializer(data=request.data)
            if not serializer.is_valid():
                return Response({'message': "Invalid data provided.", 'errors': serializer.errors},
                                status=status.HTTP_400_BAD_REQUEST)

            # Get validated data from serializer
            validated_data = serializer.validated_data
            receipt_date = validated_data.get('receipt_date')
            payment_method = validated_data.get('payment_method')
            bank_id = validated_data.get('bank_id')
            account_number = validated_data.get('account_number')
            payment_reference = validated_data.get('payment_reference')
            reference_date = validated_data.get('reference_date')

            # payment method Instance
            try:
                paymentmethodInstance = PaymentMethod.objects.get(organization=organization_id, branch=branch_id,
                                                                  id=payment_method, is_active=True)
            except PaymentMethod.DoesNotExist:
                return Response({"PaymentMethod record not found !!!"}, status=status.HTTP_404_NOT_FOUND)

            # Get Bank instance if bank_id is provided
            bankInstance = None
            if bank_id:
                try:
                    bankInstance = Bank.objects.get(id=bank_id, is_active=True)
                except Bank.DoesNotExist:
                    return Response({"message": "Bank not found"}, status=status.HTTP_404_NOT_FOUND)

            # Get BankAccountDetail instance if account_number is provided
            accountInstance = None
            if account_number:
                try:
                    accountInstance = BankAccountDetail.objects.get(id=account_number, is_active=True)
                except BankAccountDetail.DoesNotExist:
                    return Response({"message": "Bank Account not found"}, status=status.HTTP_404_NOT_FOUND)

            # Update the record
            ReceiptheaderInstance.receipt_date = receipt_date
            ReceiptheaderInstance.payment_method = paymentmethodInstance
            # Note: payment_reference field is commented out in StudentFeeReceiptHeader model

            StudentPaymentInstance.payment_method = paymentmethodInstance
            StudentPaymentInstance.bank = bankInstance
            StudentPaymentInstance.bank_account = accountInstance
            StudentPaymentInstance.payment_date = receipt_date
            StudentPaymentInstance.payment_reference = payment_reference
            StudentPaymentInstance.reference_date = reference_date

            ReceiptheaderInstance.save()
            StudentPaymentInstance.save()

            return Response({'message': 'payment receipt Update successfully!!'}, status=status.HTTP_200_OK)



        except Http404:
            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            self.log_exception(request, str(e))
            return Response({'error': 'A database error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': 'An unexpected error occurred.' + str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='FEESDETAILSUpdate',
            message=error_message,
        )


from .models import Bank


class GetAllBANKListAPIView(ListAPIView):
    queryset = Bank.objects.all()

    # serializer_class = BankSerializer

    def list(self, request, *args, **kwargs):
        try:
            # response = super().list(request, *args, **kwargs)
            # resdata = response.data

            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            try:
                BankInstance = Bank.objects.filter(organization=organization_id, branch=branch_id, is_active=True)
                # queryset = Bank.objects.all()
            except Bank.DoesNotExist:
                return Response({"message": "Bank record doesn't exist !!!"}, status=status.HTTP_404_NOT_FOUND)

            if BankInstance:
                responsedata = []
                for bank in BankInstance:
                    # if item.get('is_active') == True:

                    # Prepare the custom response data
                    responsedata.append({
                        'id': bank.id,
                        'bank_name': bank.bank_name,
                    })
                    # else:
                    #     continue
                if responsedata:
                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='banklist',
            message=error_message,
        )


class GetAccountDetailsListAPIView(ListAPIView):
    queryset = BankAccountDetail.objects.all()
    serializer_class = BankAccountDetailSerializer

    def list(self, request, *args, **kwargs):
        try:
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            bank_id = request.query_params.get('bank_id')

            # filter account details based on bank id
            try:
                bankdetailsrecord = BankAccountDetail.objects.filter(organization=organization_id, branch=branch_id,
                                                                     bank=bank_id, is_active=True)
            except ObjectDoesNotExist:
                return Response({'message': f"No Record Found"}, status=status.HTTP_404_NOT_FOUND)

            if bankdetailsrecord:
                responsedata = []
                for item in bankdetailsrecord:
                    responsedata.append({
                        'id': item.id,
                        'organization_id': item.organization.id,
                        'organization': item.organization.organization_description,
                        'branch_id': item.branch.id,
                        'branch_name': item.branch.branch_name,
                        'bank_branch_address': item.bank_branch_address,
                        'bank_account': item.bank_account,
                        'ifsc': item.ifsc,
                        'account_type': item.account_type,
                        'is_active': item.is_active
                    })
                return Response({'message': 'success!!', 'data': responsedata}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No record found!!'}, status=status.HTTP_200_OK)



        except Exception as e:
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='AccountDetailsList',
            message=error_message,
        )


class StudentCourseRetriveAPIView(RetrieveAPIView):
    queryset = StudentCourse.objects.all()
    serializer_class = StudentCourseSerializer

    def retrieve(self, request, *args, **kwargs):
        try:
            # Fetch `student_id` from the URL
            student_id = request.query_params.get('student_id')
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            # academic_year_id = self.kwargs.get('academic_year_id')
            # academic_year_id = request.query_params.get('academic_year_id')
            isPromoted = request.query_params.get('is_promoted')

            # Get Record student Registration

            try:
                studentregistrationInstance = StudentRegistration.objects.get(id=student_id,
                                                                              organization=organization_id,
                                                                              branch=branch_id)
            except ObjectDoesNotExist:
                return Response({'message': f"No student registration Record Found"}, status=status.HTTP_404_NOT_FOUND)

            # Get Record student class
            if not isPromoted:
                try:
                    studentcourseInstance = StudentCourse.objects.get(student=student_id, organization=organization_id,
                                                                      branch=branch_id, is_active=True)
                except ObjectDoesNotExist:
                    return Response({'message': f"No student course Record Found"}, status=status.HTTP_404_NOT_FOUND)
            else:
                try:
                    studentcourseInstance = StudentCourse.objects.get(student=student_id, organization=organization_id,
                                                                      branch=branch_id, is_active=False,
                                                                      is_promoted=True)
                    # if studentcourseInstance.is_promoted:
                    #     studentcourseInstance = StudentCourse.objects.get(student_id=studentId,is_active=False,is_promoted=False)
                except ObjectDoesNotExist:
                    return Response({'message': f"No student course Record Found"}, status=status.HTTP_404_NOT_FOUND)

            # Get Record class
            try:
                courseInstance = Course.objects.get(id=studentcourseInstance.course.id, is_active=True)
            except ObjectDoesNotExist:
                return Response({'message': f"No course Record Found"}, status=status.HTTP_404_NOT_FOUND)

            # Get Record section
            try:
                sectionInstance = Section.objects.get(id=studentcourseInstance.section.id, is_active=True)
            except ObjectDoesNotExist:
                return Response({'message': f"No section Record Found"}, status=status.HTTP_404_NOT_FOUND)

            # Get Record academic year
            try:
                academicyearInstance = AcademicYear.objects.get(id=studentcourseInstance.academic_year.id,
                                                                is_active=True)
            except ObjectDoesNotExist:
                return Response({'message': f"No Academic year Record Found"}, status=status.HTTP_404_NOT_FOUND)

            feestructuremasterInstance = None
            if studentcourseInstance.fee_group:
                try:
                    feestructuremasterInstance = FeeStructureMaster.objects.get(id=studentcourseInstance.fee_group.id,
                                                                                is_active=True)
                except ObjectDoesNotExist:
                    feestructuremasterInstance = None  # Assign None if not found

            # Get Record feeappfrom Instance
            feeperiodInstance = None
            feeSemesterInstance = None
            if studentcourseInstance.fee_applied_from:
                try:
                    feeSemesterInstance = Semester.objects.get(id=studentcourseInstance.fee_applied_from.id, is_active=True)
                except ObjectDoesNotExist:
                    feeSemesterInstance = None

            # # Get Record fee group
            # try:
            #     feestructuremasterInstance = FeeStructureMaster.objects.get(id=studentcourseInstance.fee_group, is_active=True)
            # except ObjectDoesNotExist:
            #     return Response({'message': f"No fee structure master Record Found"}, status=status.HTTP_404_NOT_FOUND)
            #
            # # Get Record feeappfrom Instance
            # try:
            #     feeperiodInstance = Period.objects.get(id=studentcourseInstance.feeappfrom, is_active=True)
            # except ObjectDoesNotExist:
            #     return Response({'message': f"No period Record Found"}, status=status.HTTP_404_NOT_FOUND)

            # Initialize `periods_data` outside the if block
            periods_data = None

            # Check if transport is availed
            if studentcourseInstance.transport_availed:
                # Check if `choice_month` is available and convert it to a list
                choice_semester = studentcourseInstance.choice_semester
                if choice_semester:
                    try:
                        # Convert string "[1,2,3]" to a Python list [1, 2, 3]
                        choice_semester_list = ast.literal_eval(choice_semester)
                        if not isinstance(choice_semester_list, list):
                            raise ValueError("Invalid format for choice_semester")
                    except (ValueError, SyntaxError):
                        return Response(
                            {"message": "Invalid choice_semester format. Expected a list-like string."},
                            status=status.HTTP_400_BAD_REQUEST,
                        )

                    # Fetch Period records based on `choice_semester` values
                    semesters = Semester.objects.filter(id__in=choice_semester_list, is_active=True)

                    # Prepare periods data
                    semester_data = [{"id": semester.id, "semester": semester.semester_description} for semester in
                                     semesters]
                else:
                    semester_data = []
                    # semesters = Semester.objects.all()

                    # Prepare periods data
                    # semester_data = [{"id": semester.id, "semester_description": semester.semester_description} for
                    #                  semester in semesters]

                # Get Record route details
                try:
                    routedetailsInstance = RouteDetail.objects.get(id=studentcourseInstance.route_id, is_active=True)
                except ObjectDoesNotExist:
                    return Response({'message': f"No route details Record Found"}, status=status.HTTP_404_NOT_FOUND)

                # periods_data = []
                periods = Period.objects.all()

                # Prepare periods data
                periods_data = [{"id": period.id, "period_name": period.period_name} for period in periods]
                # Prepare transport-related data
                route_data = {
                    "routeid": routedetailsInstance.route_master.id,
                    "transport_name": routedetailsInstance.route_master.transport_name,
                    "pickuppoitId": routedetailsInstance.pickup_point.id,
                    "pickuppointname": routedetailsInstance.pickup_point.pickup_point_name,
                    "amount": routedetailsInstance.pickup_point.amount,
                }
            else:
                # Default transport-related data if not availed
                route_data = {
                    "routeid": None,
                    "transport_name": None,
                    "pickuppoitId": None,
                    "pickuppointname": None,
                    "amount": None,
                }
                semester_data = []
                periods_data = []
                # Fetch Period records based on `choice_semester` values
                # semesters = Semester.objects.all()
                #
                # # Prepare periods data
                # semester_data = [{"id": semester.id, "semester_": semester.semester_description} for semester in
                #                  semesters]

            # Get student name
            name_part = filter(None, [
                studentregistrationInstance.first_name,
                studentregistrationInstance.middle_name,
                studentregistrationInstance.last_name
            ])
            student_name = " ".join(name_part)
            is_paid = False
            # status = []
            StudentFeeDetailData = StudentFeeDetail.objects.filter(student=student_id, is_active=True)
            if StudentFeeDetailData:
                for item in StudentFeeDetailData:
                    if item.paid == 'Y':
                        is_paid = True
                        break
                    else:
                        is_paid = False

                    # status.append(is_paid)
            transport_paid_sems = StudentFeeDetail.objects.filter(organization_id=organization_id, branch_id=branch_id,
                                                                  student=studentcourseInstance.student,
                                                                  paid__iexact='Y',element_name__iexact='Transport Fees', is_active=True).values('semester_id')
            hostel_paid_sems = StudentFeeDetail.objects.filter(organization_id=organization_id, branch_id=branch_id,
                                                                  student=studentcourseInstance.student,
                                                                  paid__iexact='Y',element_name__iexact='Hostel Fees', is_active=True).values(
                'semester_id')
            # Data representation
            data = {
                'id': studentcourseInstance.id,
                'organization_id': studentcourseInstance.organization.id,
                'organization': studentcourseInstance.organization.organization_code,
                'branch_id': studentcourseInstance.branch.id,
                'branch': studentcourseInstance.branch.branch_name,
                'batch_id': studentcourseInstance.batch.id,
                'batch': studentcourseInstance.batch.batch_code,
                'course_id': courseInstance.id,
                'course_name': courseInstance.course_name,
                'department_id': studentcourseInstance.department.id,
                'department': studentcourseInstance.department.department_description,
                'academic_year_id': academicyearInstance.id,
                'academic_year': academicyearInstance.academic_year_code,
                'semester_id': studentcourseInstance.semester.id,
                'semester_name': studentcourseInstance.semester.semester_code,
                'section_id': sectionInstance.id,
                'section_name': sectionInstance.section_name,
                'student_id': studentregistrationInstance.id,
                'student_name': student_name,
                'college_admission_no': studentregistrationInstance.college_admission_no,
                'admission_no': studentregistrationInstance.admission_no,
                'registration_no': studentregistrationInstance.registration_no,
                'barcode': studentregistrationInstance.barcode,
                'father_name': studentregistrationInstance.father_name,
                'mother_name': studentregistrationInstance.mother_name,
                'enrollment_no': studentcourseInstance.enrollment_no,
                'house_id': studentcourseInstance.house.id if studentcourseInstance.house else None,
                'house': studentcourseInstance.house.house_name if studentcourseInstance.house else None,
                'FeeStructureMasterId': feestructuremasterInstance.id if feestructuremasterInstance else None,
                'FeeStructureMaster': feestructuremasterInstance.fee_structure_description if feestructuremasterInstance else None,
                'fee_applied_fromId': feeSemesterInstance.id if feeSemesterInstance else None,
                'fee_applied_from': feeSemesterInstance.semester_description if feeSemesterInstance else None,
                'transport_availed': studentcourseInstance.transport_availed,
                'choice_semester': semester_data,
                'hostel_availed': studentcourseInstance.hostel_availed,
                'hostel_choice_semester': studentcourseInstance.hostel_choice_semester if studentcourseInstance.hostel_availed else [],
                'total_semesters': studentcourseInstance.course.total_semesters,
                'is_paid': is_paid,
                'transport_paid_sems':transport_paid_sems,
                'hostel_paid_sems':hostel_paid_sems,
                **route_data,  # Unpack transport-related data
            }
            # studentregistrationInstance.is_active = False
            # studentregistrationInstance.save()

            return Response({'message': 'Success', 'data': data}, status=status.HTTP_200_OK)

        except Http404:
            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:
            # Log the exception
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='GetStudentDataBasedOnId',
            message=error_message,
        )


class StudentFeeLedgerFilterListAPIView(ListAPIView):
    queryset = StudentFeeDetail.objects.all()
    serializer_class = FeeLedgerSerializer

    def list(self, request, *args, **kwargs):
        try:
            # Extract query parameters
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            batch_id = request.query_params.get('batch_id')
            course_id = request.query_params.get('course_id')
            department_id = request.query_params.get('department_id')
            academic_year_id = request.query_params.get('academic_year_id')
            semester_id = request.query_params.get('semester_id')
            section_id = request.query_params.get('section_id')
            student_id = request.query_params.get('student_id')
            status_data = request.query_params.get('status_data')
            from_semester = request.query_params.get('from_semester')
            to_semester = request.query_params.get('to_semester')
            report = request.query_params.get('report')
            show_fees = request.query_params.get('show_fees')
            show_balance_fees = request.query_params.get('show_balance_fees')

            # organization_id,branch_id,batch_id,course_id,department_id,semester_id,section_id,student_id,status_data,
            # from_semester,to_semester,report,show_fees,show_balance_fees

            # Validate academic year ID
            # if not academicyearId:
            #     raise ValidationError(
            #         {'message': 'Please provide academic_year_id!'},
            #         code=status.HTTP_400_BAD_REQUEST
            #     )
            if not (organization_id and branch_id):
                raise ValidationError(
                    {'message': 'Please provide organization_id and branch_id !!!'},
                    code=status.HTTP_400_BAD_REQUEST
                )

            # Get initial filter data
            filterdata = StudentCourse.objects.filter(organization=organization_id, branch=branch_id, is_active=True)
            # filterdata = StudentCourse.objects.filter(academic_year=academicyearId, is_active=True)

            # Apply additional filters
            if student_id:
                filterdata = filterdata.filter(student=student_id)
            if course_id:
                filterdata = filterdata.filter(course=course_id)

            if department_id:
                filterdata = filterdata.filter(department=department_id)

            if academic_year_id:
                filterdata = filterdata.filter(academic_year=academic_year_id)

            if semester_id:
                filterdata = filterdata.filter(semester=semester_id)

            if section_id:
                filterdata = filterdata.filter(section=section_id)

            if status_data:
                if status_data.upper() in ['TRUE', '1', 'ACTIVE']:
                    # student_registration_ids = StudentRegistration.objects.filter(status=status_data.upper()).values_list('id')
                    filterdata = filterdata.filter(student__status__iexact="ACTIVE")
                elif status_data.upper() in ['FALSE', '0', 'INACTIVE']:
                    filterdata = filterdata.filter(student__status__iexact="INACTIVE")

            if show_fees:
                filterdata_ids = filterdata.all().values_list('id', flat=True)
                # GET ALL STUDENT ID INTO STUDENT FEE DETAILS
                fee_student_ids = StudentFeeDetail.objects.filter(
                    student_course__in=filterdata_ids,
                    organization=organization_id,
                    branch=branch_id,

                    # academic_year=academic_year_id,
                    is_active=True
                ).values_list('student_id', flat=True)



                if show_fees.upper() == "F":

                    # Keep only students who have fee details

                    filterdata = filterdata.filter(student_id__in=fee_student_ids)


                elif show_fees.upper() == "A":
                    # Do nothing, retain all students
                    pass

                elif show_fees.upper() == "Z":
                    # Exclude students who have fee detailS
                    zero_fee_student_list = []
                    for item in filterdata_ids:
                        student_amount = StudentFeeDetail.objects.filter(student_course_id=item).aggregate(total=Sum('element_amount'))['total']
                        if student_amount == 0:
                            zero_fee_student_list.append(item)
                        # student_amount = StudentFeeDetail.objects.filter(student_course_id=item).values_list('element_amount',flat=True)
                    filterdata = filterdata.filter(id__in = zero_fee_student_list)

                    # StudentFeeDetail.objects.filter()
                    # filterdata = filterdata.exclude(student_id__in=fee_student_ids)

            if filterdata:
                responsedata = []

                for item in filterdata:

                    try:
                        # Get Registration Instance
                        RegistrationInstance = StudentRegistration.objects.get(id=item.student.id)
                    except ObjectDoesNotExist:
                        return Response(
                            {'message': f"No student found in registration table for ID {item.student.id}"},
                            status=status.HTTP_404_NOT_FOUND
                        )
                    # Get fee details for the student
                    feesrecord = StudentFeeDetail.objects.filter(
                        student=item.student,
                        # academic_year=academic_year_id,
                        is_active=True
                    )

                    if feesrecord.exists():
                        if from_semester and to_semester:
                            semesterInstanceIds = Semester.objects.filter(organization=organization_id,
                                                                          branch=branch_id, batch=batch_id,
                                                                          course=course_id,
                                                                          department=department_id).values_list('id',
                                                                                                                flat=True).order_by(
                                'id')
                            semester_ids = semesterInstanceIds.filter(id__range=[from_semester, to_semester])
                            feesrecord.filter(fee_applied_from__in=semester_ids)

                        if from_semester and not to_semester:
                            semesterInstanceIds = Semester.objects.filter(organization=organization_id,
                                                                          branch=branch_id, batch=batch_id,
                                                                          course=course_id,
                                                                          department=department_id).values_list('id',
                                                                                                                flat=True).order_by(
                                'id')
                            semester_ids = semesterInstanceIds.filter(
                                id__range=[from_semester, semesterInstanceIds[len(semesterInstanceIds) - 1]])
                            feesrecord.filter(fee_applied_from__in=semester_ids)

                        if not from_semester and to_semester:
                            semesterInstanceIds = Semester.objects.filter(organization=organization_id,
                                                                          branch=branch_id, batch=batch_id,
                                                                          course=course_id,
                                                                          department=department_id).values_list('id',
                                                                                                                flat=True).order_by(
                                'id')
                            semester_ids = semesterInstanceIds.filter(id__range=[semesterInstanceIds[0], to_semester])
                            feesrecord.filter(fee_applied_from__in=semester_ids)
                        # Filter fees based on periods
                        # if from_semester:
                        #     try:
                        #         semesterInstance = Semester.objects.get(organization=organization_id,branch=branch_id,batch=batch_id,course=course_id,department=department_id)
                        #         from_semester_instance = semesterInstance.get(id=from_semester)
                        #         # start_date = from_semester.period_start_date
                        #         # valid_periods = Semester.objects.filter(
                        #         #     academic_year=academic_year_id,
                        #         #     period_start_date__gte=start_date
                        #         # ).values_list('id', flat=True)
                        #         feesrecord = feesrecord.filter(fee_applied_from__in=valid_periods)
                        #     except Semester.DoesNotExist:
                        #         return Response(
                        #             {'message': f"No semester found with ID {from_semester}"},
                        #             status=status.HTTP_404_NOT_FOUND
                        #         )
                        #
                        # if to_semester:
                        #     try:
                        #         to_semester_instance = Semester.objects.get(id=to_semester)
                        #         # end_date = to_period.period_end_date
                        #         valid_semesters = Semester.objects.filter(
                        #             # academic_id=academicyearId,
                        #             period_end_date__lte=end_date
                        #         ).values_list('id', flat=True)
                        #         feesrecord = feesrecord.filter(fee_applied_from__in=valid_semesters)
                        #     except Period.DoesNotExist:
                        #         return Response(
                        #             {'message': f"No period found with ID {to_semester}"},
                        #             status=status.HTTP_404_NOT_FOUND
                        #         )
                        # Initialize fee variables
                        total_fees = Decimal('0.00')
                        total_paid_fees = Decimal('0.00')
                        discount_fees = Decimal('0.00')

                        # Calculate fee amounts
                        for fee in feesrecord:
                            if fee.element_name == 'DISCOUNT':
                                discount_fees += fee.paid_amount


                            else:
                                total_fees += fee.element_amount or 0
                                total_paid_fees += fee.paid_amount

                        remaining_fees = total_fees - total_paid_fees - discount_fees

                    else:
                        total_fees = Decimal('0.00')
                        total_paid_fees = Decimal('0.00')
                        discount_fees = Decimal('0.00')
                        remaining_fees = Decimal('0.00')

                    # Get student name
                    name_part = filter(None, [
                        RegistrationInstance.first_name,
                        RegistrationInstance.middle_name,
                        RegistrationInstance.last_name
                    ])
                    student_name = " ".join(name_part)

                    # Prepare student data
                    responsedata.append({
                        'studentId': RegistrationInstance.id,
                        'student_name': student_name,
                        'organization_id': item.organization.id,
                        'organization_description': item.organization.organization_description,
                        'branch_id': item.branch.id,
                        'branch_name': item.branch.branch_name,
                        'batch_id': item.batch.id,
                        'batch_name': item.batch.batch_code,
                        'course_id': item.course.id,
                        'course_name': item.course.course_name,
                        'department_id': item.department.id,
                        'department_description': item.department.department_description,
                        'academic_year_id': item.academic_year.id,
                        'academic_year_code': item.academic_year.academic_year_code,
                        'semester_id': item.semester.id,
                        'semester_name': item.semester.semester_description,
                        'section_id': item.section.id,
                        'section_name': item.section.section_name,

                        'college_admission_no': RegistrationInstance.college_admission_no,
                        'barcode': RegistrationInstance.barcode,
                        'fatherName': RegistrationInstance.father_name,
                        'fatherMobileNo': RegistrationInstance.father_contact_number,
                        'motherName': RegistrationInstance.mother_name,
                        'motherMobileNo': RegistrationInstance.mother_contact_number,
                        'total_fees': total_fees,
                        'total_paid': total_paid_fees,
                        'discount_fees': discount_fees,
                        'remaining_fees': remaining_fees
                    })

                # Logic to filter records where remaining_fees > 0 if showbalancefees is true
                if show_balance_fees and show_balance_fees.lower() in ['true', '1']:
                    responsedata = [data for data in responsedata if data['remaining_fees'] > 0]

                if responsedata:
                    return Response({"message": "success!!", "data": responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!!'}, status=status.HTTP_200_OK)


        except Exception as e:
            self.log_exception(request, str(e))
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='GetStudentFeeLedger',
            message=error_message,
        )


class  StudentConfirmFilterListAPIView(ListAPIView):
    queryset = StudentCourse.objects.all()
    serializer_class = studentsearchconfirmSerializer

    def list(self, request, *args, **kwargs):

        try:
            # Fetch query parameters

            serializer = self.get_serializer(data=request.query_params)
            serializer.is_valid(raise_exception=True)

            organization_id = serializer.validated_data.get('organization_id')
            branch_id = serializer.validated_data.get('branch_id')
            batch_id = serializer.validated_data.get('batch_id')
            course_id = serializer.validated_data.get('course_id')
            department_id = serializer.validated_data.get('department_id')
            academic_year_id = serializer.validated_data.get('academic_year_id')
            semester_id = serializer.validated_data.get('semester_id')
            section_id = serializer.validated_data.get('section_id')
            student_id = serializer.validated_data.get('student_id')
            status_data = serializer.validated_data.get('status_data')
            admission_no = serializer.validated_data.get('admission_no')
            barcode = serializer.validated_data.get('barcode')
            student_name = serializer.validated_data.get('student_name')
            father_name = serializer.validated_data.get('father_name')
            mother_name = serializer.validated_data.get('mother_name')
            college_admission_no = serializer.validated_data.get('college_admission_no')

            # filterdata = StudentCourse.objects.none()

            if organization_id and branch_id:
                try:
                    studentCourseConfirmList = StudentCourse.objects.filter(organization=organization_id,
                                                                            branch=branch_id,student_status__iexact='PROMOTED',
                                                                            is_active=False).order_by('-updated_at')
                except StudentCourse.DoesNotExist:
                    return Response({"message": "student course record not found !!!"},
                                    status=status.HTTP_404_NOT_FOUND)
            else:
                return Response({"message": "organization_id and branch_id is required !!!"},
                                status=status.HTTP_404_NOT_FOUND)

            # if organization_id and branch_id:
            #     filterdata = StudentCourse.objects.filter(organization=organization_id,branch=branch_id, is_active=False)

            # apply student status filter
            if batch_id:
                studentCourseConfirmList = studentCourseConfirmList.filter(batch=batch_id)

            if course_id:
                studentCourseConfirmList = studentCourseConfirmList.filter(course=course_id)

            if department_id:
                studentCourseConfirmList = studentCourseConfirmList.filter(department=department_id)

            if academic_year_id:
                studentCourseConfirmList = studentCourseConfirmList.filter(academic_year=academic_year_id)

            if semester_id:
                studentCourseConfirmList = studentCourseConfirmList.filter(semester=semester_id)

            if section_id:
                studentCourseConfirmList = studentCourseConfirmList.filter(section=section_id)

            if status_data:
                studentCourseConfirmList = studentCourseConfirmList.filter(student_status__iexact=status_data.upper())
            else:
                # if statusdata not provided
                studentCourseConfirmList = studentCourseConfirmList.filter(
                    student_status__in=["PROMOTED", "DEMOTED", "FAIL"])

            # Apply filter for a specific student
            if student_id:
                studentCourseConfirmList = studentCourseConfirmList.filter(student=student_id)

            if admission_no:
                studentCourseConfirmList = studentCourseConfirmList.filter(student__admission_no=admission_no)

            if barcode:
                studentCourseConfirmList = studentCourseConfirmList.filter(student__barcode=barcode)

            if college_admission_no:
                studentCourseConfirmList = studentCourseConfirmList.filter(
                    student__college_admission_no=college_admission_no)

            if student_name:
                name_parts = student_name.strip().split()
                if len(name_parts) == 1:
                    first = name_parts[0].strip()
                    studentCourseConfirmList = studentCourseConfirmList.filter(
                        Q(student__first_name__icontains=first) | Q(student__middle_name__icontains=first) | Q(
                            student__last_name__icontains=first))

                elif len(name_parts) == 2:  # First + Last
                    first, last = name_parts
                    studentCourseConfirmList = studentCourseConfirmList.filter(
                        Q(student__first_name__iexact=first, student__last_name__iexact=last) |
                        Q(student__first_name__iexact=first, student__middle_name__isnull=False,
                          student__last_name__iexact=last)
                    )

                elif len(name_parts) == 3:  # First + Middle + Last
                    first, middle, last = name_parts
                    studentCourseConfirmList = studentCourseConfirmList.filter(
                        student__first_name__iexact=first,
                        student__middle_name__iexact=middle,
                        student__last_name__iexact=last
                    )
                # filterdata = filterdata.filter(studentName=studentName)

            if father_name:
                studentCourseConfirmList = studentCourseConfirmList.filter(student__father_name=father_name)

            if mother_name:
                studentCourseConfirmList = studentCourseConfirmList.filter(student__mother_name=mother_name)

            # make response
            if studentCourseConfirmList:
                responsedata = []
                for item in studentCourseConfirmList:
                    # Get student name
                    name_part = filter(None, [
                        item.student.first_name,
                        item.student.middle_name,
                        item.student.last_name
                    ])
                    student_name = " ".join(name_part)
                    route = ""
                    pickup_point_id = ""
                    pickup_point_name = ""
                    pickup_point_amount = ""

                    if item.route_id:
                        route_instance = RouteMaster.objects.get(id=item.route_id, is_active=True)
                        route_detail_instance = RouteDetail.objects.get(route_master=item.route_id, is_active=True)
                        route = route_instance.transport_name
                        pickup_point = route_detail_instance.pickup_point
                        pickup_point_id = route_detail_instance.pickup_point.id
                        pickup_point_name = route_detail_instance.pickup_point.pickup_point_name
                        pickup_point_amount = route_detail_instance.pickup_point.amount
                    # if  item.route_id:
                    #     route_instance = RouteMaster.objects.get(id=item.route_id,is_active=True)
                    #     route = route_instance.transport_name
                    elif not item.route_id:
                        route = ""

                    responsedata.append(
                        {
                            "student_id": item.student.id,
                            "student_name": student_name,
                            "organization_id": item.organization.id,
                            "organization_description": item.organization.organization_description,
                            "branch_id": item.branch.id,
                            "branch_name": item.branch.branch_name,
                            "batch_id": item.batch.id,
                            "batch_code": item.batch.batch_code,
                            "course_id": item.course.id,
                            "course_name": item.course.course_name,
                            "department_id": item.department.id,
                            "department_description": item.department.department_description,
                            "academic_year_id": item.academic_year.id,
                            "academic_year_code": item.academic_year.academic_year_code,
                            "semester_id": item.semester.id,
                            "semester_code": item.semester.semester_code,
                            "section_id": item.section.id,
                            "section_name": item.section.section_name,
                            "fee_applied_from_id": item.fee_applied_from.id if item.fee_applied_from else None,
                            "fee_applied_from": item.fee_applied_from.semester_description if item.fee_applied_from else None,
                            "fee_group_id": item.fee_group.id if item.fee_group else None,
                            "fee_group": item.fee_group.fee_structure_description if item.fee_group else None,
                            "house_id": item.house.id,
                            "house": item.house.house_name,
                            "route_id": item.route_id,
                            "transport_name": route,
                            "transport_availed": item.transport_availed,
                            "choice_semester": item.choice_semester,
                            "pickup_point_id": pickup_point_id,
                            "pickup_point": pickup_point_name,
                            "transport_amount": pickup_point_amount,
                            "admission_no": item.student.admission_no,
                            "registration_no": item.student.registration_no,
                            "college_admission_no": item.student.college_admission_no,
                            "barcode": item.student.barcode,
                            "fatherName": item.student.father_name,
                            "motherName": item.student.mother_name,
                            "student_status": item.student_status,
                        }
                    )

                return Response({"message": "success!!", "data": responsedata}, status=status.HTTP_200_OK)

            else:
                return Response({"message": "No Data Found!!"}, status=status.HTTP_200_OK)

            # else:
            #     # raise ValidationError(
            #     #     {'message': 'organization_id and branch_id is required !!!'},
            #     #     code=status.HTTP_400_BAD_REQUEST
            #     # )
            #     return Response({'message': 'Organization_id and branch_id is required !!!'}, status=status.HTTP_404_NOT_FOUND)

        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='Student-Course-Confirm-Record-Filter',

            message=error_message,

        )


class GetPreviousYearRemainingAmount(ListAPIView):
    queryset = StudentFeeDetail.objects.all()
    serializer_class = StudentFeeDetailSerializer

    def list(self, request, *args, **kwargs):

        try:
            # Fetch query parameters

            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            semester_id = request.query_params.get('semester_id')
            student_id = request.query_params.get('student_id')
            is_promoted = request.query_params.get('is_promoted')

            # Student Course Instance

            # if is_promoted:
            #     if student_id:
            #         try:
            #             studentCourseInstance = StudentCourse.objects.get(student=student_id, is_active=False, is_promoted=True)
            #         except ObjectDoesNotExist:
            #             return Response({"message": "Student course record Not Found!!"}, status=status.HTTP_404_NOT_FOUND)
            #     else:
            #         return Response({"message": "student_id is required !!!"}, status=status.HTTP_404_NOT_FOUND)
            # else:
            #     if student_id:
            #         try:
            #             studentCourseInstance = StudentCourse.objects.get(student=student_id, is_active=True)
            #         except ObjectDoesNotExist:
            #             return Response({"message": "Student course record Not Found!!"}, status=status.HTTP_404_NOT_FOUND)
            #     else:
            #         return Response({"message": "student_id is required !!!"}, status=status.HTTP_404_NOT_FOUND)

            # Academic year Instance
            if semester_id:
                previous_semester_id = int(semester_id) - 1
                try:
                    semesterInstance = Semester.objects.get(id=semester_id, is_active=True)
                except ObjectDoesNotExist:
                    return Response({"message": "Semester record Not Found!!"}, status=status.HTTP_404_NOT_FOUND)
            else:
                return Response({"message": "semester_id is required !!!"}, status=status.HTTP_404_NOT_FOUND)

            # Get the academic year immediately before the current one
            previous_semester = Semester.objects.filter(
                id=previous_semester_id,
                organization=semesterInstance.organization.id,
                branch=semesterInstance.branch.id,
                # date_from__lt=semesterInstance.date_from,
                is_active=True).first()
            # ).order_by('-date_from').first()

            # check previous year exist or not
            if not previous_semester:
                return Response({"message": "No previous semester found!"}, status=status.HTTP_404_NOT_FOUND)

            # filter All fees record data based on previous academic year

            fee_records = StudentFeeDetail.objects.filter(student=student_id,
                                                          student_course__semester=previous_semester, paid='N',
                                                          is_active=True)

            # student_course=studentCourseInstance

            # Initialize totals
            total_element_amount = 0
            total_paid_amount = 0

            for record in fee_records:
                total_element_amount += record.element_amount or 0  # Handle null values
                total_paid_amount += record.paid_amount or 0  # Handle null values

            # Calculate remaining amount
            total_remaining_amount = total_element_amount - total_paid_amount

            # Make Response data
            data = {
                "student_id": student_id,
                "previous_semester_id": previous_semester.id,
                "previous_semester": previous_semester.semester_code,
                "total_element_amount": total_element_amount,
                "total_paid_amount": total_paid_amount,
                "total_remaining_amount": total_remaining_amount
            }

            return Response({"message": "success!!", "data": data}, status=status.HTTP_200_OK)




        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='previousyearamount',

            message=error_message,

        )


class GetStudentFeesDetailsPDFBasedOnStudentId(ListAPIView):
    queryset = StudentFeeDetail.objects.all()
    serializer_class = StudentFeeDetailSerializer

    def list(self, request, *args, **kwargs):
        try:
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            student_id = request.query_params.get('student_id')
            # academicyearId= self.kwargs.get('academic_year_id')

            try:
                studentCourseInstance = StudentCourse.objects.get(organization=organization_id, branch=branch_id,
                                                                  student=student_id, is_active=True)
            except ObjectDoesNotExist:
                return Response({'message': 'Student course record Not Found!'}, status=status.HTTP_404_NOT_FOUND)

            studentfeedetailsrecord = None
            try:
                studentfeedetailsrecord = StudentFeeDetail.objects.filter(organization=organization_id,
                                                                          branch=branch_id, student=student_id,
                                                                          is_active=True)
            except ObjectDoesNotExist:
                studentfeedetailsrecord = None

            discount_amount = 0
            total_fees = 0
            total_paid = 0
            feesdetails = []

            # If student fees record exist
            if studentfeedetailsrecord:
                for stdfees in studentfeedetailsrecord:
                    semester_id = None
                    semester_name = None
                    
                    # PRIORITY 1: use semester field (Most reliable)
                    if stdfees.semester:
                        try:
                            semesterInstance = stdfees.semester
                            semester_id = semesterInstance.id
                            semester_name = semesterInstance.semester_description
                        except Exception:
                            pass

                    # PRIORITY 2: Fallback to fee_applied_from if semester is missing
                    if not semester_name and stdfees.fee_applied_from:
                        try:
                            semesterInstance = stdfees.fee_applied_from
                            semester_id = semesterInstance.id
                            semester_name = semesterInstance.semester_description
                        except Exception:
                            pass
                    
                    # Fallback string if still nothing
                    if not semester_name:
                         semester_name = "-"

                    data = {
                        'element_name': stdfees.element_name,
                        'fee_applied_from': semester_id,
                        'semester_name': semester_name,
                        'total_amount': stdfees.element_amount,
                        'paid_amount': stdfees.paid_amount,
                        'remaining_amount': f'{stdfees.element_amount - stdfees.paid_amount}'

                    }
                    if stdfees.element_name == "DISCOUNT":
                        discount_amount += stdfees.element_amount
                    else:
                        total_fees += stdfees.element_amount
                        total_paid += stdfees.paid_amount

                    feesdetails.append(data)

            # make response data
            name_part = filter(None, [
                studentCourseInstance.student.first_name,
                studentCourseInstance.student.middle_name,
                studentCourseInstance.student.last_name
            ])
            student_name = " ".join(name_part)
            responsedata = {
                'studentname': student_name,
                'academic_year_id': studentCourseInstance.academic_year.id,
                'session_code': studentCourseInstance.academic_year.academic_year_code,
                'course_id': studentCourseInstance.course.id,
                'course_name': studentCourseInstance.course.course_name,
                'section_id': studentCourseInstance.section.id,
                'section_name': studentCourseInstance.section.section_name,
                'fathername': studentCourseInstance.student.father_name,
                'mothername': studentCourseInstance.student.mother_name,
                'admission_no': studentCourseInstance.student.admission_no,
                'barcode': studentCourseInstance.student.barcode,
                'feesdetails': feesdetails,
                'total_fees': total_fees,
                'total_paid': total_paid,
                'total_discount': discount_amount,
                'remaining_amount': total_fees - total_paid - discount_amount

            }

            return Response({'message': 'success', 'data': responsedata}, status=status.HTTP_200_OK)





        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='StudentFeeDetail',

            message=error_message,

        )


class GetStudentFeeDueReceiptListAPIView(ListAPIView):
    queryset = StudentFeeDetail.objects.all()
    serializer_class = StudentFeeDueReceiptSerializer

    def list(self, request, *args, **kwargs):
        try:
            # academicyearId = request.query_params.get('academic_year_id')
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            studentIds = request.query_params.get('studentIds')
            fee_applied_from = request.query_params.get('fee_applied_from')

            # Iterate student Ids to process data
            finalresponsedata = []

            # Convert stidentIds string to list
            # Parse studentIds to a list of integers
            try:
                import json
                studentIds = json.loads(studentIds)  # Convert string to list
                if not isinstance(studentIds, list):
                    raise ValueError("Invalid format for studentIds")
            except (ValueError, json.JSONDecodeError) as e:
                return Response(
                    {'error': 'Invalid studentIds format. Expected a list of integers.'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            for stdIds in studentIds:
                try:
                    studentcourseInstance = StudentCourse.objects.get(organization=organization_id, branch=branch_id,
                                                                      student_id=stdIds, is_active=True)
                except ObjectDoesNotExist:
                    return Response({'message': 'Student record Not Found'}, status=status.HTTP_404_NOT_FOUND)

                # Initialize fees variables
                current_semester_fees = 0
                paid_semester_fees = 0
                discount = 0

                # Initialize previous fees variables
                total_previous_fees = 0
                total_previous_paid = 0
                total_previous_discount_amount = 0

                # Fetch student fees record
                try:
                    studentfeesrecord = StudentFeeDetail.objects.filter(
                        organization=organization_id,
                        branch=branch_id,
                        student=stdIds,
                        fee_applied_from=fee_applied_from,
                        # academic_year_id=academicyearId,
                        is_active=True
                    )
                except ObjectDoesNotExist:
                    studentfeesrecord = None

                if studentfeesrecord:
                    for item in studentfeesrecord:
                        if item.element_name == "DISCOUNT":
                            discount += item.element_amount
                        else:
                            current_semester_fees += item.element_amount
                            paid_semester_fees += item.paid_amount

                # fetch all semesters through course
                semester_ids = Semester.objects.filter(organization=organization_id, branch=branch_id,
                                                       batch=studentcourseInstance.batch,
                                                       course=studentcourseInstance.course,
                                                       department=studentcourseInstance.department,
                                                       is_active=True).values_list('id', flat=True)
                previous_semester_ids = []
                if semester_ids and fee_applied_from:
                    for id in semester_ids:
                        if id < int(fee_applied_from):
                            previous_semester_ids.append(id)
                        else:
                            continue
                # Fetch current semester based on feeappfrom
                try:
                    current_semester = Semester.objects.get(id=fee_applied_from, organization=organization_id,
                                                            branch=branch_id, is_active=True)
                except ObjectDoesNotExist:
                    return Response({'message': 'Semester record not found'}, status=status.HTTP_404_NOT_FOUND)

                # Filter previous semester
                # previous_semester = Semester.objects.filter(
                #     # academic_id=academicyearId,
                #     is_active=True,
                #     id__in=current_semester.id
                # )

                # Calculate fees for all previous periods
                # for prd in previous_semester:
                for previous_semester_id in previous_semester_ids:
                    studentfees = StudentFeeDetail.objects.filter(
                        student_id=stdIds,
                        # academic_year_id=academicyearId,
                        fee_applied_from=previous_semester_id,
                        is_active=True
                    )
                    for fees in studentfees:
                        if fees.element_name == "DISCOUNT":
                            total_previous_discount_amount += fees.element_amount
                        else:
                            total_previous_fees += fees.element_amount
                            total_previous_paid += fees.paid_amount

                # Fetch fees with NO semester (Global/Legacy dues)
                global_fees = StudentFeeDetail.objects.filter(
                    student_id=stdIds,
                    fee_applied_from__isnull=True,
                    is_active=True
                )
                for fees in global_fees:
                    if fees.element_name == "DISCOUNT":
                        total_previous_discount_amount += fees.element_amount
                    else:
                        total_previous_fees += fees.element_amount
                        total_previous_paid += fees.paid_amount

                # Organization & branch Instance
                organizationInstance = studentcourseInstance.organization
                branchInstance = studentcourseInstance.branch

                # Make response data
                name_part = filter(None, [
                    studentcourseInstance.student.first_name,
                    studentcourseInstance.student.middle_name,
                    studentcourseInstance.student.last_name
                ])
                student_name = " ".join(name_part)

                data = {
                    "organization_id": organizationInstance.id,
                    "organizationname": organizationInstance.organization_code,
                    "branch_id": branchInstance.id,
                    "branch_name": branchInstance.branch_name,
                    "studentId": studentcourseInstance.student.id,
                    "studentname": student_name,
                    "fathername": studentcourseInstance.student.father_name,
                    "course_name": studentcourseInstance.course.course_name,
                    "section_name": studentcourseInstance.section.section_name,
                    "college_admission_no": studentcourseInstance.student.college_admission_no,
                    "barcode": studentcourseInstance.student.barcode,
                    "current_semester": current_semester.semester_description,
                    "current_semester_fees": current_semester_fees - paid_semester_fees - discount,
                    "pending_fees": total_previous_fees - total_previous_paid - total_previous_discount_amount,
                    "current_month_discount": discount,
                    "grand_total_fees": current_semester_fees - paid_semester_fees - discount +
                                        total_previous_fees - total_previous_paid - total_previous_discount_amount,
                    "total_assigned_fees": current_semester_fees + total_previous_fees
                }
                finalresponsedata.append(data)

            return Response({'message': 'success', "data": finalresponsedata}, status=status.HTTP_200_OK)


        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='StudentFeeDueReceiptDetails',

            message=error_message,

        )


class GetStudentFeeBalanceReceiptListAPIView(ListAPIView):
    queryset = StudentFeeReceiptDetail.objects.all()
    serializer_class = StudentFeeBalanceReceiptSerializer

    def list(self, request, *args, **kwargs):
        try:

            # academicyearId = request.query_params.get('academic_year_id')
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            batch_id = request.query_params.get('batch_id')
            course_id = request.query_params.get('course_id')
            department_id = request.query_params.get('department_id')
            studentIds = request.query_params.get('studentIds')
            fee_due_from = request.query_params.get('fee_due_from')
            fee_due_to = request.query_params.get('fee_due_to')

            # print(academicyearId,studentIds,feeappfrom,feeappto)

            # if not academicyearId:
            #     return Response({'message': 'Choose an academic year'}, status=status.HTTP_400_BAD_REQUEST)

            if not organization_id:
                return Response({'message': 'organization_id is required !!!'}, status=status.HTTP_400_BAD_REQUEST)

            if not branch_id:
                return Response({'message': 'branch_id is required !!!'}, status=status.HTTP_400_BAD_REQUEST)

            if not studentIds:
                return Response({'message': 'Choose at least one student'}, status=status.HTTP_400_BAD_REQUEST)

            # Parse studentIds to a list
            try:
                import json
                studentIds = json.loads(studentIds)  # Convert string to list
                if not isinstance(studentIds, list):
                    raise ValueError("Invalid format for studentIds")
            except (ValueError, json.JSONDecodeError):
                return Response(
                    {'error': 'Invalid studentIds format. Expected a list of integers.'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            # print(studentIds,type(studentIds))

            semester_list = Semester.objects.filter(organization=organization_id, branch=branch_id,
                                                    course=course_id, department=department_id).order_by('id')
            
            if fee_due_from and fee_due_to:
                # Validate sorting orders
                if fee_due_from > fee_due_to:
                    return Response(
                        {
                            'message': 'fee_due_from cannot be greater than fee_due_to'},
                        status=status.HTTP_400_BAD_REQUEST
                    )
                semester_list_filtered = semester_list.filter(id__range=(fee_due_from, fee_due_to))
            else:
                 # If params missing, use all semesters
                 semester_list_filtered = semester_list

            if not semester_list_filtered.exists():
                return Response(
                    {'message': 'No semester found'},
                    status=status.HTTP_404_NOT_FOUND
                )

            # Get the names of the filtered periods
            semester_names = list(semester_list_filtered.values_list('semester_description',
                                                                     flat=True))  # Assuming 'period_name' is the field for the period's name

            # If you want to store the names as a comma-separated string
            semester_names_string = ", ".join(semester_names)

            # get currect Academic year
            # try:
            #     current_academic_year= AcademicYear.objects.get(id=academicyearId,is_active=True)
            # except ObjectDoesNotExist:
            #     return Response({'message':'academic year not found!'},status=status.HTTP_404_NOT_FOUND)
            #
            # # Get prevoius year academic year
            # previous_academic_year = (
            #     AcademicYear.objects.filter(date_to__lt=current_academic_year.date_from, is_active=True)
            #     .order_by('-date_to')
            #     .first()
            # )

            finalresponsedata = []
            receiptNoList = []
            receiptDateList = []

            for stdId in studentIds:

                # Initialize dictionaries for aggregating the amounts
                elementList = {}  # To store the amounts for each element name
                totalFees = 0
                paidFees = 0
                discountFees = 0
                # student class instance
                try:
                    student_course_instance = StudentCourse.objects.get(student_id=stdId, is_active=True)
                except ObjectDoesNotExist:
                    return Response({'message': 'student course Not Found!!'}, status=status.HTTP_404_NOT_FOUND)

                try:
                    # Query the StudentFeeDetail model for the student
                    student_fee_details_records = StudentFeeDetail.objects.filter(
                        student_id=stdId,
                        fee_applied_from__in=semester_list_filtered,
                        is_active=True  # Only include active records
                    )

                    if student_fee_details_records.exists():

                        for fee_record in student_fee_details_records:
                            # Check element exist in element list or not
                            if fee_record.element_name not in elementList:
                                elementList[fee_record.element_name] = fee_record.element_amount
                            else:
                                elementList[fee_record.element_name] += fee_record.element_amount

                            # Check if element_name is "DISCOUNT"
                            if fee_record.element_name == "DISCOUNT":
                                discountFees += fee_record.element_amount

                            if fee_record.element_name == "PREVIOUS YEAR FEES":
                                continue

                            else:
                                totalFees += fee_record.element_amount
                                paidFees += fee_record.paid_amount

                            # Receipt Details Retrieval
                            try:
                                StudentFeeReceiptDetailRecords = StudentFeeReceiptDetail.objects.filter(
                                    fee_detail_id=fee_record.id, is_active=True
                                ).select_related('receipt')  # Fetch the full receipt object
                            except StudentFeeReceiptDetail.DoesNotExist:
                                StudentFeeReceiptDetailRecords = []

                            if StudentFeeReceiptDetailRecords.exists():
                                for receiptdetails in StudentFeeReceiptDetailRecords:
                                    if receiptdetails.receipt:
                                        # Append to receiptNoList if receipt_no is not already in the list
                                        if receiptdetails.receipt.receipt_no not in receiptNoList:
                                            receiptNoList.append(receiptdetails.receipt.receipt_no)
                                        # Append to receiptDateList if receipt_date is not already in the list
                                        if receiptdetails.receipt.receipt_date not in receiptDateList:
                                            receiptDateList.append(receiptdetails.receipt.receipt_date)



                except ObjectDoesNotExist:
                    continue  # If no records found fo
                # try:
                #     studentpreviousyearfeesrecord = StudentFeeDetail.objects.filter(student_id=stdId,academic_year_id=previous_academic_year.id,is_active=True)
                # except ObjectDoesNotExist:
                #     studentpreviousyearfeesrecord= None

                # previous_year_fees = 0
                # previous_year_paid = 0
                # if studentpreviousyearfeesrecord:
                #     for previousfees in studentpreviousyearfeesrecord:
                #         previous_year_fees+= previousfees.element_amount
                #         previous_year_paid+= previousfees.paid_amount
                #
                # else:
                #     previous_year_fees=0
                #     previous_year_paid=0

                # Construct response for the current student
                student_name_parts = filter(
                    None,
                    [
                        student_course_instance.student.first_name,
                        student_course_instance.student.middle_name,
                        student_course_instance.student.last_name,
                    ],
                )
                student_name = " ".join(student_name_parts)

                # Get student address details
                address_instance = None  # Initialize to prevent UnboundLocalError
                try:
                    address_instance = Address.objects.get(
                        reference_id=stdId, usertype="STUDENT", is_active=True
                    )
                    address_parts = filter(
                        None,
                        [
                            address_instance.permanent_address,
                            address_instance.permanent_pincode,
                            address_instance.permanent_city,
                            address_instance.permanent_state,
                            address_instance.permanent_country,
                        ],
                    )
                    full_address = " ".join(address_parts)
                except ObjectDoesNotExist:
                    full_address = "N/A"

                data = {
                    "studentId": stdId,
                    "studentName": student_name,
                    "schoolAdmissionNo": student_course_instance.student.college_admission_no,
                    "barcode": student_course_instance.student.barcode,
                    "className": student_course_instance.course.course_name,
                    "sectionName": student_course_instance.section.section_name,
                    "fatherName": student_course_instance.student.father_name,
                    "addressDetails": full_address,
                    "phoneNumber": address_instance.permanent_phone_number if address_instance else "N/A",
                    "category": student_course_instance.student.category.category_name if student_course_instance.student.category else "N/A",
                    "receiptNo": receiptNoList,
                    "receiptDate": receiptDateList,
                    "Fees_Period": semester_names_string,
                    "totalFees": totalFees,
                    "paidFees": paidFees,
                    "remainingFees": totalFees - paidFees - discountFees,
                    "elementList": elementList,
                    # "previous_year_fees": previous_year_fees,
                    # "previous_year_paid": previous_year_paid,
                    # "previous_year_remaining_fees": previous_year_fees-previous_year_paid
                }

                finalresponsedata.append(data)

            return Response({'message': 'success', 'data': finalresponsedata}, status=status.HTTP_200_OK)


        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='StudentFeeBalanceReceiptDetails',

            message=error_message,

        )


class GetStudentFeeDetailSemesterWiseListAPIView(ListAPIView):
    queryset = StudentFeeDetail.objects.all()
    serializer_class = StudentFeeDueReceiptSerializer

    def list(self, request, *args, **kwargs):
        try:
            # serializer = self.get_serializer(data=request.data)
            # serializer.is_valid(raise_exception=True)
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            # academicyearId = request.query_params.get('academic_year_id')
            studentIds = request.query_params.get('studentIds')
            fee_due_from = request.query_params.get('fee_due_from')
            fee_due_to = request.query_params.get('fee_due_to')

            # print(academicyearId,studentIds,feeappfrom,feeappto)

            if not (organization_id and branch_id):
                return Response({'message': 'organization_id and branch_id is required !!!'},
                                status=status.HTTP_400_BAD_REQUEST)

            if not studentIds:
                return Response({'message': 'Choose at least one student'}, status=status.HTTP_400_BAD_REQUEST)

            if not fee_due_from:
                return Response({'message': 'Choose fee_due_from'}, status=status.HTTP_400_BAD_REQUEST)

            if not fee_due_to:
                return Response({'message': 'Choose fee_due_to'}, status=status.HTTP_400_BAD_REQUEST)

            # Parse studentIds to a list
            try:

                studentIds = json.loads(studentIds)  # Convert string to list
                if not isinstance(studentIds, list):
                    raise ValueError("Invalid format for studentIds")
            except (ValueError, json.JSONDecodeError):
                return Response(
                    {'error': 'Invalid studentIds format. Expected a list of integers.'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            # get Student Fees Details based on studentId,academic year & month
            finalresponsedata = []
            for stdId in studentIds:
                # student class instance
                try:
                    student_course_instance = StudentCourse.objects.get(organization=organization_id, branch=branch_id,
                                                                        student_id=stdId, is_active=True)
                except ObjectDoesNotExist:
                    return Response({'message': 'student course Not Found!!'}, status=status.HTTP_404_NOT_FOUND)

                # Initialize dictionaries for aggregating the amounts
                elementList = {}  # To store the amounts for each element name
                totalFees = 0
                totalPaid = 0
                totaldiscount = 0
                SemesterFees = 0
                SemesterpaidFees = 0
                SemesterdiscountFees = 0

                # fetch student fee details based on academic year wise

                try:
                    studentfeedetailsrecord = StudentFeeDetail.objects.filter(organization=organization_id,
                                                                              branch=branch_id, student_id=stdId,
                                                                              is_active=True)
                except ObjectDoesNotExist:
                    studentfeedetails = None

                if studentfeedetailsrecord:

                    for record in studentfeedetailsrecord:

                        if record.element_name == "DISCOUNT":
                            totaldiscount += record.element_amount
                        else:
                            totalFees += record.element_amount
                            totalPaid += record.paid_amount
                else:
                    pass

                # Get Month wise student fees record
                try:
                    studentSemesterfeesrecord = StudentFeeDetail.objects.filter(student_id=stdId,
                                                                                fee_applied_from__id__range=(
                                                                                    fee_due_from, fee_due_to),
                                                                                is_active=True)
                except ObjectDoesNotExist:
                    studentmonthfeesrecord = None

                # period month
                try:
                    semesterInstance = Semester.objects.filter(id__range=(fee_due_from, fee_due_to), is_active=True)
                    semester_descriptions_string = semesterInstance.values_list('semester_description', flat=True)
                except ObjectDoesNotExist:
                    return Response({'No semester found'}, status=status.HTTP_404_NOT_FOUND)

                if studentSemesterfeesrecord:
                    receiptNoList = []
                    receiptDateList = []
                    for record in studentSemesterfeesrecord:

                        # Check element exist in element list or not
                        if record.element_name not in elementList:
                            elementList[record.element_name] = record.element_amount
                        else:
                            elementList[record.element_name] += record.element_amount

                        if record.element_name == "DISCOUNT":
                            SemesterdiscountFees += record.element_amount
                        else:
                            SemesterFees += record.element_amount
                            SemesterpaidFees += record.paid_amount

                        if record.paid_amount:
                            try:
                                StudentFeeReceiptDetailsRecord = StudentFeeReceiptDetail.objects.filter(
                                    fee_detail_id=record.id, is_active=True)
                            except StudentFeeReceiptDetail.DoesNotExists:
                                StudentFeeReceiptDetailsRecord = []

                            if StudentFeeReceiptDetailsRecord.exists():
                                for receiptdetails in StudentFeeReceiptDetailsRecord:
                                    if receiptdetails.receipt_id:
                                        if receiptdetails.receipt_id.receipt_no not in receiptNoList:
                                            receiptNoList.append(receiptdetails.receipt_id.receipt_no)

                                        if receiptdetails.receipt_id.receipt_date not in receiptDateList:
                                            receiptDateList.append(receiptdetails.receipt_id.receipt_date)


                else:
                    pass

                # Construct response for the current student
                student_name_parts = filter(
                    None,
                    [
                        student_course_instance.student.first_name,
                        student_course_instance.student.middle_name,
                        student_course_instance.student.last_name,
                    ],
                )
                student_name = " ".join(student_name_parts)

                # Get student address details
                try:
                    address_instance = Address.objects.get(
                        reference_id=stdId, usertype="STUDENT", is_active=True
                    )
                    address_parts = filter(
                        None,
                        [
                            address_instance.permanent_address,
                            address_instance.permanent_pincode,
                            address_instance.permanent_city,
                            address_instance.permanent_state,
                            address_instance.permanent_country,
                        ],
                    )
                    full_address = " ".join(address_parts)
                except ObjectDoesNotExist:
                    full_address = "N/A"

                data = {
                    "studentId": stdId,
                    "studentName": student_name,
                    "schoolAdmissionNo": student_course_instance.student.college_admission_no,
                    "barcode": student_course_instance.student.barcode,
                    "courseName": student_course_instance.course.course_name,
                    "sectionName": student_course_instance.section.section_name,
                    "fatherName": student_course_instance.student.father_name,
                    "addressDetails": full_address,
                    "phoneNumber": address_instance.permanent_phone_number if address_instance else "N/A",
                    "category": student_course_instance.student.category.category_name,
                    "receiptNo": receiptNoList,
                    "receiptDate": receiptDateList,
                    "fee_semester": semester_descriptions_string,
                    # "fee_semester": semesterInstance.semester_description,
                    "total_fees": totalFees,
                    "total_paid": totalPaid,
                    "total_remaining": totalFees - totalPaid - totaldiscount,
                    "semester_fees": SemesterFees,
                    "semester_fee_paid": SemesterpaidFees,
                    "semester_remaining_paid": SemesterFees - SemesterpaidFees - SemesterdiscountFees,
                    "element_list": elementList
                }

                finalresponsedata.append(data)

            return Response({'message': 'success', 'data': finalresponsedata}, status=status.HTTP_200_OK)

        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='StudentFeeBalanceReceiptDetails',

            message=error_message,

        )


class GetStudentPaymentMethodWiseFeeListAPIView(ListAPIView):
    queryset = StudentFeeReceiptHeader.objects.all()
    serializer_class = StudentPaymentMethodWiseFeesSerializer

    def list(self, request, *args, **kwargs):
        try:
            print('.')
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            # academicyearId = request.query_params.get('academic_year_id')
            studentIds = request.query_params.get('studentIds')

            # print(academicyearId,studentIds,feeappfrom,feeappto)

            if not (organization_id and branch_id):
                return Response({'message': 'organization_id and branch_id is required !!!'},
                                status=status.HTTP_400_BAD_REQUEST)

            if not studentIds:
                return Response({'message': 'Choose at least one student'}, status=status.HTTP_400_BAD_REQUEST)

            finalresponsedata = []
            # Parse studentIds to a list
            try:
                studentIds = json.loads(studentIds)  # Convert string to list
                if not isinstance(studentIds, list):
                    raise ValueError("Invalid format for studentIds")
            except (ValueError, json.JSONDecodeError):
                return Response(
                    {'error': 'Invalid studentIds format. Expected a list of integers.'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            for stdIds in studentIds:

                try:
                    studentcourseInstance = StudentCourse.objects.get(organization=organization_id, branch=branch_id,
                                                                      student_id=stdIds, is_active=True)
                except ObjectDoesNotExist:
                    return Response({'message': 'Student course record Not found!'}, status=status.HTTP_404_NOT_FOUND)

                receiptNo = []
                try:
                    stdFeeReceiptRecords = StudentFeeReceiptHeader.objects.filter(student_id=stdIds,
                                                                                  organization=organization_id,
                                                                                  branch=branch_id, is_active=True)
                except ObjectDoesNotExist:
                    stdFeeReceiptRecords = []

                # Dictionary to hold total amounts by payment method for the student
                payment_method_totals = defaultdict(float)

                if stdFeeReceiptRecords:
                    for record in stdFeeReceiptRecords:
                        try:
                            # Fetch the active payment instances for the receipt
                            stdPaymentInstances = StudentPayment.objects.filter(
                                receipt_id=record.id,
                                is_active=True
                            )

                            # Aggregate amount by payment method
                            for payment in stdPaymentInstances:
                                payment_method_name = payment.payment_method.payment_method
                                payment_method_totals[payment_method_name] += float(payment.amount)

                            # add receipt no
                            receiptNo.append(record.receipt_no)
                        except ObjectDoesNotExist:
                            return Response({'message': 'Student payment receipt not found!'},
                                            status=status.HTTP_404_NOT_FOUND)
                # Construct response for the current student
                student_name_parts = filter(
                    None,
                    [
                        studentcourseInstance.student.first_name,
                        studentcourseInstance.student.middle_name,
                        studentcourseInstance.student.last_name,
                    ],
                )
                student_name = " ".join(student_name_parts)
                data = {
                    "studentId": stdIds,
                    "receiptNo": receiptNo,
                    "college_admission_no": studentcourseInstance.student.college_admission_no,
                    "studentname": student_name,
                    "course_name": studentcourseInstance.course.course_name,
                    "department_name": studentcourseInstance.department.department_description,
                    "payment_method_totals": payment_method_totals
                }

                finalresponsedata.append(data)
            return Response({'message': 'success', 'data': finalresponsedata}, status=status.HTTP_200_OK)

        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='StudentPaymentMethodWiseReceiptDetails',

            message=error_message,

        )


class GetStudentperiodwiseFeeListAPIView(ListAPIView):
    queryset = StudentFeeReceiptHeader.objects.all()
    serializer_class = studentperiodwiseSerializer

    def list(self, request, *args, **kwargs):
        try:

            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            # academicyearId = request.query_params.get('academic_year_id')
            studentIds = request.query_params.get('studentIds')
            fee_due_from = request.query_params.get('fee_due_from')
            fee_due_to = request.query_params.get('fee_due_to')

            # print(academicyearId,studentIds,feeappfrom,feeappto)

            if not (organization_id and branch_id):
                return Response({'message': 'organization_id and branch_id is required !!!'},
                                status=status.HTTP_400_BAD_REQUEST)

            # if not academicyearId:
            #     return Response({'message': 'Choose an academic year'}, status=status.HTTP_400_BAD_REQUEST)

            if not studentIds:
                return Response({'message': 'Choose at least one student'}, status=status.HTTP_400_BAD_REQUEST)

            if not fee_due_from:
                return Response({'message': 'fee_due_from is required !!!'}, status=status.HTTP_400_BAD_REQUEST)

            if not fee_due_to:
                return Response({'message': 'fee_due_to is required !!!'}, status=status.HTTP_400_BAD_REQUEST)

            finalresponsedata = []

            # Parse studentIds to a list

            try:
                studentIds = json.loads(studentIds)  # Convert string to list
                if not isinstance(studentIds, list):
                    raise ValueError("Invalid format for studentIds")
            except (ValueError, json.JSONDecodeError):
                return Response(
                    {'error': 'Invalid studentIds format. Expected a list of integers.'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            # Fetch fee elements with element_type == 'P'
            fee_elements = FeeElementType.objects.filter(
                Q(is_active=True) & Q(element_type='S')
                # Q(is_active=True) & Q(element_type='P')
            ).values_list('element_name', flat=True)

            # # Initialize the element_balance dictionary
            # element_balance = {element.element_name: 0.00 for element in fee_elements}

            for stdIds in studentIds:
                try:
                    studentcourseInstance = StudentCourse.objects.get(organization=organization_id, branch=branch_id,
                                                                      student_id=stdIds, is_active=True)
                except ObjectDoesNotExist:
                    return Response({'message': 'Student course record Not found!'}, status=status.HTTP_404_NOT_FOUND)

                # Filter the student fees record based on condition
                StudentFeesRecord = StudentFeeDetail.objects.filter(
                    organization=organization_id, branch=branch_id,
                    student_id=stdIds,
                    # academic_year_id=academicyearId,
                    fee_applied_from__gte=fee_due_from,
                    fee_applied_from__lte=fee_due_to
                )

                # Receipt No and Receipt date

                ReceiptNo = []
                ReceiptDate = []

                # Dictionary to store element-wise monthly amounts
                semester_element_balance = {}

                if StudentFeesRecord:
                    for record in StudentFeesRecord:
                        if record.element_name in fee_elements:
                            try:
                                semesterInstance = Semester.objects.get(id=record.fee_applied_from.id)
                            except Semester.DoesNotExist:
                                continue

                            if semesterInstance and semesterInstance.semester_description:
                                if semesterInstance.semester_description not in semester_element_balance:
                                    semester_element_balance[semesterInstance.semester_description] = {}

                                if record.element_name not in semester_element_balance[
                                    semesterInstance.semester_description]:
                                    semester_element_balance[semesterInstance.semester_description][
                                        record.element_name] = 0.00

                                if record.paid_amount > 0:

                                    semester_element_balance[semesterInstance.semester_description][
                                        record.element_name] += float(record.paid_amount)

                                    StudentFeeReceiptDetailRecords = StudentFeeReceiptDetail.objects.filter(
                                        fee_detail_id=record.id, is_active=True)

                                    if StudentFeeReceiptDetailRecords:
                                        for item in StudentFeeReceiptDetailRecords:
                                            if item.receipt_no not in ReceiptNo:
                                                ReceiptNo.append(item.receipt_no)
                                            if item.receipt_id.receipt_date not in ReceiptDate:
                                                ReceiptDate.append(item.receipt_date)



                        else:
                            continue

                # Construct response for the current student
                student_name_parts = filter(
                    None,
                    [
                        studentcourseInstance.student.first_name,
                        studentcourseInstance.student.middle_name,
                        studentcourseInstance.student.last_name,
                    ],
                )
                student_name = " ".join(student_name_parts)

                # Get student address details
                try:
                    address_instance = Address.objects.get(
                        reference_id=stdIds, usertype="STUDENT", is_active=True
                    )
                    address_parts = filter(
                        None,
                        [
                            address_instance.permanent_address,
                            address_instance.permanent_pincode,
                            address_instance.permanent_city,
                            address_instance.permanent_state,
                            address_instance.permanent_country,
                        ],
                    )
                    full_address = " ".join(address_parts)
                except ObjectDoesNotExist:
                    full_address = "N/A"

                data = {
                    "studentId": stdIds,
                    "studentname": student_name,
                    "college_admission_no": studentcourseInstance.student.college_admission_no,
                    "barcode": studentcourseInstance.student.barcode,
                    "course_name": studentcourseInstance.course.course_name,
                    "section_name": studentcourseInstance.section.section_name,
                    "fathername": studentcourseInstance.student.father_name,
                    "address": full_address,
                    "phonenumber": studentcourseInstance.student.father_contact_number,
                    "category": studentcourseInstance.student.category.category_name,
                    "ReceiptNo": ReceiptNo,
                    "ReceiptDate": ReceiptDate,
                    "feedetails": semester_element_balance
                }
                finalresponsedata.append(data)

            return Response({"message": "success", "data": finalresponsedata}, status=status.HTTP_200_OK)


        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='StudentPaymentMethodWiseReceiptDetails',

            message=error_message,

        )


# Manish sir API'S

class StudentCertificateCreateAPIView(CreateAPIView):
    # serializer_class = StudentCertificateSerializer

    def create(self, request, *args, **kwargs):
        try:
            certificate_type = request.query_params.get('certificate_type')
            if certificate_type == 'TC':
                # serializer_class = StudentTransferCertificateSerializer
                serializer = StudentTCSerializer(data = request.data)
                if serializer.is_valid():
                    data = serializer.data
                    student_instance = StudentRegistration.objects.get(id=data.get('student_id'))
                    student_transfer_certificate_last_instance = StudentTransferCertificate.objects.last()
                    if student_transfer_certificate_last_instance:
                        last_tc_number = student_transfer_certificate_last_instance.tc_number
                        last_tc_number = last_tc_number.split("/")[-1]
                        tc_number = f"{student_instance.organization.organization_code}/{student_instance.branch.branch_code}/{student_instance.batch.batch_code}/tc/{int(last_tc_number)+1}"
                    else:
                        tc_number = f"{student_instance.organization.organization_code}/{student_instance.branch.branch_code}/{student_instance.batch.batch_code}/tc/{1}"

                    student_transfer_certificate_instance = StudentTransferCertificate.objects.filter(student_id=data.get('student_id'))
                    if student_transfer_certificate_instance:
                        return Response({"message":"transfer certificate already issued !!!"}, status=status.HTTP_200_OK)
                    else:
                        StudentTransferCertificate.objects.create(
                            organization=student_instance.organization,
                            branch=student_instance.branch,
                            student = student_instance,
                            tc_number = tc_number,
                            issue_date = data.get('issue_date'),
                            reason_of_leaving = data.get('reason_of_leaving'),
                            student_behaviour = data.get('student_behaviour'),
                            readmission_eligibility = data.get('readmission_eligibility'),
                            certificate_status = data.get('certificate_status'),
                            created_at = datetime.now(),
                            created_by = 1
                        )
                        return Response({"message":"transfer certificate created."}, status=status.HTTP_200_OK)
                else:
                    return Response({"message":serializer.error_messages},status=status.HTTP_400_BAD_REQUEST)

            elif certificate_type == 'CC':
                # serializer_class = StudentCharacterCertificateSerializer
                serializer = StudentCCSerializer(data = request.data)
                if serializer.is_valid():
                    data = serializer.data
                    student_instance = StudentRegistration.objects.get(id=data.get('student_id'))
                    student_character_certificate_last_instance = StudentCharacterCertificate.objects.last()
                    if student_character_certificate_last_instance:
                        last_cc_number = student_character_certificate_last_instance.cc_number
                        last_cc_number = last_cc_number.split("/")[-1]
                        cc_number = f"{student_instance.organization.organization_code}/{student_instance.branch.branch_code}/{student_instance.batch.batch_code}/cc/{int(last_cc_number) + 1}"
                    else:
                        cc_number = f"{student_instance.organization.organization_code}/{student_instance.branch.branch_code}/{student_instance.batch.batch_code}/cc/{1}"

                    student_character_certificate_instance = StudentCharacterCertificate.objects.filter(
                        student_id=data.get('student_id'))
                    if student_character_certificate_instance:
                        return Response({"message":"character certificate already issued !!!"}, status=status.HTTP_200_OK)
                    else:
                        StudentCharacterCertificate.objects.create(
                            organization=student_instance.organization,
                            branch=student_instance.branch,
                            student=student_instance,
                            cc_number=cc_number,
                            issue_date=data.get('issue_date'),
                            student_behaviour=data.get('student_behaviour'),
                            certificate_status=data.get('certificate_status'),
                            created_at=datetime.now(),
                            created_by=1
                        )
                        return Response({"message":"success"}, status=status.HTTP_200_OK)

                else:
                    return Response({"message": serializer.error_messages}, status=status.HTTP_400_BAD_REQUEST)

            elif certificate_type.upper() == 'BC':
                # serializer_class = StudentBonafideCertificateSerializer
                serializer = StudentBCSerializer(data = request.data)
                if serializer.is_valid():
                    data = serializer.data
                    student_instance = StudentRegistration.objects.get(id=data.get('student_id'))
                    student_bonafide_certificate_last_instance = StudentBonafideCertificate.objects.last()
                    if student_bonafide_certificate_last_instance:
                        last_bc_number = student_bonafide_certificate_last_instance.bc_number
                        last_bc_number = last_bc_number.split("/")[-1]
                        bc_number = f"{student_instance.organization.organization_code}/{student_instance.branch.branch_code}/{student_instance.batch.batch_code}/bc/{int(last_bc_number) + 1}"
                    else:
                        bc_number = f"{student_instance.organization.organization_code}/{student_instance.branch.branch_code}/{student_instance.batch.batch_code}/bc/{1}"

                    student_bonafide_certificate_instance = StudentBonafideCertificate.objects.filter(
                        student_id=data.get('student_id'))

                    if student_bonafide_certificate_instance:
                        return Response({"message":"bonafide certificate already issued !!!"}, status=status.HTTP_200_OK)
                    else:
                        StudentBonafideCertificate.objects.create(
                            organization=student_instance.organization,
                            branch=student_instance.branch,
                            student=student_instance,
                            bc_number=bc_number,
                            issue_date=data.get('issue_date'),
                            purpose = data.get('purpose'),
                            certificate_status=data.get('certificate_status'),
                            created_at=datetime.now(),
                            created_by=1
                        )
                        return Response({"message": "success"}, status=status.HTTP_200_OK)
                else:
                    return Response({"message": serializer.error_messages}, status=status.HTTP_400_BAD_REQUEST)

            elif certificate_type.upper() == 'FC':
            # serializer_class = StudentBonafideCertificateSerializer
                serializer = StudentFCSerializer(data=request.data)
                if serializer.is_valid():
                    data = serializer.data
                    student_instance = StudentRegistration.objects.get(id=data.get('student_id'))
                    student_fee_certificate_last_instance = StudentFeeCertificate.objects.last()
                    if student_fee_certificate_last_instance:
                        last_fc_number = student_fee_certificate_last_instance.fc_number
                        last_fc_number = last_fc_number.split("/")[-1]
                        fc_number = f"{student_instance.organization.organization_code}/{student_instance.branch.branch_code}/{student_instance.batch.batch_code}/fc/{int(last_fc_number) + 1}"
                    else:
                        fc_number = f"{student_instance.organization.organization_code}/{student_instance.branch.branch_code}/{student_instance.batch.batch_code}/fc/{1}"

                    student_fee_certificate_instance = StudentFeeCertificate.objects.filter(
                        student_id=data.get('student_id'))

                    if student_fee_certificate_instance:
                        return Response({"message": "fee certificate already issued !!!"},
                                        status=status.HTTP_200_OK)
                    else:
                        StudentFeeCertificate.objects.create(
                            organization=student_instance.organization,
                            branch=student_instance.branch,
                            student=student_instance,
                            fc_number=fc_number,
                            issue_date=data.get('issue_date'),
                            certificate_status=data.get('certificate_status'),
                            purpose=data.get('purpose'),
                            created_at=datetime.now(),
                            created_by=1
                        )
                        return Response({"message": "success"}, status=status.HTTP_200_OK)
                else:
                    return Response({"message": serializer.error_messages}, status=status.HTTP_400_BAD_REQUEST)

        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='Student-Certificate-Create',

            message=error_message,

        )

class StudentCertificateList(APIView):
    def get(self, request):
        try:
            student_id = request.query_params.get('student_id')
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            batch_id = request.query_params.get('batch_id')
            course_id = request.query_params.get('course_id')
            department_id = request.query_params.get('department_id')
            academic_year_id = request.query_params.get('academic_year_id')
            semester_id = request.query_params.get('semester_id')
            section_id = request.query_params.get('section_id')
            certificate_status = request.query_params.get('status')
            document_type = request.query_params.get('document_type')
            from_date = request.query_params.get('from_date')
            to_date = request.query_params.get('to_date')

            if not organization_id:
                return Response({'message': 'Choose Organization'}, status=status.HTTP_400_BAD_REQUEST)

            if not branch_id:
                return Response({'message': 'Choose branch'}, status=status.HTTP_400_BAD_REQUEST)

            filtered_tc = StudentTransferCertificate.objects.filter(branch=branch_id, organization=organization_id).order_by('-created_at')
            filtered_cc = StudentCharacterCertificate.objects.filter(branch=branch_id, organization=organization_id).order_by('-created_at')
            filtered_bc = StudentBonafideCertificate.objects.filter(branch=branch_id, organization=organization_id).order_by('-created_at')
            filtered_fc = StudentFeeCertificate.objects.filter(branch=branch_id, organization=organization_id).order_by('-created_at')



            if student_id:
                filtered_tc = filtered_tc.filter(student_id = student_id)
                filtered_cc = filtered_cc.filter(student_id = student_id)
                filtered_bc = filtered_bc.filter(student_id = student_id)
                filtered_fc = filtered_fc.filter(student_id = student_id)

            if batch_id:
                filtered_tc = filtered_tc.filter(student__batch_id=batch_id)
                filtered_cc = filtered_cc.filter(student__batch_id=batch_id)
                filtered_bc = filtered_bc.filter(student__batch_id=batch_id)
                filtered_fc = filtered_fc.filter(student__batch_id=batch_id)

            if course_id:
                filtered_tc = filtered_tc.filter(student__course_id=course_id)
                filtered_cc = filtered_cc.filter(student__course_id=course_id)
                filtered_bc = filtered_bc.filter(student__course_id=course_id)
                filtered_fc = filtered_fc.filter(student__course_id=course_id)

            if department_id:
                filtered_tc = filtered_tc.filter(student__department_id=department_id)
                filtered_cc = filtered_cc.filter(student__department_id=department_id)
                filtered_bc = filtered_bc.filter(student__department_id=department_id)
                filtered_fc = filtered_fc.filter(student__department_id=department_id)

            if academic_year_id:
                filtered_tc = filtered_tc.filter(student__academic_year_id=academic_year_id)
                filtered_cc = filtered_cc.filter(student__academic_year_id=academic_year_id)
                filtered_bc = filtered_bc.filter(student__academic_year_id=academic_year_id)
                filtered_fc = filtered_fc.filter(student__academic_year_id=academic_year_id)

            if semester_id:
                filtered_tc = filtered_tc.filter(student__semester_id=semester_id)
                filtered_cc = filtered_cc.filter(student__semester_id=semester_id)
                filtered_bc = filtered_bc.filter(student__semester_id=semester_id)
                filtered_fc = filtered_fc.filter(student__semester_id=semester_id)

            if section_id:
                filtered_tc = filtered_tc.filter(student__section_id=section_id)
                filtered_cc = filtered_cc.filter(student__section_id=section_id)
                filtered_bc = filtered_bc.filter(student__section_id=section_id)
                filtered_fc = filtered_fc.filter(student__section_id=section_id)

            if section_id:
                filtered_tc = filtered_tc.filter(student__section_id=section_id)
                filtered_cc = filtered_cc.filter(student__section_id=section_id)
                filtered_bc = filtered_bc.filter(student__section_id=section_id)
                filtered_fc = filtered_fc.filter(student__section_id=section_id)

            if certificate_status:
                filtered_tc = filtered_tc.filter(status=certificate_status.lower())
                filtered_cc = filtered_cc.filter(status=certificate_status.lower())
                filtered_bc = filtered_bc.filter(status=certificate_status.lower())
                filtered_fc = filtered_fc.filter(status=certificate_status.lower())



            if from_date and to_date:
                filtered_tc = filtered_tc.filter(created_at__range=(from_date,to_date))
                filtered_cc = filtered_cc.filter(created_at__range=(from_date,to_date))
                filtered_bc = filtered_bc.filter(created_at__range=(from_date,to_date))
                filtered_fc = filtered_fc.filter(created_at__range=(from_date,to_date))

            if document_type:
                if document_type.upper() == 'TC':
                    filtered_tc = filtered_tc
                    filtered_cc = []
                    filtered_bc = []
                    filtered_fc = []
                elif document_type.upper() == 'BC':
                    filtered_tc = []
                    filtered_cc = []
                    filtered_bc = filtered_bc
                    filtered_fc = []
                elif document_type.upper() == 'CC':
                    filtered_tc = []
                    filtered_cc = filtered_cc
                    filtered_bc = []
                    filtered_fc = []
                elif document_type.upper() == 'FC':
                    filtered_tc = []
                    filtered_cc = []
                    filtered_bc = []
                    filtered_fc = filtered_fc

            data = []

            if document_type in (None, 'TC'):
                # serializer_data = StudentTransferCertificateSerializer(filtered_tc, many=True).data
                for instance in filtered_tc:
                    student_name_parts = filter(
                        None,
                        [
                            instance.student.first_name,
                            instance.student.middle_name,
                            instance.student.last_name,
                        ],
                    )
                    student_name = " ".join(student_name_parts)
                    data.append({
                                "transfer_certificate_id":instance.id,
                                "student_id": instance.student.id,
                                "document_type": 'TC',
                                "student_name": student_name,
                                "organization_id": instance.student.organization.id,
                                "organization": instance.student.organization.organization_description,
                                "branch_id": instance.student.branch.id,
                                "branch": instance.student.branch.branch_name,
                                "batch_id": instance.student.batch.id,
                                "batch": instance.student.batch.batch_code,
                                "course_id": instance.student.course.id,
                                "course": instance.student.course.course_name,
                                "department_id": instance.student.department.id,
                                "department": instance.student.department.department_description,
                                "academic_year_id": instance.student.academic_year.id,
                                "academic_year": instance.student.academic_year.academic_year_code,
                                "semester_id": instance.student.semester.id,
                                "semester": instance.student.semester.semester_description,
                                "section_id": instance.student.section.id,
                                "section": instance.student.section.section_name,
                                "college_admission_no": instance.student.college_admission_no,
                                "registration_no": instance.student.registration_no,
                                "tc_number": instance.tc_number,
                                "issue_date": instance.issue_date,
                                "date_of_leaving": instance.date_of_leaving,
                                "reason_of_leaving":instance.reason_of_leaving,
                                "student_behaviour":instance.student_behaviour,
                                "certificate_status":instance.certificate_status,
                                "readmission_eligibility":instance.readmission_eligibility,
                    })

            if document_type in (None, 'CC'):
                # data += StudentCharacterCertificateSerializer(filtered_cc, many=True).data
                for instance in filtered_cc:
                    student_name_parts = filter(
                        None,
                        [
                            instance.student.first_name,
                            instance.student.middle_name,
                            instance.student.last_name,
                        ],
                    )
                    student_name = " ".join(student_name_parts)
                    data.append({
                        "character_certificate_id": instance.id,
                        "student_id": instance.student.id,
                        "document_type": 'CC',
                        "student_name": student_name,
                        "organization_id": instance.student.organization.id,
                        "organization": instance.student.organization.organization_description,
                        "branch_id": instance.student.branch.id,
                        "branch": instance.student.branch.branch_name,
                        "batch_id": instance.student.batch.id,
                        "batch": instance.student.batch.batch_code,
                        "course_id": instance.student.course.id,
                        "course": instance.student.course.course_name,
                        "department_id": instance.student.department.id,
                        "department": instance.student.department.department_description,
                        "academic_year_id": instance.student.academic_year.id,
                        "academic_year": instance.student.academic_year.academic_year_code,
                        "semester_id": instance.student.semester.id,
                        "semester": instance.student.semester.semester_description,
                        "section_id": instance.student.section.id,
                        "section": instance.student.section.section_name,
                        "college_admission_no": instance.student.college_admission_no,
                        "registration_no": instance.student.registration_no,
                        "cc_number": instance.cc_number,
                        "issue_date": instance.issue_date,
                        "certificate_status": instance.certificate_status,
                        "student_behaviour": instance.student_behaviour

                    })

            if document_type in (None, 'BC'):
                # data += StudentBonafideCertificateSerializer(filtered_bc, many=True).data
                for instance in filtered_bc:
                    student_name_parts = filter(
                        None,
                        [
                            instance.student.first_name,
                            instance.student.middle_name,
                            instance.student.last_name,
                        ],
                    )
                    student_name = " ".join(student_name_parts)
                    data.append({
                        "bonafide_certificate_id": instance.id,
                        "student_id": instance.student.id,
                        "document_type": 'BC',
                        "student_name": student_name,
                        "organization_id": instance.student.organization.id,
                        "organization": instance.student.organization.organization_description,
                        "branch_id": instance.student.branch.id,
                        "branch": instance.student.branch.branch_name,
                        "batch_id": instance.student.batch.id,
                        "batch": instance.student.batch.batch_code,
                        "course_id": instance.student.course.id,
                        "course": instance.student.course.course_name,
                        "department_id": instance.student.department.id,
                        "department": instance.student.department.department_description,
                        "academic_year_id": instance.student.academic_year.id,
                        "academic_year": instance.student.academic_year.academic_year_code,
                        "semester_id": instance.student.semester.id,
                        "semester": instance.student.semester.semester_description,
                        "section_id": instance.student.section.id,
                        "section": instance.student.section.section_name,
                        "college_admission_no": instance.student.college_admission_no,
                        "registration_no": instance.student.registration_no,
                        "bc_number": instance.bc_number,
                        "issue_date": instance.issue_date,
                        "purpose": instance.purpose,
                        "certificate_status": instance.certificate_status
                    })

            if document_type in (None, 'FC'):
                # data += StudentFeeCertificateSerializer(filtered_fc, many=True).data
                for instance in filtered_fc:
                    student_name_parts = filter(
                        None,
                        [
                            instance.student.first_name,
                            instance.student.middle_name,
                            instance.student.last_name,
                        ],
                    )
                    student_name = " ".join(student_name_parts)
                    data.append({
                        "fee_certificate_id": instance.id,
                        "student_id": instance.student.id,
                        "document_type": 'FC',
                        "student_name": student_name,
                        "organization_id": instance.student.organization.id,
                        "organization": instance.student.organization.organization_description,
                        "branch_id": instance.student.branch.id,
                        "branch": instance.student.branch.branch_name,
                        "batch_id": instance.student.batch.id,
                        "batch": instance.student.batch.batch_code,
                        "course_id": instance.student.course.id,
                        "course": instance.student.course.course_name,
                        "department_id": instance.student.department.id,
                        "department": instance.student.department.department_description,
                        "academic_year_id": instance.student.academic_year.id,
                        "academic_year": instance.student.academic_year.academic_year_code,
                        "semester_id": instance.student.semester.id,
                        "semester": instance.student.semester.semester_description,
                        "section_id": instance.student.section.id,
                        "section": instance.student.section.section_name,
                        "college_admission_no": instance.student.college_admission_no,
                        "registration_no": instance.student.registration_no,
                        "fc_number": instance.fc_number,
                        "issue_date": instance.issue_date,
                        "purpose": instance.purpose,
                        "certificate_status": instance.certificate_status
                    })

            # data.sort(key=lambda x: x['created_at'], reverse=True)

            if data:
                return Response(data)
            else:
                return Response({"message":"no record found !!!"}, status = status.HTTP_204_NO_CONTENT)

        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='Get-Student-Certificate-List',

            message=error_message,

        )


class StudentCertificateUpdateView(generics.UpdateAPIView):

    def update(self, request, *args, **kwargs):
        try:
            data = request.data

            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            student_certificate_id = request.query_params.get('student_certificate_id')
            document_type = request.query_params.get('document_type')

            if document_type.upper() == 'TC':
                try:
                    instance = StudentTransferCertificate.objects.get(id=student_certificate_id,
                                                            branch=branch_id,
                                                            organization=organization_id)
                except StudentTransferCertificate.DoesNotExist:
                    return Response({"message":"record doesn't exist"},status=status.HTTP_204_NO_CONTENT)

                instance.issue_date = data.get('issue_date')
                instance.date_of_leaving = data.get('date_of_leaving')
                instance.reason_of_leaving = data.get('reason_of_leaving')
                instance.student_behaviour = data.get('student_behaviour')
                instance.certificate_status = data.get('certificate_status')
                instance.readmission_eligibility = data.get('readmission_eligibility')
                instance.updated_at = datetime.now()
                instance.updated_by = 1
                instance.save()
                return Response({"message":"student transfer certificate updated."},status=status.HTTP_200_OK)
            elif document_type.upper() == 'CC':
                try:
                    instance = StudentCharacterCertificate.objects.get(id=student_certificate_id,
                                                            branch=branch_id,
                                                            organization=organization_id)
                except StudentCharacterCertificate.DoesNotExist:
                    return Response({"message":"record doesn't exist"},status=status.HTTP_204_NO_CONTENT)

                instance.issue_date = data.get('issue_date')
                instance.student_behaviour = data.get('student_behaviour')
                instance.certificate_status = data.get('certificate_status')
                instance.updated_at = datetime.now()
                instance.updated_by = 1
                instance.save()
                return Response({"message": "student character certificate updated."}, status=status.HTTP_200_OK)
            elif document_type.upper() == 'BC':
                try:
                    instance = StudentBonafideCertificate.objects.get(id=student_certificate_id,
                                                            branch=branch_id,
                                                            organization=organization_id)
                except StudentBonafideCertificate.DoesNotExist:
                    return Response({"message":"record doesn't exist"},status=status.HTTP_204_NO_CONTENT)

                instance.issue_date = data.get('issue_date')
                instance.purpose = data.get('purpose')
                instance.certificate_status = data.get('certificate_status')
                instance.updated_at = datetime.now()
                instance.updated_by = 1
                instance.save()
                return Response({"message": "student bona fide certificate updated."}, status=status.HTTP_200_OK)
            elif document_type.upper() == 'FC':
                try:
                    instance = StudentFeeCertificate.objects.get(id=student_certificate_id,
                                                            branch=branch_id,
                                                            organization=organization_id)
                except StudentFeeCertificate.DoesNotExist:
                    return Response({"message":"record doesn't exist"},status=status.HTTP_204_NO_CONTENT)

                instance.issue_date = data.get('issue_date')
                instance.purpose = data.get('purpose')
                instance.certificate_status = data.get('certificate_status')
                instance.updated_at = datetime.now()
                instance.updated_by = 1
                instance.save()
                return Response({"message": "student fee certificate updated."}, status=status.HTTP_200_OK)
        except Http404:
            return Response({'message': 'Invalid Request'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='student-certificate-update',

            message=error_message,

        )


class GetStudentCertificateDetailBasedOnDocumentTypeStudentId(APIView):

    def get(self, request, *args, **kwargs):
        try:
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            student_id = request.query_params.get('student_id')
            document_type = request.query_params.get('document_type')

            if not (organization_id and branch_id):
                return Response({'message': 'organization_id and branch_id is  required!'},
                                status=status.HTTP_404_NOT_FOUND)

            if not document_type:
                return Response({'message': 'document_type required!'}, status=status.HTTP_404_NOT_FOUND)

            if not student_id:
                return Response({'message': 'student_id is required !!!'}, status=status.HTTP_404_NOT_FOUND)

            if document_type.upper() == 'TC':
                if student_id:
                    try:
                        instance = StudentTransferCertificate.objects.get(student_id = student_id)
                    except StudentTransferCertificate.DoesNotExist:
                        return Response({"message":"record not found !!!"},status=status.HTTP_204_NO_CONTENT)

                    data = {
                        "student_id": instance.student.id,
                        "student_name": instance.student.id,
                        "organization_id": instance.student.organization.id,
                        "organization": instance.student.organization.organization_description,
                        "branch_id": instance.student.branch.id,
                        "branch": instance.student.branch.branch_name,
                        "batch_id": instance.student.batch.id,
                        "batch": instance.student.batch.batch_code,
                        "course_id": instance.student.course.id,
                        "course": instance.student.course.course_name,
                        "department_id": instance.student.department.id,
                        "department": instance.student.department.department_description,
                        "academic_year_id": instance.student.academic_year.id,
                        "academic_year": instance.student.academic_year.academic_year_code,
                        "semester_id": instance.student.semester.id,
                        "semester": instance.student.semester.semester_description,
                        "section_id": instance.student.section.id,
                        "section": instance.student.section.section_description,
                        "tc_number": instance.tc_number,
                        "issue_date": instance.issue_date,
                        "date_of_leaving": instance.date_of_leaving,
                        "reason_of_leaving":instance.reason_of_leaving,
                        "student_behaviour":instance.student_behaviour,
                        "certificate_status":instance.certificate_status,
                        "readmission_eligibility":instance.readmission_eligibility,
                    }
                    return Response({"message":"success","data":data},status=status.HTTP_200_OK)
            elif document_type.upper() == 'CC':
                if student_id:
                    try:
                        instance = StudentCharacterCertificate.objects.get(student_id = student_id)
                    except StudentCharacterCertificate.DoesNotExist:
                        return Response({"message":"record not found !!!"},status=status.HTTP_204_NO_CONTENT)

                    data = {
                        "student_id": instance.student.id,
                        "student_name": instance.student.id,
                        "organization_id": instance.student.organization.id,
                        "organization": instance.student.organization.organization_description,
                        "branch_id": instance.student.branch.id,
                        "branch": instance.student.branch.branch_name,
                        "batch_id": instance.student.batch.id,
                        "batch": instance.student.batch.batch_code,
                        "course_id": instance.student.course.id,
                        "course": instance.student.course.course_name,
                        "department_id": instance.student.department.id,
                        "department": instance.student.department.department_description,
                        "academic_year_id": instance.student.academic_year.id,
                        "academic_year": instance.student.academic_year.academic_year_code,
                        "semester_id": instance.student.semester.id,
                        "semester": instance.student.semester.semester_description,
                        "section_id": instance.student.section.id,
                        "section": instance.student.section.section_description,
                        "cc_number":instance.cc_number
                    }
                    return Response({"message":"success","data":data},status=status.HTTP_200_OK)
            elif document_type.upper() == 'BC':
                if student_id:
                    try:
                        instance = StudentBonafideCertificate.objects.get(student_id=student_id)
                    except StudentBonafideCertificate.DoesNotExist:
                        return Response({"message": "record not found !!!"}, status=status.HTTP_204_NO_CONTENT)

                    data = {
                        "student_id": instance.student.id,
                        "student_name": instance.student.id,
                        "organization_id": instance.student.organization.id,
                        "organization": instance.student.organization.organization_description,
                        "branch_id": instance.student.branch.id,
                        "branch": instance.student.branch.branch_name,
                        "batch_id": instance.student.batch.id,
                        "batch": instance.student.batch.batch_code,
                        "course_id": instance.student.course.id,
                        "course": instance.student.course.course_name,
                        "department_id": instance.student.department.id,
                        "department": instance.student.department.department_description,
                        "academic_year_id": instance.student.academic_year.id,
                        "academic_year": instance.student.academic_year.academic_year_code,
                        "semester_id": instance.student.semester.id,
                        "semester": instance.student.semester.semester_description,
                        "section_id": instance.student.section.id,
                        "section": instance.student.section.section_description,

                    }
                    return Response({"message":"success","data":data},status=status.HTTP_200_OK)
            elif document_type.upper() == 'FC':
                if student_id:
                    try:
                        instance = StudentFeeCertificate.objects.get(student_id=student_id)
                    except StudentFeeCertificate.DoesNotExist:
                        return Response({"message": "record not found !!!"}, status=status.HTTP_204_NO_CONTENT)

                    data = {
                        "student_id": instance.student.id,
                        "student_name": instance.student.id,
                        "organization_id": instance.student.organization.id,
                        "organization": instance.student.organization.organization_description,
                        "branch_id": instance.student.branch.id,
                        "branch": instance.student.branch.branch_name,
                        "batch_id": instance.student.batch.id,
                        "batch": instance.student.batch.batch_code,
                        "course_id": instance.student.course.id,
                        "course": instance.student.course.course_name,
                        "department_id": instance.student.department.id,
                        "department": instance.student.department.department_description,
                        "academic_year_id": instance.student.academic_year.id,
                        "academic_year": instance.student.academic_year.academic_year_code,
                        "semester_id": instance.student.semester.id,
                        "semester": instance.student.semester.semester_description,
                        "section_id": instance.student.section.id,
                        "section": instance.student.section.section_description,

                    }
                    return Response({"message":"success","data":data},status=status.HTTP_200_OK)
            else:
                return Response({"message":"invalid document_type"},status=status.HTTP_204_NO_CONTENT)

        except Http404:
            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name='Get-Student-Certificate-Detail',
            message=error_message,
        )

class StudentCertificatePDFGenerateAPIView(APIView):

    def get(self, request, *args, **kwargs):
        try:
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            student_certificate_id = request.query_params.get('student_certificate_id')
            student_id = request.query_params.get('student_id')
            document_type = request.query_params.get('document_type')

            if not (organization_id,branch_id,student_id,document_type,student_certificate_id):
                return Response({"message":"provide required data !!!"},status=status.HTTP_2)


            try:
                addressinstance = Address.objects.get(reference_id=student_id, usertype__iexact='STUDENT',is_active=True)
            except Address.DoesNotExist:
                addressinstance = None

            if addressinstance:
                # Concatenate all present address fields
                present_address_details = ", ".join(filter(None, [
                    addressinstance.present_address,
                    addressinstance.present_pincode,
                    addressinstance.present_city,
                    addressinstance.present_state,
                    addressinstance.present_country,
                    addressinstance.present_phone_number  # Include phone number if not None
                ]))
            student_instance = StudentRegistration.objects.get(organization=organization_id,branch=branch_id,id=student_id)
            student_name_parts = filter(
                None,
                [
                    student_instance.first_name,
                    student_instance.middle_name,
                    student_instance.last_name,
                ],
            )
            student_name = " ".join(student_name_parts)

            finalresponsedata = []
            # check document type
            if document_type.upper() == 'TC':
                if student_id:
                    try:
                        instance = StudentTransferCertificate.objects.get(student_id = student_id)
                    except StudentTransferCertificate.DoesNotExist:
                        return Response({"message":"record not found !!!"},status=status.HTTP_204_NO_CONTENT)
                    if instance.certificate_status.upper() == 'APPROVED':
                        data = {
                            "student_id": instance.student.id,
                            "student_name": student_name,
                            "document_type": "TC",
                            "organization_id": instance.student.organization.id,
                            "organization": instance.student.organization.organization_description,
                            "branch_id": instance.student.branch.id,
                            "branch": instance.student.branch.branch_name,
                            "batch_id": instance.student.batch.id,
                            "batch": instance.student.batch.batch_code,
                            "course_id": instance.student.course.id,
                            "course": instance.student.course.course_name,
                            "department_id": instance.student.department.id,
                            "department": instance.student.department.department_description,
                            "academic_year_id": instance.student.academic_year.id,
                            "academic_year": instance.student.academic_year.academic_year_code,
                            "semester_id": instance.student.semester.id,
                            "semester": instance.student.semester.semester_description,
                            "section_id": instance.student.section.id,
                            "section": instance.student.section.section_name,
                            "tc_number": instance.tc_number,
                            "issue_date": instance.issue_date,
                            "date_of_leaving": instance.date_of_leaving,
                            "reason_of_leaving":instance.reason_of_leaving,
                            "student_behaviour":instance.student_behaviour,
                            "certificate_status":instance.certificate_status,
                            "readmission_eligibility":instance.readmission_eligibility,
                        }
                        return Response({"message":"success","data":data},status=status.HTTP_200_OK)
                    else:
                        return Response({"message": "Certificate is not approved !!!"},
                                        status=status.HTTP_400_BAD_REQUEST)
            elif document_type.upper() == 'CC':
                if student_id:
                    try:
                        instance = StudentCharacterCertificate.objects.get(student_id = student_id)
                    except StudentCharacterCertificate.DoesNotExist:
                        return Response({"message":"record not found !!!"},status=status.HTTP_204_NO_CONTENT)
                    if instance.certificate_status.upper() == 'APPROVED':
                        data = {
                            "student_id": instance.student.id,
                            "student_name": instance.student.id,
                            "document_type": "CC",
                            "organization_id": instance.student.organization.id,
                            "organization": instance.student.organization.organization_description,
                            "branch_id": instance.student.branch.id,
                            "branch": instance.student.branch.branch_name,
                            "batch_id": instance.student.batch.id,
                            "batch": instance.student.batch.batch_code,
                            "course_id": instance.student.course.id,
                            "course": instance.student.course.course_name,
                            "department_id": instance.student.department.id,
                            "department": instance.student.department.department_description,
                            "academic_year_id": instance.student.academic_year.id,
                            "academic_year": instance.student.academic_year.academic_year_code,
                            "semester_id": instance.student.semester.id,
                            "semester": instance.student.semester.semester_description,
                            "section_id": instance.student.section.id,
                            "section": instance.student.section.section_name,
                            "cc_number":instance.cc_number,
                            "issue_date": instance.issue_date,
                            "student_behaviour": instance.student_behaviour,
                            "certificate_status": instance.certificate_status
                        }
                        return Response({"message":"success","data":data},status=status.HTTP_200_OK)
                    else:
                        return Response({"message": "Certificate is not approved !!!"},status=status.HTTP_400_BAD_REQUEST)
            elif document_type.upper() == 'BC':
                if student_id:
                    try:
                        instance = StudentBonafideCertificate.objects.get(student_id=student_id)
                    except StudentBonafideCertificate.DoesNotExist:
                        return Response({"message": "record not found !!!"}, status=status.HTTP_204_NO_CONTENT)
                    if instance.certificate_status.upper() == 'APPROVED':
                        data = {
                            "student_id": instance.student.id,
                            "student_name": instance.student.id,
                            "document_type": "BC",
                            "organization_id": instance.student.organization.id,
                            "organization": instance.student.organization.organization_description,
                            "branch_id": instance.student.branch.id,
                            "branch": instance.student.branch.branch_name,
                            "batch_id": instance.student.batch.id,
                            "batch": instance.student.batch.batch_code,
                            "course_id": instance.student.course.id,
                            "course": instance.student.course.course_name,
                            "department_id": instance.student.department.id,
                            "department": instance.student.department.department_description,
                            "academic_year_id": instance.student.academic_year.id,
                            "academic_year": instance.student.academic_year.academic_year_code,
                            "semester_id": instance.student.semester.id,
                            "semester": instance.student.semester.semester_description,
                            "section_id": instance.student.section.id,
                            "section": instance.student.section.section_name,
                            "bc_number": instance.bc_number,
                            "issue_date": instance.issue_date,
                            "purpose": instance.purpose,
                            "certificate_status": instance.certificate_status
                        }
                        return Response({"message":"success","data":data},status=status.HTTP_200_OK)
                    else:
                        return Response({"message": "Certificate is not approved !!!"},
                                        status=status.HTTP_400_BAD_REQUEST)
            elif document_type.upper() == 'FC':
                if student_id:
                    try:
                        instance = StudentFeeCertificate.objects.get(student_id=student_id)
                    except StudentFeeCertificate.DoesNotExist:
                        return Response({"message": "record not found !!!"}, status=status.HTTP_204_NO_CONTENT)
                    if instance.certificate_status.upper() == 'APPROVED':
                        data = {
                            "student_id": instance.student.id,
                            "student_name": instance.student.id,
                            "document_type": "FC",
                            "organization_id": instance.student.organization.id,
                            "organization": instance.student.organization.organization_description,
                            "branch_id": instance.student.branch.id,
                            "branch": instance.student.branch.branch_name,
                            "batch_id": instance.student.batch.id,
                            "batch": instance.student.batch.batch_code,
                            "course_id": instance.student.course.id,
                            "course": instance.student.course.course_name,
                            "department_id": instance.student.department.id,
                            "department": instance.student.department.department_description,
                            "academic_year_id": instance.student.academic_year.id,
                            "academic_year": instance.student.academic_year.academic_year_code,
                            "semester_id": instance.student.semester.id,
                            "semester": instance.student.semester.semester_description,
                            "section_id": instance.student.section.id,
                            "section": instance.student.section.section_name,
                            "fc_number": instance.fc_number,
                            "issue_date": instance.issue_date,
                            "purpose": instance.purpose,
                            "certificate_status": instance.certificate_status
                        }
                        return Response({"message":"success","data":data},status=status.HTTP_200_OK)
                    else:
                        return Response({"message": "Certificate is not approved !!!"},
                                        status=status.HTTP_400_BAD_REQUEST)
            else:
                return Response({"message":"invalid document_type"},status=status.HTTP_204_NO_CONTENT)

            return Response({'message': 'success', 'data': finalresponsedata}, status=status.HTTP_200_OK)


        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)



        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='Student-Certificate-PDF',

            message=error_message,

        )

        # if transfer_certificate_id:
            #     try:
            #         studentcertificateInstance = StudentCertificate.objects.get(
            #             transfer_certificate_id=transfer_certificate_id, is_active=True)
            #     except:
            #         return Response({'message': 'No transfer_certificate record found!'},
            #                         status=status.HTTP_404_NOT_FOUND)
            #     try:
            #         courseInstance = Course.objects.get(id=studentcertificateInstance.course_last_studied.id)
            #     except ObjectDoesNotExist:
            #         return Response({'message': 'course record not found!'}, status=status.HTTP_404_NOT_FOUND)
            #
            #     student_course_instance = StudentCourse.objects.get(student_id=student_id)
            #
            #     student_course_subject_instance = CourseDepartmentSubject.objects.filter(
            #         course=student_course_instance.course, semester=student_course_instance.section)
            #     subject_studied = []
            #     if student_course_subject_instance:
            #         for item in student_course_subject_instance:
            #             subject_studied.append(item.subject_code)
            #     subject_studied = ", ".join(subject_studied)
            #     studentcertificatedetails = {
            #         "transfer_certificate_id": studentcertificateInstance.transfer_certificate_id,
            #         "tc_applied_date": studentcertificateInstance.tc_applied_date,
            #         "reason_for_tc": studentcertificateInstance.reason_for_tc,
            #         "tc_issued_date": studentcertificateInstance.tc_issued_date,
            #         "transfer_certificate_no": studentcertificateInstance.transfer_certificate_no,
            #         "document_no": f'{studentcertificateInstance.transfer_certificate_no_prefix}/{studentcertificateInstance.transfer_certificate_no_postfix}',
            #         "ncc_cadet_details": studentcertificateInstance.ncc_cadet_details,
            #         "games_played_details": studentcertificateInstance.games_played_details,
            #         "general_conduct": studentcertificateInstance.general_conduct,
            #         "other_remarks": studentcertificateInstance.other_remarks,
            #         "status": studentcertificateInstance.status,
            #         "school_board_last_taken": studentcertificateInstance.school_board_last_taken,
            #         "whether_failed": studentcertificateInstance.whether_failed,
            #         # "subjects_studied": studentcertificateInstance.subjects_studied,
            #         "subjects_studied": subject_studied,
            #         "qualified_for_promotion": studentcertificateInstance.qualified_for_promotion,
            #         "month_fee_paid": studentcertificateInstance.month_fee_paid,
            #         "fee_concession_availed": studentcertificateInstance.fee_concession_availed,
            #         "total_no_working_days": studentcertificateInstance.total_no_working_days,
            #         "total_no_working_days_present": studentcertificateInstance.total_no_working_days_present,
            #         "document_type": studentcertificateInstance.document_type,
            #         "cancelled_on": studentcertificateInstance.cancelled_on,
            #         "cancelled_remarks": studentcertificateInstance.cancelled_remarks,
            #         "cancelled_by": studentcertificateInstance.cancelled_by,
            #         "enrollment_no": studentcertificateInstance.enrollment_no,
            #         "cultural_activities": studentcertificateInstance.cultural_activities,
            #         "other_activities": studentcertificateInstance.other_activities,
            #         "marks_obtained": studentcertificateInstance.marks_obtained,
            #         "from_month": studentcertificateInstance.from_month,
            #         "to_month": studentcertificateInstance.to_month,
            #         "course_id": courseInstance.id,
            #         "course_name": courseInstance.course_name,
            #         "cbse_reg_no": studentcertificateInstance.student.cbse_reg_no
            #     }
            #
            #
            #
            # else:
            #     # student certificate Instance
            #
            #     studentcertificateRecord = StudentCertificate.objects.filter(organization=organization_id,
            #                                                                  branch=branch_id,
            #                                                                  document_type__iexact=document_type)
            #     # print(studentcertificateRecord)
            #
            #     # Fetch academic year session code
            #     # try:
            #     #     AcademicyearInstance = AcademicYear.objects.get(
            #     #         id=academic_year_id, is_active=True
            #     #     )
            #     # except AcademicYear.DoesNotExist:
            #     #     return Response(
            #     #         {'message': 'Academic year record not found!'},
            #     #         status=status.HTTP_404_NOT_FOUND
            #     #     )
            #     document_no = ""
            #     new_prefix = 0
            #     if studentcertificateRecord.exists():
            #         # Get the maximum prefix from the existing records
            #         max_prefix = studentcertificateRecord.aggregate(
            #             max_prefix=Max('transfer_certificate_no_prefix')
            #         )['max_prefix'] or 0  # Default to 0 if no records
            #
            #         # print(max_prefix)
            #
            #         # Increment prefix by 1
            #         new_prefix = max_prefix + 1
            #
            #         # Generate document number
            #         document_no = f'{student_course_instance.organization.organization_code}/{student_course_instance.course.course_name}/{student_course_instance.batch.batch_}/{document_type}/{new_prefix}'
            #         # print(document_no)
            #
            #
            #     else:
            #         # If no record exists, start prefix from 1
            #         new_prefix = 1
            #
            #         # Generate document number
            #         # document_no = f'{new_prefix}/{AcademicyearInstance.academic_year_code}'
            #         document_no = f'{student_course_instance.organization.organization_code}/{student_course_instance.course.course_name}/{student_course_instance.batch.batch_code}/{document_type}/{new_prefix}'
            #         # print(document_no)
            #
            #         # Update studentcertificatedetails with the document_no
            #         # studentcertificatedetails = {"document_no": document_no}
            #
            #     # Attendance Get
            #     # try:
            #     #     attendancerecord = Attendance.objects.filter(academic_year_id=academicyearId,
            #     #                                                  student_id=studentId,
            #     #                                                  is_active=True)
            #     #     print(attendancerecord)
            #     # except:
            #     #     attendancerecord = []
            #     attendancerecord = Attendance.objects.filter(organization=organization_id, branch=branch_id,
            #                                                  student_id=student_id,
            #                                                  is_active=True)
            #
            #     total_working_day = 0
            #     total_present_day = 0
            #
            #     if attendancerecord:
            #         # Total number of filtered attendance records
            #         total_working_day = attendancerecord.count()
            #
            #         # Number of records where present == "P"
            #         total_present_day = attendancerecord.filter(present="P").count()
            #
            #     studentcertificatedetails.update(
            #         {'total_no_working_days': total_working_day, 'total_no_working_days_present': total_present_day,
            #          "document_no": document_no})
            #
            # # Get student class Instance
            #
            # try:
            #     studentCourseInstance = StudentCourse.objects.get(student_id=student_id, organization=organization_id,
            #                                                       branch=branch_id
            #                                                       , is_active=True)  # is_active=True
            # except ObjectDoesNotExist:
            #     return Response({'message': 'student course record not found!'}, status=status.HTTP_404_NOT_FOUND)
            #
            # # subject list Get
            # try:
            #     student_course_instance = StudentCourse.objects.get(student_id=student_id, organization=organization_id,
            #                                                         branch=branch_id)
            #     student_course_subject_instance = CourseDepartmentSubject.objects.filter(organization=organization_id,
            #                                                                              branch=branch_id,
            #                                                                              course=student_course_instance.course,
            #                                                                              department=student_course_instance.department)  # is_active=True
            # except:
            #     studentsubjectrecord = []
            #
            # subject_studied = []
            # if student_course_subject_instance:
            #     for item in student_course_subject_instance:
            #         subject_studied.append(item.subject_code)
            #     subject_studied = ", ".join(subject_studied)
            #
            # # student_class_subject_instance = CourseSubjects.objects.filter(
            # #     class_id=student_course_instance.addmitted_class, section_id=student_course_instance.addmitted_section)
            #
            # student_name_parts = filter(
            #     None,
            #     [
            #         studentCourseInstance.student.first_name,
            #         studentCourseInstance.student.middle_name,
            #         studentCourseInstance.student.last_name,
            #     ],
            # )
            # student_name = " ".join(student_name_parts)
            #
            # data = {
            #     "studentId": studentCourseInstance.student.id,
            #     "student_name": student_name,
            #     "college_admission_no": studentCourseInstance.student.college_admission_no,
            #     "barcode": studentCourseInstance.student.barcode,
            #     "father_name": studentCourseInstance.student.father_name,
            #     "mother_name": studentCourseInstance.student.mother_name,
            #     "nationality": studentCourseInstance.student.nationality.nationality_name,
            #     "category": studentCourseInstance.student.category.category_code,
            #     "date_of_admission": studentCourseInstance.student.date_of_admission,
            #     "date_of_birth": studentCourseInstance.student.date_of_birth,
            #     "subjects_studied": subject_studied,
            #     "course_last_studied": studentCourseInstance.course.course_name if not transfer_certificate_id else None,
            #     "course_id": studentCourseInstance.course.id if not transfer_certificate_id else None,
            #     # "document_no": document_no,
            #     # "total_working_day": total_working_day,
            #     # "total_present_day": total_present_day,
            #     "student_certificate_details": studentcertificatedetails
            #
            # }
            #
            # return Response({'message': 'success', 'data': data}, status=status.HTTP_200_OK)

    #     except Http404:
    #
    #         return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)
    #
    #
    #     except Exception as e:
    #
    #         # Log the exception
    #
    #         error_message = str(e)
    #
    #         self.log_exception(request, error_message)
    #
    #         return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    #
    # def log_exception(self, request, error_message):
    #
    #     ExceptionTrack.objects.create(
    #
    #         request=str(request),
    #
    #         process_name='GetStudentDetailsBasedOnStudentIdDocumentType',
    #
    #         message=error_message,
    #
    #     )


class StudentAttendanceSearchListAPIView(ListAPIView):
    # permission_classes = [IsAuthenticated]
    serializer_class = AttendanceSearchSerializer

    def list(self, request, *args, **kwargs):
        try:

            serializers = self.get_serializer(data=request.query_params)
            serializers.is_valid(raise_exception=True)

            organization_id = serializers.validated_data.get('organization_id')
            branch_id = serializers.validated_data.get('branch_id')
            batch_id = serializers.validated_data.get('batch_id')
            course_id = serializers.validated_data.get('course_id')
            department_id = serializers.validated_data.get('department_id')
            academic_year_id = serializers.validated_data.get('academic_year_id')
            semester_id = serializers.validated_data.get('semester_id')
            section_id = serializers.validated_data.get('section_id')
            lecture_period_id = serializers.validated_data.get('lecture_period_id')
            subject_id = serializers.validated_data.get('subject_id')
            professor_id = serializers.validated_data.get('professor_id')
            date = serializers.validated_data.get('date')
            from_date = serializers.validated_data.get('from_date')
            to_date = serializers.validated_data.get('to_date')
            student_id = serializers.validated_data.get('student_id')

            if organization_id and branch_id:
                try:
                    studentAttendanceList = Attendance.objects.filter(organization=organization_id, branch=branch_id,
                                                                      is_active=True).order_by('-updated_at')
                except Attendance.DoesNotExist:
                    return Response({"message": "student attendance record not found !!!"},
                                    status=status.HTTP_404_NOT_FOUND)
            else:
                return Response({"message": "organization_id and branch_id is required !!!"},
                                status=status.HTTP_404_NOT_FOUND)

            if batch_id:
                studentAttendanceList = studentAttendanceList.filter(batch=batch_id)

            if course_id:
                studentAttendanceList = studentAttendanceList.filter(course=course_id)

            if department_id:
                studentAttendanceList = studentAttendanceList.filter(department=department_id)

            if academic_year_id:
                studentAttendanceList = studentAttendanceList.filter(academic_year=academic_year_id)

            if semester_id:
                studentAttendanceList = studentAttendanceList.filter(semester=semester_id)

            if section_id:
                studentAttendanceList = studentAttendanceList.filter(section=section_id)

            if date:
                studentAttendanceList = studentAttendanceList.filter(attendance_date=date)

            if from_date and not to_date:
                studentAttendanceList = studentAttendanceList.filter(attendance_date__range=(from_date,datetime.now()))
            if not from_date and to_date:
                studentAttendanceList = studentAttendanceList.filter(attendance_date__lte=to_date)

            if from_date and to_date:
                studentAttendanceList = studentAttendanceList.filter(attendance_date__range=(from_date,to_date))

            if student_id:
                studentAttendanceList =  studentAttendanceList.filter(student_id=student_id)

            student_attendance_first_lecture = studentAttendanceList.filter(lecture_period=1)

            if lecture_period_id:
                studentAttendanceList = studentAttendanceList.filter(lecture_period=lecture_period_id)

            if subject_id:
                studentAttendanceList = studentAttendanceList.filter(subject=subject_id)

            if professor_id:
                studentAttendanceList = studentAttendanceList.filter(professor=professor_id)

            # validate the data
            # if not academic_year_id:
            #     return Response({'message':'Academic year Id not found!'},status=status.HTTP_404_NOT_FOUND)
            #
            # if not date:
            #     return Response({'message':'date not found!'},status=status.HTTP_404_NOT_FOUND)
            # if not course_id:
            #     return Response({'message':'Course Id not found!'},status=status.HTTP_404_NOT_FOUND)
            #
            # if not section_id:
            #     return Response({'message':'Section Id not found!'},status=status.HTTP_404_NOT_FOUND)
            # if not lecture_id:
            #     return Response({'message':'Period Id not found!'},status=status.HTTP_404_NOT_FOUND)
            #
            # if not subject_id:
            #     return Response({'message':'Subject Id not found!'},status=status.HTTP_404_NOT_FOUND)
            # if not professor_id:
            #     return Response({'message':'Professor Id not found!'},status=status.HTTP_404_NOT_FOUND)
            #

            # try:
            #     coursebindsectionInstance = CourseSemesterSectionBind.objects.get(course=course_id,section=section_id,is_active=True)
            # except ObjectDoesNotExist:
            #     return Response({'message':'This course & section combination Not Found!'})

            # Check Attendance exist or not

            # try:
            #     AttendanceRecord = Attendance.objects.filter(organization=organization_id,branch=branch_id,batch=batch_id,course=course_id,department=department_id,academic_year=academic_year_id,semester=semester_id,section=section_id,
            #                                                 lecture_period=lecture_period_id,subject=subject_id,
            #                                                 professor=professor_id,attendance_date=date,is_active=True)
            # except:
            #     AttendanceRecord=[]

            ResponseData = []

            if studentAttendanceList:
                if student_attendance_first_lecture:
                    for item,first_item in zip(studentAttendanceList,student_attendance_first_lecture):

                        try:

                            StudentCourseInstance = StudentCourse.objects.get(student=item.student.id, is_active=True)
                        except:
                            return Response({'message': 'Student course record not found'},
                                            status=status.HTTP_404_NOT_FOUND)

                        data = {
                            "id": item.id,
                            "organization_id": item.organization.id,
                            "organization": item.organization.organization_code,
                            "branch_id": item.branch.id,
                            "branch": item.branch.branch_name,
                            "batch_id": item.batch.id,
                            "batch": item.batch.batch_code,
                            "course_id": item.course.id,
                            "course_name": item.course.course_name,
                            "department_id": item.department.id,
                            "department": item.department.department_description,
                            "academic_year_id": item.academic_year.id,
                            "academic_year": item.academic_year.academic_year_code,
                            "semester_id": item.semester.id,
                            "semester": item.semester.semester_description,
                            "section_id": item.section.id,
                            "section_name": item.section.section_name,
                            # "class_period_id": item.class_period_id.id,
                            # "class_period": item.class_period_id.period_name,
                            # "subject_id": item.subject_id.id,
                            # "subjectname": item.subject_id.subject_code,
                            # "teacher_id": item.teacher_id.id,
                            # "teachername": item.teacher_id.first_name,
                            "attendance_date": item.attendance_date,
                            "student_id": item.student.id,
                            "registration_no": item.student.registration_no,
                            "student_name": f"{item.student.first_name} {item.student.last_name}",
                            "college_admission_no": item.student.college_admission_no,
                            "barcode": item.student.barcode,
                            "primary_guardian": item.student.primary_guardian,
                            "enrollment_no": StudentCourseInstance.enrollment_no,
                            "present": item.present,
                            "remarks": item.remarks,
                            "is_sms_sent": first_item.is_sms_sent if first_item else False,
                            # "is_sms_sent": item.is_sms_sent,
                            "father_contact_number": item.father_contact_number,  # this data i fetch on attendance
                            "mother_contact_number": item.mother_contact_number
                        }

                        ResponseData.append(data)
                else:
                    for item in studentAttendanceList:

                        try:

                            StudentCourseInstance = StudentCourse.objects.get(student=item.student.id, is_active=True)
                        except:
                            return Response({'message': 'Student course record not found'},
                                            status=status.HTTP_404_NOT_FOUND)

                        data = {
                            "id": item.id,
                            "organization_id": item.organization.id,
                            "organization": item.organization.organization_code,
                            "branch_id": item.branch.id,
                            "branch": item.branch.branch_name,
                            "batch_id": item.batch.id,
                            "batch": item.batch.batch_code,
                            "course_id": item.course.id,
                            "course_name": item.course.course_name,
                            "department_id": item.department.id,
                            "department": item.department.department_description,
                            "academic_year_id": item.academic_year.id,
                            "academic_year": item.academic_year.academic_year_code,
                            "semester_id": item.semester.id,
                            "semester": item.semester.semester_description,
                            "section_id": item.section.id,
                            "section_name": item.section.section_name,
                            # "class_period_id": item.class_period_id.id,
                            # "class_period": item.class_period_id.period_name,
                            # "subject_id": item.subject_id.id,
                            # "subjectname": item.subject_id.subject_code,
                            # "teacher_id": item.teacher_id.id,
                            # "teachername": item.teacher_id.first_name,
                            "attendance_date": item.attendance_date,
                            "student_id": item.student.id,
                            "registration_no": item.student.registration_no,
                            "student_name": " ".join(filter(None, [item.student.first_name, item.student.last_name])),
                            "college_admission_no": item.student.college_admission_no,
                            "barcode": item.student.barcode,
                            "primary_guardian": item.student.primary_guardian,
                            "enrollment_no": StudentCourseInstance.enrollment_no,
                            "present": item.present,
                            "remarks": item.remarks,
                            "is_sms_sent": False,
                            # "is_sms_sent": item.is_sms_sent,
                            "father_contact_number": item.father_contact_number,  # this data i fetch on attendance
                            "mother_contact_number": item.mother_contact_number
                        }

                        ResponseData.append(data)
            else:

                try:
                    studentRecord = StudentCourse.objects.filter(academic_year=academic_year_id, course=course_id,
                                                                 section=section_id, is_active=True)
                except:
                    return Response({'message': 'Record Not Found!'}, status=status.HTTP_404_NOT_FOUND)

                if studentRecord:
                    if student_attendance_first_lecture:
                        for record,first_item in zip(studentRecord,student_attendance_first_lecture):
                            academicyearInstance = AcademicYear.objects.get(id=academic_year_id, is_active=True)

                            courseInstance = Course.objects.get(id=course_id, is_active=True)

                            sectionInstance = Section.objects.get(id=section_id, is_active=True)

                            data = {
                                "organization_id": record.organization.id,
                                "organization": record.organization.organization_code,
                                "branch_id": record.branch.id,
                                "branch": record.branch.branch_name,
                                "batch_id": record.batch.id,
                                "batch": record.batch.batch_code,
                                "course_id": record.course.id,
                                "course_name": record.course.course_name,
                                "department_id": record.department.id,
                                "department": record.department.department_description,
                                "academic_year_id": record.academic_year.id,
                                "academic_year": record.academic_year.academic_year_code,
                                "semester_id": record.semester.id,
                                "semester": record.semester.semester_description,
                                "section_id": record.section.id,
                                "section_name": record.section.section_name,
                                "student_id": record.student.id,
                                "student_name": " ".join(filter(None, [record.student.first_name, record.student.last_name])),
                                "college_admission_no": record.student.college_admission_no,
                                "barcode": record.student.barcode,
                                "primary_guardian": record.student.primary_guardian,
                                "enrollment_no": record.enrollment_no,
                                "registration_no": record.student.registration_no,
                                "present": '',
                                # "present": 'P',
                                "remarks": "",
                                "father_contact_number": record.student.father_contact_number,
                                "mother_contact_number": record.student.mother_contact_number,
                                "attendance_date": date,
                                "is_sms_sent": first_item.is_sms_sent if first_item else False
                                # "academic_year_id": academic_year_id,
                                # "academicyear": academicyearInstance.academic_year_code,
                                # "course_id": courseInstance.id,
                                # "course_name": courseInstance.course_name,
                                # "section_id": sectionInstance.id,
                                # "section_name": sectionInstance.section_name
                            }

                            ResponseData.append(data)
                    else:
                        for record in studentRecord:
                            academicyearInstance = AcademicYear.objects.get(id=academic_year_id, is_active=True)

                            courseInstance = Course.objects.get(id=course_id, is_active=True)

                            sectionInstance = Section.objects.get(id=section_id, is_active=True)

                            data = {
                                "organization_id": record.organization.id,
                                "organization": record.organization.organization_code,
                                "branch_id": record.branch.id,
                                "branch": record.branch.branch_name,
                                "batch_id": record.batch.id,
                                "batch": record.batch.batch_code,
                                "course_id": record.course.id,
                                "course_name": record.course.course_name,
                                "department_id": record.department.id,
                                "department": record.department.department_description,
                                "academic_year_id": record.academic_year.id,
                                "academic_year": record.academic_year.academic_year_code,
                                "semester_id": record.semester.id,
                                "semester": record.semester.semester_description,
                                "section_id": record.section.id,
                                "section_name": record.section.section_name,
                                "student_id": record.student.id,
                                "student_name": " ".join(filter(None, [record.student.first_name, record.student.last_name])),
                                "college_admission_no": record.student.college_admission_no,
                                "barcode": record.student.barcode,
                                "primary_guardian": record.student.primary_guardian,
                                "enrollment_no": record.enrollment_no,
                                "registration_no": record.student.registration_no,
                                "present": '',
                                # "present": 'P',
                                "remarks": "",
                                "father_contact_number": record.student.father_contact_number,
                                "mother_contact_number": record.student.mother_contact_number,
                                "attendance_date": date,
                                "is_sms_sent": False
                                # "academic_year_id": academic_year_id,
                                # "academicyear": academicyearInstance.academic_year_code,
                                # "course_id": courseInstance.id,
                                # "course_name": courseInstance.course_name,
                                # "section_id": sectionInstance.id,
                                # "section_name": sectionInstance.section_name
                            }

                            ResponseData.append(data)

                else:
                    return Response({'message': 'No Record Found'}, status=status.HTTP_204_NO_CONTENT)

            return Response({'message': 'success', 'data': ResponseData}, status=status.HTTP_200_OK)


        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='GetSearchAttendanceDetails',

            message=error_message,

        )


class StudentAttendanceCreate_UpdateAPI(CreateAPIView):
    queryset = Attendance.objects.all()
    serializer_class = StudentAttendanceSerializer

    @transaction.atomic
    def create(self, request, *args, **kwargs):
        try:
            # Get validated data
            serializers = self.get_serializer(data=request.data)
            serializers.is_valid(raise_exception=True)

            login_id = serializers.validated_data.get('login_id')

            date = serializers.validated_data.get('date')
            organization_id = serializers.validated_data.get('organization_id')
            branch_id = serializers.validated_data.get('branch_id')
            batch_id = serializers.validated_data.get('batch_id')
            course_id = serializers.validated_data.get('course_id')
            department_id = serializers.validated_data.get('department_id')
            academic_year_id = serializers.validated_data.get('academic_year_id')
            semester_id = serializers.validated_data.get('semester_id')
            section_id = serializers.validated_data.get('section_id')
            lecture_period_id = serializers.validated_data.get('lecture_id')
            subject_id = serializers.validated_data.get('subject_id')
            professor_id = serializers.validated_data.get('professor_id')
            updateDetails = serializers.validated_data.get('update_detail')

            # Get class section instance
            # try:
            #     CourseBindInstance = Section.objects.get(organization=organization_id,branch=branch_id,batch=batch_id,course=course_id,department=department_id,semester=semester_id,section=section_id, is_active=True)
            # except CourseSectionBind.DoesNotExist:
            #     return Response({'message': 'Course-section combination not found!'}, status=status.HTTP_404_NOT_FOUND)

            # Iterate through updateDetails to update or create records
            for item in updateDetails:
                IsAttendanceRecordExist = None # helper var init
                
                if lecture_period_id > 1:
                    is_sms_sent = False
                else:
                    is_sms_sent = True

                # Check if attendance record exists (MOVED OUTSIDE ELSE BLOCK)
                IsAttendanceRecordExist = Attendance.objects.filter(
                    organization=organization_id,
                    branch=branch_id,
                    batch=batch_id,
                    course=course_id,
                    department=department_id,
                    academic_year=academic_year_id,
                    semester=semester_id,
                    section=section_id,
                    lecture_period=lecture_period_id,
                    # lecture=lecture_id,
                    subject=subject_id,
                    professor=professor_id,
                    attendance_date=date,
                    student=item['student_id'],
                    is_active=True
                ).first()

                if IsAttendanceRecordExist:
                    # Update the existing record
                    IsAttendanceRecordExist.present = item['mark_Attendance']
                    IsAttendanceRecordExist.remarks = item.get('remarks', '')
                    IsAttendanceRecordExist.father_contact_number = item.get('father_contact_number', None)
                    IsAttendanceRecordExist.mother_contact_number = item.get('mother_contact_number', None)
                    IsAttendanceRecordExist.send_to_sms = item.get('send_sms_to', 'B') if is_sms_sent else 'N'
                    IsAttendanceRecordExist.is_sms_sent = True
                    IsAttendanceRecordExist.save()
                else:
                    # Create new attendance record

                    try:
                        OrganizationInstance = Organization.objects.get(id=organization_id, is_active=True)
                    except ObjectDoesNotExist:
                        return Response({'message': 'Organization not found!'}, status=status.HTTP_404_NOT_FOUND)

                    try:
                        BranchInstance = Branch.objects.get(id=branch_id, is_active=True)
                    except ObjectDoesNotExist:
                        return Response({'message': 'Branch not found!'}, status=status.HTTP_404_NOT_FOUND)

                    try:
                        BatchInstance = Batch.objects.get(id=batch_id, is_active=True)
                    except ObjectDoesNotExist:
                        return Response({'message': 'Batch not found!'}, status=status.HTTP_404_NOT_FOUND)

                    try:
                        CourseInstance = Course.objects.get(id=course_id, is_active=True)
                    except ObjectDoesNotExist:
                        return Response({'message': 'Course not found!'}, status=status.HTTP_404_NOT_FOUND)

                    try:
                        DepartmentInstance = Department.objects.get(id=department_id, is_active=True)
                    except ObjectDoesNotExist:
                        return Response({'message': 'Department not found!'}, status=status.HTTP_404_NOT_FOUND)

                    try:
                        AcademicyearInstance = AcademicYear.objects.get(id=academic_year_id, is_active=True)
                    except ObjectDoesNotExist:
                        return Response({'message': 'Academic year not found!'}, status=status.HTTP_404_NOT_FOUND)

                    try:
                        SemesterInstance = Semester.objects.get(id=semester_id, is_active=True)
                    except ObjectDoesNotExist:
                        return Response({'message': 'Semester not found!'}, status=status.HTTP_404_NOT_FOUND)

                    try:
                        SectionInstance = Section.objects.get(id=section_id, is_active=True)
                    except ObjectDoesNotExist:
                        return Response({'message': 'Academic year not found!'}, status=status.HTTP_404_NOT_FOUND)

                    # period class Instance
                    try:
                        LecturePeriodInstance = LecturePeriod.objects.get(id=lecture_period_id, is_active=True)
                    except ObjectDoesNotExist:
                        return Response({'message': 'Period record not found!'}, status=status.HTTP_404_NOT_FOUND)

                    # Subject Master Instance
                    try:
                        SubjectInstance = CourseDepartmentSubject.objects.get(id=subject_id, is_active=True)
                    except ObjectDoesNotExist:
                        return Response({'message': 'Subject  not found!'}, status=status.HTTP_404_NOT_FOUND)

                    # Employee Instance
                    try:
                        EmployeeInstance = EmployeeMaster.objects.get(id=professor_id, is_active=True)
                    except ObjectDoesNotExist:
                        return Response({'message': 'Professor not found!'}, status=status.HTTP_404_NOT_FOUND)

                    # Registration Instance
                    try:
                        RegistrationInstance = StudentRegistration.objects.get(id=item['student_id'], is_active=True)
                    except ObjectDoesNotExist:
                        return Response({'message': 'Registration student  not found!'},
                                        status=status.HTTP_404_NOT_FOUND)

                    if lecture_period_id > 1:
                        is_sms_sent = False
                    else:
                        is_sms_sent = True

                    # Ensure a Lecture exists to satisfy DB Not-Null constraint
                    lecture_instance = Lecture.objects.filter(
                        organization=organization_id, 
                        branch=branch_id,
                        batch=batch_id,
                        course=course_id,
                        department=department_id,
                        academic_year=academic_year_id,
                        semester=semester_id,
                        section=section_id,
                        lecture_name="Lecture"
                    ).first()
                    
                    if not lecture_instance:
                        lecture_instance = Lecture.objects.create(
                            lecture_name="Lecture",
                            organization=OrganizationInstance,
                            branch=BranchInstance,
                            batch=BatchInstance,
                            course=CourseInstance,
                            department=DepartmentInstance,
                            academic_year=AcademicyearInstance,
                            semester=SemesterInstance,
                            section=SectionInstance,
                            created_by=login_id
                        )

                    Attendance.objects.create(
                        organization=OrganizationInstance,
                        branch=BranchInstance,
                        batch=BatchInstance,
                        course=CourseInstance,
                        department=DepartmentInstance,
                        academic_year=AcademicyearInstance,
                        semester=SemesterInstance,
                        section=SectionInstance,
                        # class_session_id=CourseBindInstance,
                        lecture_period=LecturePeriodInstance,
                        lecture=lecture_instance,
                        subject=SubjectInstance,
                        professor=EmployeeInstance,
                        # organization=AcademicyearInstance.department.course.batch.organization.organization_description,
                        # branch_id=AcademicyearInstance.branch.id,
                        attendance_date=date,
                        student=RegistrationInstance,
                        father_contact_number=item.get('father_contact_number', None),
                        mother_contact_number=item.get('mother_contact_number', None),
                        present=item['mark_Attendance'],
                        remarks=item.get('remarks', ''),
                        is_active=True,
                        created_by=login_id,
                        updated_by=login_id,
                        send_to_sms=item.get('send_sms_to', 'B') if is_sms_sent else 'N',
                        is_sms_sent=is_sms_sent
                    )

            return Response({'message': 'Success'}, status=status.HTTP_200_OK)


        except ValidationError as e:
            # Rollback the transaction on validation error

            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        except DatabaseError as e:
            # Rollback the transaction on database error
            try:
                with open('error_log.txt', 'a') as f:
                    import traceback
                    f.write(f"DB Error: {str(e)}\n")
                    traceback.print_exc(file=f)
            except:
                pass

            self.log_exception(request, str(e))

            return Response({'error': 'A database error occurred: ' + str(e)},

                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:

            # Rollback the transaction on any other exception
            try:
                with open('error_log.txt', 'a') as f:
                    import traceback
                    f.write(f"Generic Error: {str(e)}\n")
                    traceback.print_exc(file=f)
            except:
                pass

            self.log_exception(request, str(e))

            return Response({'error': 'An unexpected error occurred: ' + str(e)},

                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='Attendance_create_or_update',

            message=error_message,

        )


class GetSubjectProfessorListAPIView(ListAPIView):
    queryset = TimeTable.objects.all()
    serializer_class = TimeTableSerializer

    def list(self, request, *args, **kwargs):
        try:

            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            batch_id = request.query_params.get('batch_id')
            course_id = request.query_params.get('course_id')
            department_id = request.query_params.get('department_id')
            academic_year_id = request.query_params.get('academic_year_id')
            semester_id = request.query_params.get('semester_id')
            section_id = request.query_params.get('section_id')
            subject_id = request.query_params.get('subject_id')
            # branchId = request.query_params.get('branch_id')
            date = request.query_params.get('date')
            # course_id = request.query_params.get('course_id')

            semesterLectureId = request.query_params.get('semesterLectureId')

            # validate data
            if not organization_id:
                return Response({'message': 'organization not found'}, status=status.HTTP_400_BAD_REQUEST)

            if not branch_id:
                return Response({'message': 'branch_id not found'}, status=status.HTTP_400_BAD_REQUEST)

            if not batch_id:
                return Response({'message': 'batch_id not found'}, status=status.HTTP_400_BAD_REQUEST)

            if not course_id:
                return Response({'message': 'course_id not found'}, status=status.HTTP_400_BAD_REQUEST)

            if not department_id:
                return Response({'message': 'department_id not found'}, status=status.HTTP_400_BAD_REQUEST)

            if not academic_year_id:
                return Response({'message': 'academic year not found'}, status=status.HTTP_400_BAD_REQUEST)

            if not semester_id:
                return Response({'message': 'semester_id not found'}, status=status.HTTP_400_BAD_REQUEST)

            if not section_id:
                return Response({'message': 'section_id not found'}, status=status.HTTP_400_BAD_REQUEST)

            if not subject_id:
                return Response({'message': 'subject_id not found'}, status=status.HTTP_400_BAD_REQUEST)

            if not date:
                return Response({'message': 'date not found'}, status=status.HTTP_400_BAD_REQUEST)

            # if not lecture_id:
            #     return Response({'message':'claasPeriodId not found'},status=status.HTTP_400_BAD_REQUEST)

            # Convert date to day of the week
            # day_of_week=None
            if date:
                try:
                    date_obj = datetime.strptime(date, '%Y-%m-%d')
                    day_of_week = date_obj.strftime('%A')  # Converts to full weekday name, e.g., "Monday"
                except ValueError:
                    return Response({"error": "Invalid date format. Use 'YYYY-MM-DD'."},
                                    status=status.HTTP_400_BAD_REQUEST)

            TimeTableInstance = None
            # filter record provide parameter's
            try:
                TimeTableInstance = TimeTable.objects.filter(organization=organization_id, branch=branch_id,
                                                             batch=batch_id, course=course_id, department=department_id,
                                                             academic_year=academic_year_id,
                                                             semester=semester_id, section=section_id,
                                                             subject=subject_id,
                                                             schedule_day=day_of_week, is_active=True)
            except ObjectDoesNotExist:
                data = []

            # print(TimeTableInstance)
            if TimeTableInstance:
                records = []
                for item in TimeTableInstance:
                    if item.professor.first_name and item.professor.middle_name and item.professor.last_name:
                        professor_name = item.professor.first_name + ' ' + item.professor.middle_name + ' ' + item.professor.last_name
                    elif item.professor.first_name and item.professor.middle_name:
                        professor_name = item.professor.first_name + ' ' + item.professor.middle_name
                    elif item.professor.first_name and item.professor.last_name:
                        professor_name = item.professor.first_name + ' ' + item.professor.last_name
                    else:
                        professor_name = item.professor.first_name
                    record = {
                        'professor_id': item.professor.id,
                        'professor_name': professor_name,
                        'subject_id': item.subject.id,
                        'subject_name': item.subject.subject_description,
                    }
                    records.append(record)
                data = records
            else:
                data = []

            return Response({'message': 'success', 'data': data}, status=status.HTTP_200_OK)

        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='GetSubjectProfessorList',

            message=error_message,

        )


class GetLectureListAPIView(ListAPIView):
    queryset = Lecture.objects.all()
    serializer_class = LectureSerializer

    def list(self, request, *args, **kwargs):
        try:
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            batch_id = request.query_params.get('batch_id')
            course_id = request.query_params.get('course_id')
            department_id = request.query_params.get('department_id')
            academic_year_id = request.query_params.get('academic_year_id')
            semester_id = request.query_params.get('semester_id')
            section_id = request.query_params.get('section_id')
            # lecture_id = request.query_params.get('lecture_id')
            # branchId = self.kwargs.get('branch_id')

            # validate data

            # if not organization:
            #     return Response({'message': 'organization not found'}, status=status.HTTP_400_BAD_REQUEST)
            # if not branchId:
            #     return Response({'message': 'branchId not found'}, status=status.HTTP_400_BAD_REQUEST)

            if organization_id and branch_id and batch_id and course_id and department_id and academic_year_id and semester_id and section_id:
                lecture_record = Lecture.objects.filter(organization=organization_id, branch=branch_id, batch=batch_id,
                                                        course=course_id, department=department_id,
                                                        academic_year=academic_year_id, semester=semester_id,
                                                        section=section_id, is_active=True)
            else:
                return Response({
                                    'error': 'organization_id, branch_id, batch_id, course_id, department_id, academic_year_id, semester_id and section_id is required !!!'},
                                status=status.HTTP_400_BAD_REQUEST)

            responsedata = []
            if lecture_record:
                for item in lecture_record:
                    data = {
                        'id': item.id,
                        'lecture_name': item.lecture_name,
                        'lecture_description': item.lecture_description,
                        'is_active': item.is_active,
                        'day_attendance': item.day_attendance
                    }

                    responsedata.append(data)
            if responsedata:
                return Response({'message': 'success', 'data': responsedata}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'success', 'data': responsedata}, status=status.HTTP_200_OK)

        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='GetLectureList',

            message=error_message,

        )


class GetLectureListByTimeTableAPIView(ListAPIView):
    queryset = TimeTable.objects.all()
    serializer_class = LectureSerializer

    def list(self, request, *args, **kwargs):
        try:
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')
            batch_id = request.query_params.get('batch_id')
            course_id = request.query_params.get('course_id')
            department_id = request.query_params.get('department_id')
            academic_year_id = request.query_params.get('academic_year_id')
            semester_id = request.query_params.get('semester_id')
            section_id = request.query_params.get('section_id')
            date = request.query_params.get('date')
            # lecture_id = request.query_params.get('lecture_id')
            # branchId = self.kwargs.get('branch_id')

            # validate data

            if not organization_id:
                return Response({'message': 'organization not found'}, status=status.HTTP_400_BAD_REQUEST)

            if not branch_id:
                return Response({'message': 'branch_id not found'}, status=status.HTTP_400_BAD_REQUEST)

            if not batch_id:
                return Response({'message': 'batch_id not found'}, status=status.HTTP_400_BAD_REQUEST)

            if not course_id:
                return Response({'message': 'course_id not found'}, status=status.HTTP_400_BAD_REQUEST)

            if not department_id:
                return Response({'message': 'department_id not found'}, status=status.HTTP_400_BAD_REQUEST)

            if not academic_year_id:
                return Response({'message': 'academic year not found'}, status=status.HTTP_400_BAD_REQUEST)

            if not semester_id:
                return Response({'message': 'semester_id not found'}, status=status.HTTP_400_BAD_REQUEST)

            if not section_id:
                return Response({'message': 'section_id not found'}, status=status.HTTP_400_BAD_REQUEST)

            # if not subject_id:
            #     return Response({'message':'subject_id not found'},status=status.HTTP_400_BAD_REQUEST)

            if date:
                try:
                    date_obj = datetime.strptime(date, '%Y-%m-%d')
                    day_of_week = date_obj.strftime('%A')  # Converts to full weekday name, e.g., "Monday"
                except ValueError:
                    return Response({"error": "Invalid date format. Use 'YYYY-MM-DD'."},
                                    status=status.HTTP_400_BAD_REQUEST)

            TimeTableInstance = None
            # filter record provide parameter's
            try:
                TimeTableInstance = TimeTable.objects.filter(organization=organization_id, branch=branch_id,
                                                             batch=batch_id, course=course_id, department=department_id,
                                                             academic_year=academic_year_id,
                                                             semester=semester_id, section=section_id,
                                                             schedule_day=day_of_week.lower(), is_active=True)
            except ObjectDoesNotExist:
                data = []

            # if not organization:
            #     return Response({'message': 'organization not found'}, status=status.HTTP_400_BAD_REQUEST)
            # if not branchId:
            #     return Response({'message': 'branchId not found'}, status=status.HTTP_400_BAD_REQUEST)

            # if  organization_id and branch_id and batch_id and course_id and department_id and academic_year_id and semester_id and section_id:
            #     lecture_record = Lecture.objects.filter(organization=organization_id,branch=branch_id,batch=batch_id,course=course_id,department=department_id,academic_year=academic_year_id,semester=semester_id,section=section_id,is_active=True)
            # else:
            #     return Response({'error': 'organization_id, branch_id, batch_id, course_id, department_id, academic_year_id, semester_id and section_id is required !!!'}, status=status.HTTP_400_BAD_REQUEST)

            responsedata = []
            if TimeTableInstance:
                for item in TimeTableInstance:
                    data = {
                        'id': item.id,
                        'lecture_name': item.lecture.lecture_name,
                        'lecture_description': item.lecture.lecture_description,
                        'is_active': item.is_active,
                        'day_attendance': item.lecture.day_attendance
                    }

                    responsedata.append(data)
            if responsedata:
                return Response({'message': 'success', 'data': responsedata}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'success', 'data': responsedata}, status=status.HTTP_200_OK)

        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='GetLectureList',

            message=error_message,

        )


class GetLectureAPIView(ListAPIView):
    queryset = Lecture.objects.all()
    serializer_class = LectureSerializer

    def list(self, request, *args, **kwargs):
        try:
            lecture_id = request.query_params.get('lecture_id')
            # branchId = self.kwargs.get('branch_id')

            # validate data

            # if not organization:
            #     return Response({'message': 'organization not found'}, status=status.HTTP_400_BAD_REQUEST)
            # if not branchId:
            #     return Response({'message': 'branchId not found'}, status=status.HTTP_400_BAD_REQUEST)

            # try:
            if lecture_id:
                lecture_record = Lecture.objects.filter(id=lecture_id, is_active=True)
            else:
                return Response({'error': 'lecture_id is required !!!'}, status=status.HTTP_400_BAD_REQUEST)

            # except :
            #     lecture_record=[]

            responsedata = []
            if lecture_record:
                for item in lecture_record:
                    data = {
                        'id': item.id,
                        'lecture_name': item.lecture_name,
                        'lecture_description': item.lecture_description,
                        'is_active': item.is_active,
                        'day_attendance': item.day_attendance
                    }

                    responsedata.append(data)
            if responsedata:
                return Response({'message': 'success', 'data': responsedata}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'success', 'data': responsedata}, status=status.HTTP_200_OK)

        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)


        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='GetLectureById',

            message=error_message,

        )


class GetSearchProfessorBasedOnConditionListAPIView(ListAPIView):
    # queryset = EmployeeMaster.objects.all()
    serializer_class = EmployeeSearchSerializer

    def list(self, request, *args, **kwargs):
        try:
            organization = request.query_params.get('organization_id')
            branchId = request.query_params.get('branch_id')
            employee_id = request.query_params.get('employeeId')
            # employeeName = request.query_params.get('employeeName')
            employeecode = request.query_params.get('employee_code')
            department_id = request.query_params.get('department_id')
            designation_id = request.query_params.get('designation_id')

            if not organization:
                return Response({'message': 'please provide valid OrgId '})

            if not branchId:
                return Response({'message': 'please provide valid branchId '})

            # get filter data
            filterdata = EmployeeMaster.objects.filter(organization=organization, is_active=True)

            finalresponseData = []
            if filterdata:

                # check condition
                if employee_id:
                    filterdata = filterdata.filter(id=employee_id)
                #
                # if employeeName:
                #     filterdata = filterdata.filter()

                if employeecode:
                    filterdata = filterdata.filter(employee_code=employee_id)

                if department_id:
                    filterdata = filterdata.filter(department=department_id)

                if designation_id:
                    filterdata = filterdata.filter(designation=designation_id)

                for item in filterdata:
                    employee_name_parts = filter(
                        None,
                        [
                            item.title,
                            item.first_name,
                            item.middle_name,
                            item.last_name,
                        ],
                    )
                    employee_name = " ".join(employee_name_parts)

                    data = {
                        'id': item.id,
                        'organization': item.organization.id,
                        'organizationName': item.organization.organization_code,
                        # 'branch_id': item.branch_id.id,
                        # 'branchName': item.branch_id.branch_name,
                        'department': item.department,
                        'department_name': item.department.department_code,
                        'designation': item.designation,
                        'designation_name': item.designation.designation_name,
                        'employee_code': item.employee_code,
                        'employeeName': employee_name,
                        'date_of_birth': item.date_of_birth,
                        'marital_status': item.marital_status,
                        'gender': item.gender,
                        'nationalityId': item.nationality.id,
                        'nationality': item.nationality.nationality_code,
                        'religionId': item.religion.id,
                        'religion': item.religion.religion_code,
                        'email': item.email,
                        'phone_number': item.phone_number,
                        'office_email': item.office_email,
                        'employee_typeId': item.employee_type.employee_type_id,
                        'employee_type': item.employee_type.employee_type,
                        'date_of_joining': item.date_of_joining,
                        'date_of_leaving': item.date_of_leaving,
                        'payroll_group': item.payroll_group,
                        'place_of_birth': item.place_of_birth,
                        'blood_groupId': item.blood_group.id,
                        'blood_group': item.blood_group.blood_code,
                        'highest_qualification': item.highest_qualification,
                        'emergency_contact_number': item.emergency_contact_number,
                        'mother_tongueId': item.mother_tongue.id,
                        'mother_tongue': item.mother_tongue.language_code,
                        'status': item.status

                    }

                    finalresponseData.append(data)

                return Response({'message': 'success', 'data': finalresponseData}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No record Found'}, status=status.HTTP_200_OK)

        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)



        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='GetSearchEmployee',

            message=error_message,

        )


class GetTeacherListAPIView(ListAPIView):
    """
    Returns a filtered list of employees/teachers based on query params.
    Expected query params (all optional except orgId, branchId):
    - orgId, branchId
    - employeeId
    - employee_code
    - department_id
    - designation_id
    """

    serializer_class = EmployeeSearchSerializer

    def list(self, request, *args, **kwargs):
        # Validate and normalize incoming query params
        try:
            serializer = self.serializer_class(data=request.query_params)
            serializer.is_valid(raise_exception=True)
        except ValidationError as e:
            # Return proper 400 instead of logging as 500
            return Response(e.detail, status=status.HTTP_400_BAD_REQUEST)

        params = serializer.validated_data

        org_id = params.get("orgId")
        branch_id = params.get("branchId")
        employee_id = params.get("employeeId")
        employee_code = params.get("employee_code")
        department_id = params.get("department_id")
        designation_id = params.get("designation_id")

        try:
            # Base queryset
            queryset = EmployeeMaster.objects.filter(
                organization_id=org_id,
                branch_id=branch_id,
                is_active=True,
            )

            # Apply filters
            if employee_id:
                queryset = queryset.filter(id=employee_id)

            if employee_code:
                queryset = queryset.filter(employee_code=employee_code)

            # EmployeeMaster does not have department FK directly; filter via designation.department if both provided
            if department_id:
                queryset = queryset.filter(designation__department_id=department_id)

            if designation_id:
                queryset = queryset.filter(designation_id=designation_id)

            if not queryset.exists():
                return Response({"message": "No record Found"}, status=status.HTTP_200_OK)

            response_data = []
            for item in queryset:
                # Build full employee name
                name_parts = [
                    item.title,
                    item.first_name,
                    item.middle_name,
                    item.last_name,
                ]
                employee_name = " ".join(part for part in name_parts if part)

                department = getattr(item.designation, "department", None)

                data = {
                    "id": item.id,
                    "organization": item.organization.id,
                    "organizationName": item.organization.organization_code,
                    "branch": item.branch.id,
                    "branchName": item.branch.branch_name,
                    # Department / Designation
                    "department": department.id if department else None,
                    "department_name": department.department_code if department else None,
                    "designation": item.designation.id if item.designation_id else None,
                    "designation_name": item.designation.designation_name
                    if item.designation_id
                    else None,
                    # Basic details
                    "employee_code": item.employee_code,
                    "employeeName": employee_name,
                    "date_of_birth": item.date_of_birth,
                    "marital_status": item.marital_status,
                    "gender": item.gender.id if hasattr(item.gender, "id") else None,
                    # Nationality / Religion
                    "nationalityId": item.nationality.id,
                    "nationality": item.nationality.nationality_code,
                    "religionId": item.religion.id,
                    "religion": item.religion.religion_code,
                    # Contact
                    "email": item.email,
                    "phone_number": item.phone_number,
                    "office_email": item.office_email,
                    # Employee type
                    "employee_typeId": item.employee_type.id,
                    "employee_type": getattr(
                        item.employee_type, "employee_type_description", None
                    ),
                    # Job info
                    "date_of_joining": item.date_of_joining,
                    "date_of_leaving": item.date_of_leaving,
                    "payroll_group": item.payroll_group,
                    "place_of_birth": item.place_of_birth,
                    # Misc
                    "blood_groupId": item.blood_group.id,
                    "blood_group": item.blood_group.blood_code,
                    "highest_qualification": item.highest_qualification,
                    "emergency_contact_number": item.emergency_contact_number,
                    "mother_tongueId": item.mother_tongue.id,
                    "mother_tongue": item.mother_tongue.mother_tongue_code,
                    "status": item.status,
                }

                response_data.append(data)

            return Response({"message": "success", "data": response_data}, status=status.HTTP_200_OK)

        except Http404:
            return Response({"message": "Record not found"}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:
            error_message = str(e)
            self.log_exception(request, error_message)
            return Response({"error": error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):
        ExceptionTrack.objects.create(
            request=str(request),
            process_name="GetTeacherList",
            message=error_message,
        )


class GetStateBasedOnCountryListAPIView(ListAPIView):
    serializer_class = StateSerializer

    def list(self, request, *args, **kwargs):
        try:

            countryId = self.kwargs.get('country_id')

            # Get All state based on country
            all_state_list = None
            try:
                all_state_list = State.objects.filter(country_id=countryId, is_active=True)
            except:
                all_state_list = None

            if all_state_list:

                responsedata = []

                # Iterate the list of object to get details
                for item in all_state_list:
                    data = {
                        'id': item.id,  # get('id'),
                        'state_code': item.state_code,  # get('state_code'),
                        'state_name': item.state_name  # get('state_desc'),
                    }

                    responsedata.append(data)

                return Response({'message': 'success', 'data': responsedata}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record found'}, status=status.HTTP_200_OK)

        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)



        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='GetAllStateListBasedOnCountry',

            message=error_message,

        )


class GetCityBasedOnStateListAPIView(ListAPIView):
    serializer_class = CitySerializer

    def list(self, request, *args, **kwargs):
        try:

            stateId = self.kwargs.get('state_id')

            # Get All state based on country
            all_city_list = None
            try:
                all_city_list = City.objects.filter(state_id=stateId, is_active=True)
            except:
                all_city_list = None

            if all_city_list:
                responsedata = []

                # Iterate the list of object to get details
                for item in all_city_list:
                    data = {
                        'id': item.id,
                        'city_name': item.city_name,

                    }

                    responsedata.append(data)

                return Response({'message': 'success', 'data': responsedata}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record found'}, status=status.HTTP_200_OK)

        except Http404:

            return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)



        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='GetAllCityListBasedOnState',

            message=error_message,

        )


# class TermListAPIView(ListAPIView):
#     serializer_class = TermSerializer
#
#     def list(self, request, *args, **kwargs):
#         try:
#
#             serializer = self.get_serializer(data=request.query_params)
#             serializer.is_valid(raise_exception=True)
#
#             academic_year_id= serializer.validated_data.get('academic_year_id')
#             organization = serializer.validated_data.get('organization')
#             # branch_id = serializer.validated_data.get('branch_id')
#
#
#             # Get Term Filter
#             try:
#                 TermRecordData = TERM_MASTER.objects.filter(academic_year_id=academic_year_id,
#                                                                 organization=organization,is_active=True)
#             except:
#                 TermRecordData = None
#
#             if TermRecordData:
#                 responseData = []
#
#                 for item in TermRecordData:
#                     data ={
#                         'Term_Id':item.Term_Id,
#                         'term_desc': item.term_desc,
#                         'sorting_order': item.sorting_order
#                     }
#
#                     responseData.append(data)
#                 return Response({'message':'success','data':responseData},status=status.HTTP_200_OK)
#             else:
#                 return Response({'message': 'No record Found'}, status=status.HTTP_200_OK)
#
#
#         except ValidationError as e:
#             return Response({'message':e.details},status=status.HTTP_400_BAD_REQUEST)
#
#         except Http404:
#
#             return Response({'message': 'Record not found'}, status=status.HTTP_404_NOT_FOUND)
#
#
#
#         except Exception as e:
#
#             # Log the exception
#
#             error_message = str(e)
#
#             self.log_exception(request, error_message)
#
#             return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
#
#     def log_exception(self, request, error_message):
#
#         ExceptionTrack.objects.create(
#
#             request=str(request),
#
#             process_name='GetAllTermList',
#
#             message=error_message,
#
#         )

class EmployeeTypeListAPIView(ListAPIView):
    queryset = EmployeeType.objects.filter(is_active=True)
    serializer_class = StaffEmployeeTypeSerializer

    def list(self, request, *args, **kwargs):
        try:
            response = super().list(request, *args, **kwargs)
            resdata = response.data

            # prepare data from response

            if resdata:
                responsedata = []
                for item in resdata:
                    # Prepare the custom response data
                    responsedata.append({
                        'id': item.get('id'),
                        'employee_type_code': item.get('employee_type_code'),
                        'employee_type_description': item.get('employee_type_description')

                    })

                if responsedata:

                    return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
                else:
                    return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

            else:
                return Response({'message': 'No Record Found!'}, status=status.HTTP_200_OK)

        except Exception as e:

            # Log the exception

            error_message = str(e)

            self.log_exception(request, error_message)

            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def log_exception(self, request, error_message):

        ExceptionTrack.objects.create(

            request=str(request),

            process_name='EmployeeTypelist',

            message=error_message,

        )


class StudentsListAPIView(ListAPIView):
    queryset = StudentRegistration.objects.filter(is_active=True)
    serializer_class = StudentsSerializer

    def get_queryset(self):
        params = self.request.query_params
        filters = {
            'organization__icontains': params.get('organization'),
            'branch_id__icontains': params.get('course_name'),
            'academic_year_id': params.get('academicyearId'),
        }
        # 'admission_year': params.get('admission_year'),
        # Remove any None values
        filters = {k: v for k, v in filters.items() if v is not None}
        return StudentRegistration.objects.filter(is_active=True, **filters)

    def list(self, request, *args, **kwargs):
        queryset = self.get_queryset()
        serializer = self.get_serializer(queryset, many=True)
        return Response({
            "status": 'success',
            "message": "Student list fetched successfully",
            "data": serializer.data
        })


class GetBranchData(APIView):
    def get(self, request):
        organization_id = request.query_params.get('organization_id')
        # organization_id = request.query_params.get('organization_id')
        if not organization_id:
            return Response({'message': 'Please provide required data !!!'}, status=status.HTTP_400_BAD_REQUEST)
        branches = Branch.objects.filter(organization=organization_id)
        serializer = Branch_Serializer(branches, many=True)
        return Response(serializer.data)


class GetBatchData(APIView):
    def get(self, request):
        organization_id = request.query_params.get('organization_id')
        branch_id = request.query_params.get('branch_id')
        if not (organization_id and branch_id):
            return Response({'message': 'Please provide required data !!!'}, status=status.HTTP_400_BAD_REQUEST)

        # Reuse the same filtering logic as other batch list APIs
        batches_qs = Batch.objects.filter(is_active=True)
        batches_qs = batches_qs.filter(organization=organization_id, branch=branch_id)

        serializer = Batch_Serializer(batches_qs, many=True)
        return Response(serializer.data)


class GetCourseData(APIView):
    def get(self, request):
        organization_id = request.query_params.get('organization_id')
        branch_id = request.query_params.get('branch_id')
        batch_id = request.query_params.get('batch_id')
        batch_ids = request.query_params.get('batch_ids')

        if not (organization_id and branch_id):
            return Response({'message': 'Please provide required data !!!'}, status=status.HTTP_400_BAD_REQUEST)
        
        courses = Course.objects.filter(organization=organization_id, branch=branch_id)
        
        if batch_ids:
            try:
                batch_ids = json.loads(batch_ids)
                courses = courses.filter(batch__in=batch_ids)
            except:
                pass
        elif batch_id:
            courses = courses.filter(batch=batch_id)
            
        serializer = Course_Serializer(courses, many=True)
        return Response(serializer.data)


class GetDepartmentData(APIView):
    def get(self, request):
        organization_id = request.query_params.get('organization_id')
        branch_id = request.query_params.get('branch_id')
        batch_id = request.query_params.get('batch_id')
        batch_ids = request.query_params.get('batch_ids')
        course_id = request.query_params.get('course_id')
        course_ids = request.query_params.get('course_ids')

        if not (organization_id and branch_id):
            return Response({'message': 'Please provide required data !!!'}, status=status.HTTP_400_BAD_REQUEST)
        departments = Department.objects.filter(organization=organization_id, branch=branch_id, is_active=True)
        
        if batch_ids:
            try:
                batch_ids = json.loads(batch_ids)
                departments = departments.filter(batch__in=batch_ids)
            except:
                pass
        elif batch_id:
             departments = departments.filter(batch=batch_id)

        if course_ids:
            try:
                course_ids = json.loads(course_ids)
                departments = departments.filter(course__in=course_ids)
            except:
                pass
        elif course_id:
            departments = departments.filter(course=course_id)
            
        serializer = Department_Serializer(departments, many=True)
        return Response(serializer.data)


class GetAcademicYearData(APIView):
    def get(self, request):
        organization_id = request.query_params.get('organization_id')
        branch_id = request.query_params.get('branch_id')
        batch_id = request.query_params.get('batch_id')
        batch_ids = request.query_params.get('batch_ids')
        course_id = request.query_params.get('course_id')
        course_ids = request.query_params.get('course_ids')
        department_id = request.query_params.get('department_id')
        department_ids = request.query_params.get('department_ids')

        if not (organization_id and branch_id):
            return Response({'message': 'Please provide required data !!!'}, status=status.HTTP_400_BAD_REQUEST)
        
        academic_years = AcademicYear.objects.filter(organization=organization_id, branch=branch_id).order_by('display_order', 'id')

        if batch_ids:
            try:
                batch_ids = json.loads(batch_ids)
                academic_years = academic_years.filter(batch__in=batch_ids)
            except:
                pass
        elif batch_id:
             academic_years = academic_years.filter(batch=batch_id)

        if course_ids:
            try:
                course_ids = json.loads(course_ids)
                academic_years = academic_years.filter(course__in=course_ids)
            except:
                pass
        elif course_id:
            academic_years = academic_years.filter(course=course_id)

        if department_ids:
            try:
                department_ids = json.loads(department_ids)
                academic_years = academic_years.filter(department__in=department_ids)
            except:
                 pass
        elif department_id:
            academic_years = academic_years.filter(department=department_id)

        serializer = AcademicYear_Serializer(academic_years, many=True)
        return Response(serializer.data)


class GetAcademicYearByOrgBranch(APIView):
    """
    GET: Fetch all available academic sessions (academic years) filtered by organization and branch.

    Query params:
    - organization_id: Required - Organization ID
    - branch_id: Required - Branch ID

    Returns: List of active academic years for the given org and branch.
    """

    def get(self, request):
        try:
            organization_id = request.query_params.get('organization_id')
            branch_id = request.query_params.get('branch_id')

            if not organization_id or not branch_id:
                return Response(
                    {'message': 'organization_id and branch_id are required'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            # Validate organization and branch exist
            try:
                organization = Organization.objects.get(id=organization_id, is_active=True)
                branch = Branch.objects.get(id=branch_id, organization=organization, is_active=True)
            except (Organization.DoesNotExist, Branch.DoesNotExist):
                return Response(
                    {'message': 'Invalid organization_id or branch_id'},
                    status=status.HTTP_404_NOT_FOUND
                )

            # Get all active academic years for this org and branch
            academic_years = AcademicYear.objects.filter(
                organization_id=organization_id,
                branch_id=branch_id,
                is_active=True
            ).order_by('display_order', 'id').distinct()

            response_data = []
            for ay in academic_years:
                response_data.append({
                    'id': ay.id,
                    'academic_year_code': ay.academic_year_code,
                    'academic_year_description': ay.academic_year_description,
                    'date_from': ay.date_from,
                    'date_to': ay.date_to,
                    'organization_id': ay.organization.id,
                    'organization_code': ay.organization.organization_code,
                    'branch_id': ay.branch.id,
                    'branch_name': ay.branch.branch_name,
                    'batch_id': ay.batch.id if ay.batch else None,
                    'batch_code': ay.batch.batch_code if ay.batch else None,
                    'course_id': ay.course.id if ay.course else None,
                    'course_code': ay.course.course_code if ay.course else None,
                    'course_name': ay.course.course_name if ay.course else None,
                    'department_id': ay.department.id if ay.department else None,
                    'department_code': ay.department.department_code if ay.department else None,
                    'is_active': ay.is_active,
                    'created_at': ay.created_at,
                    'updated_at': ay.updated_at,
                })

            return Response(
                {'message': 'success', 'data': response_data},
                status=status.HTTP_200_OK
            )

        except Exception as e:
            error_message = str(e)
            ExceptionTrack.objects.create(
                request=str(request),
                process_name='GetAcademicYearByOrgBranch',
                message=error_message,
            )
            return Response(
                {'error': error_message},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class GetSemesterData(APIView):
    def get(self, request):
        organization_id = request.query_params.get('organization_id')
        branch_id = request.query_params.get('branch_id')
        batch_id = request.query_params.get('batch_id')
        batch_ids = request.query_params.get('batch_ids')
        course_id = request.query_params.get('course_id')
        course_ids = request.query_params.get('course_ids')
        department_id = request.query_params.get('department_id')
        department_ids = request.query_params.get('department_ids')
        academic_year_id = request.query_params.get('academic_year_id')
        academic_year_ids = request.query_params.get('academic_year_ids')

        if not (organization_id and branch_id):
            return Response({'message': 'Please provide required data !!!'}, status=status.HTTP_400_BAD_REQUEST)
        
        semesters = Semester.objects.filter(organization=organization_id, branch=branch_id).order_by('display_order', 'id')

        if batch_ids:
            try:
                batch_ids = json.loads(batch_ids)
                semesters = semesters.filter(batch__in=batch_ids)
            except:
                pass
        elif batch_id:
             semesters = semesters.filter(batch=batch_id)

        if course_ids:
            try:
                course_ids = json.loads(course_ids)
                semesters = semesters.filter(course__in=course_ids)
            except:
                pass
        elif course_id:
            semesters = semesters.filter(course=course_id)

        if department_ids:
            try:
                department_ids = json.loads(department_ids)
                semesters = semesters.filter(department__in=department_ids)
            except:
                 pass
        elif department_id:
            semesters = semesters.filter(department=department_id)

        if academic_year_ids:
            try:
                academic_year_ids = json.loads(academic_year_ids)
                semesters = semesters.filter(academic_year__in=academic_year_ids)
            except:
                pass
        elif academic_year_id:
            semesters = semesters.filter(academic_year=academic_year_id)

        serializer = Semester_Serializer(semesters, many=True)
        return Response(serializer.data)


class GetSemesterDataByDepartment(APIView):
    def get(self, request):
        organization_id = request.query_params.get('organization_id')
        branch_id = request.query_params.get('branch_id')
        batch_id = request.query_params.get('batch_id')
        course_id = request.query_params.get('course_id')
        department_id = request.query_params.get('department_id')
        # academic_year_id = request.query_params.get('academic_year_id')

        if not (organization_id and branch_id and batch_id and course_id and department_id):
            return Response({'message': 'Please provide required data !!!'}, status=status.HTTP_400_BAD_REQUEST)
        semesters = Semester.objects.filter(organization=organization_id, branch=branch_id, batch=batch_id,
                                            course=course_id, department=department_id).order_by('display_order', 'id')
        serializer = Semester_Serializer(semesters, many=True)
        return Response(serializer.data)


class GetSectionData(APIView):
    def get(self, request):
        organization_id = request.query_params.get('organization_id')
        branch_id = request.query_params.get('branch_id')
        batch_id = request.query_params.get('batch_id')
        batch_ids = request.query_params.get('batch_ids')
        course_id = request.query_params.get('course_id')
        course_ids = request.query_params.get('course_ids')
        department_id = request.query_params.get('department_id')
        department_ids = request.query_params.get('department_ids')
        academic_year_id = request.query_params.get('academic_year_id')
        academic_year_ids = request.query_params.get('academic_year_ids')
        semester_id = request.query_params.get('semester_id')
        semester_ids = request.query_params.get('semester_ids')

        if not (organization_id and branch_id):
            return Response({'message': 'Please provide required data !!!'}, status=status.HTTP_400_BAD_REQUEST)
        
        sections = Section.objects.filter(organization=organization_id, branch=branch_id)

        if batch_ids:
            try:
                batch_ids = json.loads(batch_ids)
                sections = sections.filter(batch__in=batch_ids)
            except:
                pass
        elif batch_id:
             sections = sections.filter(batch=batch_id)

        if course_ids:
            try:
                course_ids = json.loads(course_ids)
                sections = sections.filter(course__in=course_ids)
            except:
                pass
        elif course_id:
            sections = sections.filter(course=course_id)

        if department_ids:
            try:
                department_ids = json.loads(department_ids)
                sections = sections.filter(department__in=department_ids)
            except:
                 pass
        elif department_id:
            sections = sections.filter(department=department_id)

        if academic_year_ids:
            try:
                academic_year_ids = json.loads(academic_year_ids)
                sections = sections.filter(academic_year__in=academic_year_ids)
            except:
                pass
        elif academic_year_id:
            sections = sections.filter(academic_year=academic_year_id)

        if semester_ids:
            try:
                semester_ids = json.loads(semester_ids)
                sections = sections.filter(semester__in=semester_ids)
            except:
                pass
        elif semester_id:
            sections = sections.filter(semester=semester_id)

        serializer = Section_Serializer(sections, many=True)
        return Response(serializer.data)


# <<<<<<< HEAD
class GetFeeStructureDetail(APIView):
    def get(self, request):
        organization_id = request.query_params.get('organization_id')
        branch_id = request.query_params.get('branch_id')
        element_type_id = request.query_params.get('element_type_id')
        fee_frequency_id = request.query_params.get('fee_frequency_id')

        if not (element_type_id and fee_frequency_id):
            return Response({'message': 'Please provide element_type_id and fee_frequency_id data !!!'},
                            status=status.HTTP_404_NOT_FOUND)
        try:
            fee_structure_detail = FeeStructureDetail.objects.get(element_type=element_type_id,
                                                                  element_frequency=fee_frequency_id, is_active=True)
        except FeeStructureDetail.DoesNotExist:
            return Response({"message": "fee_structure_detail record not found !!!"}, status=status.HTTP_404_NOT_FOUND)
        serializer = FeeStructureDetail_Serializer(fee_structure_detail)
        return Response(serializer.data)


class GetFeeFrequencyDetail(APIView):
    def get(self, request):
        organization_id = request.query_params.get('organization_id')
        branch_id = request.query_params.get('branch_id')
        # element_type_id = request.query_params.get('element_type_id')
        fee_frequency_id = request.query_params.get('fee_frequency_id')

        if not fee_frequency_id:
            return Response({'message': 'Please provide fee_frequency_id !!!'}, status=status.HTTP_404_NOT_FOUND)
        try:
            fee_frequency_detail = FeeFrequency.objects.get(id=fee_frequency_id, is_active=True)
        except FeeFrequency.DoesNotExist:
            return Response({"message": "fee_frequency record not found !!!"}, status=status.HTTP_404_NOT_FOUND)
        serializer = FeeFrequency_Serializer(fee_frequency_detail)
        return Response(serializer.data)


# class GetFeeFrequencyDetail(APIView):
#     def get(self, request):
#         organization_id = request.query_params.get('organization_id')
#         branch_id = request.query_params.get('branch_id')
#         batch_id = request.query_params.get('batch_id')
#         course_id = request.query_params.get('course_id')
#         department_id = request.query_params.get('department_id')
#         element_type_id = request.query_params.get('element_type_id')
#         fee_frequency_id = request.query_params.get('fee_frequency_id')
#
#         if not (element_type_id and fee_frequency_id):
#             return Response({'message': 'Please provide element_type_id and fee_frequency_id data !!!'}, status=status.HTTP_404_NOT_FOUND)
#         try:
#             fee_structure_detail = FeeStructureDetail.objects.get(element_type=element_type_id,element_frequency=fee_frequency_id,is_active=True)
#         except FeeStructureDetail.DoesNotExist:
#             return Response({"message":"fee_structure_detail record not found !!!"}, status=status.HTTP_404_NOT_FOUND)
#         serializer = FeeStructureDetail_Serializer(fee_structure_detail)
#         return Response(serializer.data)
# =======
class TermListAPIView(ListAPIView):
    """
    Returns Semester data as Term data for frontend compatibility.
    This project uses Semester instead of Term.
    """
    serializer_class = SemesterSerializer

    def list(self, request, *args, **kwargs):
        try:
            academic_year_id = request.query_params.get('academic_year_id')
            org_id = request.query_params.get('org_id')
            branch_id = request.query_params.get('branch_id')

            filterdata = Semester.objects.filter(is_active=True)

            if org_id:
                filterdata = filterdata.filter(organization_id=org_id)

            if branch_id:
                filterdata = filterdata.filter(branch_id=branch_id)

            if academic_year_id:
                filterdata = filterdata.filter(academic_year_id=academic_year_id)

            if filterdata.exists():
                responsedata = []
                for item in filterdata:
                    responsedata.append({
                        "term_id": item.id,
                        "term_code": item.semester_code,
                        "term_description": item.semester_description,
                        "semester_id": item.id,
                        "semester_code": item.semester_code,
                        "semester_description": item.semester_description,
                    })
                return Response({'message': 'Success', 'data': responsedata}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'No Record Found!', 'data': []}, status=status.HTTP_200_OK)

        except Exception as e:
            error_message = str(e)
            ExceptionTrack.objects.create(
                request=str(request),
                process_name='TermListAPIView',
                message=error_message,
            )
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class SendOTPView(APIView):
    def post(self, request):
        try:
            organization_id = request.data.get("organization_id")
            branch_id = request.data.get("branch_id")
            email = request.data.get("email")
            username = request.data.get("username")

            if username:
                student_registration_instance = StudentRegistration.objects.get(organization=organization_id,
                                                                                branch=branch_id,
                                                                                user_name__iexact=username)
                user_email = student_registration_instance.email
                # user_email = 'bic.void@gmail.com'
                try:
                    user = UserLogin.objects.get(organization=organization_id, branch=branch_id,
                                                 user_name__iexact=username)
                except UserLogin.DoesNotExist:
                    return Response({"error": "UserLogin record not found"}, status=404)

                otp = generate_otp()
                PasswordResetOTP.objects.create(user_login=user, otp=otp)
                send_otp_email(user_email, otp)

                return Response({"message": "OTP sent successfully"}, status=200)

            if email:
                try:
                    user_login_instance = UserLogin.objects.get(organization=organization_id, branch=branch_id,
                                                                user_name__iexact=email)
                except UserLogin.DoesNotExist:
                    return Response({"error": "UserLogin record not found"}, status=404)

                otp = generate_otp()
                PasswordResetOTP.objects.create(user_login=user_login_instance, otp=otp)
                send_otp_email(email, otp)

                return Response({"message": "OTP sent successfully"}, status=200)

            if not email and not username:
                return Response({"error": "email or username is required"}, status=400)
        except Exception as e:
            error_message = str(e)
            ExceptionTrack.objects.create(
                request=str(request),
                process_name='ForgotPasswordSendOtp',
                message=error_message,
            )
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    # try:
    #     user = User.objects.get(email=email)
    # except User.DoesNotExist:
    #     return Response({"error": "User not found"}, status=404)
    #
    # otp = generate_otp()
    # PasswordResetOTP.objects.create(user=user, otp=otp)
    # send_otp_email(email, otp)

    # return Response({"message": "OTP sent successfully"}, status=200)


class VerifyOTPView(APIView):
    def post(self, request):
        try:
            organization_id = request.data.get("organization_id")
            branch_id = request.data.get("branch_id")
            username = request.data.get("username")
            email = request.data.get("email")
            otp = request.data.get("otp")

            if not email and not otp:
                return Response({"error": "Email and OTP required"}, status=400)

            if not username and not otp:
                return Response({"error": "Username and OTP required"}, status=400)

            if email:
                try:
                    user_login_instance = UserLogin.objects.get(organization=organization_id, branch=branch_id,
                                                                user_name__iexact=email)
                    otp_obj = PasswordResetOTP.objects.filter(
                        user_login=user_login_instance, otp=otp, is_verified=False
                    ).latest("created_at")
                except (UserLogin.DoesNotExist, PasswordResetOTP.DoesNotExist):
                    return Response({"error": "Invalid OTP"}, status=400)
                if otp_obj.is_expired():
                    return Response({"error": "OTP expired"}, status=400)

                otp_obj.is_verified = True
                otp_obj.save()

                return Response({"message": "OTP verified"}, status=200)
            if username:
                try:
                    # student_registration_instance = StudentRegistration.objects.get(organization=organization_id,
                    #                                                                 branch=branch_id,
                    #                                                                 user_name__iexact=username)
                    user_login_instance = UserLogin.objects.get(organization=organization_id, branch=branch_id,
                                                                user_name__iexact=username)
                    otp_obj = PasswordResetOTP.objects.filter(
                        user_login=user_login_instance, otp=otp, is_verified=False
                    ).latest("created_at")
                except (UserLogin.DoesNotExist, PasswordResetOTP.DoesNotExist):
                    return Response({"error": "Invalid OTP"}, status=400)

                if otp_obj.is_expired():
                    return Response({"error": "OTP expired"}, status=400)

                otp_obj.is_verified = True
                otp_obj.save()

                return Response({"message": "OTP verified"}, status=200)

        except Exception as e:
            error_message = str(e)
            ExceptionTrack.objects.create(
                request=str(request),
                process_name='ForgotPasswordVerifyOtp',
                message=error_message,
            )
            return Response({'error': error_message}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
